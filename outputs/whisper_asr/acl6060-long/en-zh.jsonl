{"dataset_id": "acl_6060", "sample_id": 416, "src_lang": "en", "tgt_lang": "en", "output": "Hello, my name is Asaf Harari and I will present our paper, Few-Shot Tabular Data Enrichment Using Fine-Tuning Transformers Architectures. Data scientists analyze data and mainly focus on manipulating the data existing features. But sometimes these features are limited. Feature generation using another data source may add substantial information. Our research goal is automatic tabular data enrichment using external sources free text. Feature generation using another data source may add substantial information. Our research goal is automatic tabular data enrichment using external sources free text. Assume we have a tabular data set and a knowledge base. We need an automatic process which involves entity linking and text analysis to extract new features from the knowledge base free text. Our framework, FAST, is exactly this automatic process. So let's see an example. In a data set fed into FAST. In this example, the data set is university data set when its goal is to classify universities into low-ranked universities and high-ranked universities. the dataset is university dataset when its goal is to classify universities into low-ranked universities and high-ranked universities. As knowledge base, we use Wikipedia. The first phase of FIST is entity linking. When each entity, in this example, the university name, linked to an entity within the knowledge base. And the text of the entities of the knowledge base is extracted and added to the dataset. In this example, the text is the Wikipedia page abstract. Now we need to generate or extract features from the retrieved text. So we need a feature extraction phase, which include text analysis. And this is the main novelty of this paper, and I will deep dive into it in the next slides. After the feature extraction phase, there is a feature generation phase when we use the extracted features to generate a small number of new features. First, generate features in the number of classes of the original dataset. In this example, the original dataset has two classes, so FAST generates two new features. But if the dataset has five classes, FAST generates five new features. Each feature represents the likelihood for each class. To analyze the text, we use the current state-of-the-art of text analysis, which are transformer-based language models as BERT, GPT, XNL, and etc. But it is not likely that we can train language model using the input datasets. So a naive approach will be a target task fine-tuning. So in the feature extraction phase, we can download peritrain language model, fine-tune the language model over the target dataset. In this example, to fine-tune the language model, to classify text into classes, abstract into classes, low or high, receive the language model output, which is the likelihood for each class, and use as new features. The problem with this approach is dataset may have few distinct entities tags. new features. The problem with this approach is datasets may have few distinct entities' tags. In our experiment, almost half of the datasets contain less than 400 samples, and the smallest dataset contained 35 samples in its training set. So to fine-tune a language model over this data set will be ineffective. But we can use prior knowledge about pre-analyzed data sets because-1 datasets and use this information when we analyze the Nth dataset. What we suggest is to add another fine-tuning phase, a preliminary multitask fine-tuning phase, when you fine-tune the language model over n-1 datasets, and then we execute another fine-tuning phase, which is a target task fine-tuning when we fine-tune the language model over the nth target dataset. The state of the art in multitask fine tuning called mtDNN. In mtDNN, mtDNN maintains heads in the number of tasks in the training set. So in this example there are four tasks in the training set so empty DNN and maintain four heads as you can see it In this example, there are four tasks in the training set. So empty DNN, maintain four heads, as you can see in the image, and it samples a random batch from the training set. And if the random batch belongs to, for example, single sentence classification tasks, it executes forward and backward pass through the first head. And if the random batch belongs to pairwise ranking task, it executes forward and backward pass through the last head. In our scenario, tabular datasets vary in the number of classes. So In our scenario, a Tableau dataset verifies the number of classes. So there are many tasks. MTDNN maintains number of classes heads, output layers, and additionally, MTDNN needs to initialize new heads for a new data set with a new task our approach called task reformulation fine tuning is we in our approach task reformation functioning instead of maintaining multiple heads we reformulate each data set into a sentence per classification problem which is a two classes DAS instead of maintaining multiple heads, we reformulate each dataset into a sentence per classification problem, which is two classes tasks. So let's see an example. Here is our input dataset, which consists of entities, features, text, and classes. and we task from classifying the text into low and high to classify the text, to classify abstract and class, to abstract and class, if the abstract belong to the class or not. So the label vector in Zig's case, is stays always, which consists always with two classes. in Zig's case, it stays always, which consists always with two classes. And this is the. Then it reformulates the task into a sentence per classification tasks. Apply the language model to the new task and the output likelihood for each class. And note that the language model is already fine-tuned over N minus one dataset using a preliminary multitask fine-tuning. Then we use the output vector of dataset using a preliminary multitask fine-tuning. Then we use the output vector of the language model as a newly generated feature in the number of classes. To evaluate our framework, we use a 17 tabular classification dataset, which verifies size, features, balance, domain, and initial performance. And as knowledge base, we use Wikipedia. We design our experiment as live one-out evaluation when we train fast over 16 datasets and apply it to the 17th dataset. We also split each dataset into four faults and apply a four faults cross-validation. Then we generate the new feature and evaluate them using five evaluation classifiers. for false cross-validation. Then we generate the new feature and evaluate them using five evaluation classifiers. We use in our experiment built-based architecture. Here are the results for our experiment. You can see that we compare our is our framework to target a data set fine tuning target task fine tuning and a mtdnn preliminary fine tuning and our reformulated fine tuning achieve the best result the best performance while empty dnn it formulated fine-tuning achieve the best result, the best performance. While MTDNN achieved two percent improvement over the target dataset fine-tuning, our approach achieved six percent improvement. When we look on the small dataset,, we can see that the performance of empty DNN decreases and the improvement of the the target task fine-tuning alone. For summing, FAST enables few-shot enrichment from 35 samples in our experiment. It uses one architecture for all tasks' datasets sets and it keeps the head of the model. But it adds a reformulation phase. It's augmented train set and it needs a target value with semantic meaning so we can fed it into the language model and use it in the sentence per classification problem. Thank you."}
{"dataset_id": "acl_6060", "sample_id": 417, "src_lang": "en", "tgt_lang": "en", "output": "Hi everyone, today I'm going to present our research work, Learning to Reason Detectively, Metabolic Problem Solving as Complex Reason Extraction. I'm Alan from ByteDance AI Lab, and this is a joint work with Jerry from the University of Texas at Austin, and Weilu from SUTD. First, I'd like to talk about our motivation for reasoning. So here we show an example where multi-step reasoning is helpful. So this figure is taken from the pen on paper where they perform prompting to solve the math problem in a few-shot learning scenario. So on the left-hand side, we can see if we give some examples with just questions and answers, we may not be able to obtain the correct answers. But if we give some more reasoning description, the model is able to predict the reasoning description and also make a correct prediction here. So it is good to have interpretable multi-step reasoning as output. And we also think method problem is a straightforward application to evaluate such reasoning abilities. So here in our problem setup, given the questions, we need to solve this question. application to evaluate such reasoning abilities. So here in our problem setup, given the questions, we need to solve this question and obtain the numerical answers. So in our datasets, we are also given the mathematical expression, which leads to this particular answer as well. So certain assumptions also apply as in previous work. We assume the precision of quantities are known and we only consider basic operators such as addition, subtractions, multiplication, division, and exponential. Furthermore, complicated operators can be actually decomposed into these basic operators. So previous work in method problem solving actually can categorize into sequence-to-sequence and sequence-to-tree model. So traditional sequence-to-sequence model convert the expression to a specific sequence for generation, and it is pretty easy to implement, and it can generalize to many different complicated problems. But the drawbacks of the performance is actually generally not better than the structure model. And it is lack of the interpretability for prediction. But actually, this direction is still quite popular because of the transformer model. So in tree-based models, we actually structure these expressions in the tree form and follow a pre-order traversal in three generations. So in tree-based models, we actually structure these expressions in the tree form and follow a pre-order traversal in tree generations. So here we keep generating the operators until we reach the leaves, which are the quantities. So here the good thing is that it actually gives us this binary tree structure. structure and it is but actually it is quite counterintuitive because we generate the operator first and then at the end we generate the structure, but actually it is quite counterintuitive because we generate the operator first and then at the end we generate the quantities. And the second thing is that it also contains some repetitive computations. So here if we look at this expression, a times 3 plus 3, is actually generated twice. But in fact we should reuse the results so in our proposed approach we want to solve those problems in a step-by-step and interpretable manners so for example here in the second step we can obtain this divisor which is 27 and we can also refer back to the original questions to find the relevant contents. And in these steps, we obtain the divisors. So and then at this third step, we actually get the quotient. All right. And after these three steps, we can actually reuse the results from the second step and then get the results of the fourth step. And then finally we can obtain the dividends. So here we actually generate the whole expression directly rather than generating single operators or quantities. So this makes the process more accurate. So in our deductive system, we first start with a bunch of quantities presented in the questions, and also including some constants as our initial states. So the expression is represented by EIJOP, where we perform operator from QI to QJ, and such expression is actually directed. So we also have subtraction reverse here to represent the opposite direction. This is quite similar to relation extraction. So in a formal deductive system, at the time step t, we apply the operator between the QI and QJ pair, and then we obtain this new expressions. We add it to the next state to become a new quantity. So this slide actually visualizes the evolution of the states where we keep adding expressions to the current states. So in our model implementations, we first use a pre-trained language model which can be birds or rabbits, and then we encode a sentence, and then we obtain these quantity representations. So once we get the quantity representations, we can start to do inference. Here we show an example of Q1 to obtain the representation for Q1 divided by Q2 and then times Q3. First we get the pair representation, which is basically just the concatenation between Q1 and Q2. And then we apply a feedforward network, which is parameterized by the operator. And then finally, we obtain the expression representation Q1 divided by Q2. But in practice, in the inference stage, we might be able to get the incorrect expression as well. So here all the possible expression is equal to three times the number of operators. So the nice thing here is that we can easily add constraints to control this search space. For example, if this expression is not allowed, we can simply remove this expression in our search space. So in the second step, we do the same thing, but the only difference is one more quantity. So this quantity comes from the previous calculated expression. So finally, we can obtain this final expression, Q3 times Q4. And we can also see the number of all the possible expressions is different from the previous step. So such differences make it hard to apply beam search because the probability distribution between these two steps is unbalanced. So the training procedure is similar to training a sequence-to-sequence model, where we optimize the loss at each time step. And here we also use this tau to represent when we should terminate this generation process. And here the space is different from sequence-to-sequence, because the space is different at each time step, in traditional sequence to sequence model it is the number of vocabulary and it also allows us to impose certain constraints from prior knowledge so we conduct experiments on the commonly used method problem data sets mawps math23k mathqa MATHQA, and SWAM. And here we briefly show the results compared with the previous best approaches. So our best performing variant is Robeta deductive reasoner. And in fact, we do not use beam search in contrast. Ob the best approaches are often tree-based model. So overall our reasoner is able to significantly outperform this tree-based model, but we can see the absolute number on MathQA or SWAMP are not really high. So we further investigate the results on Swamp, and this data set is challenging because the author tried to manually add something to confuse the NLP model, such as adding irrelevant information and extra quantities. So in our prediction, we find some of the intermediate values are actually negatives. For example, in this question, we are asking how many apples does Jake have, but we have some extra information like 17 fewer peaches, and Steven has 8 peaches, which is totally irrelevant. So our model makes some prediction like this, which is producing negative values. And we observe these two expressions actually have similar scores. So we can actually limit this search space by removing those results as negatives, so that we can make the answer correct. So we further find such constraint actually improves quite a lot for some model. For example, for So we further find such constraint actually improves quite a lot for some model. For example, for birds, we improved seven points. And then for the Robeta-based model, we actually improved two points. So better language model has a better language understanding ability so that the number here is higher for Robeta and lower for birds. And we also try to analyze the difficulty behind all these datasets. We assume the number of unused quantities can be regarded as irrelevant information here. So here we can see that we have the percentage of samples with unused quantities, and the SWAMP dataset has the largest proportion. And here we also show the overall performance. For those samples without unused quantities, so the overall performance is actually higher than the overall performance. But with those samples with unused quantity, it's actually way worse than the overall performance. For MAWPS, we don't really have too many death cases, so I just ignore this part. So finally, we want to show the interpretability through a crash and participation example. So here, our model actually makes wrong prediction at the first step. So we can actually correlate the So here our model actually makes a wrong prediction at the first step. So we can actually correlate this expression with the sentence here. So we think this sentence might be misleading the model to an incorrect prediction. So here, printing another 35 makes the model think it should be an addition operator. So we try to revise the sentence to be something like the number of pear trees are 55 fewer than the apple trees. So we make it to convey more accurate semantics such that the model is able to make the prediction correct. So this study shows how the interpretable predictions help us understand the model behavior. So to conclude our work, so first our model is actually pretty efficient, and we are able to provide interpretable solving procedure. And we can easily incorporate some prior knowledge as constraint, which can help improve the performance. And the last thing is that the underlying mechanism does not only apply to network problem-solving tasks, but also other tasks that involve multi-step reasoning. But we also have certain limitations. If we have a large number of operators or constants, the memory consumption could be pretty high. And the second things that that, as mentioned, because the probability distribution is unbalanced at different time steps, so it's also pretty challenging to apply beam search strategy. So this is the end of the talk, and questions are welcome. Thank you."}
{"dataset_id": "acl_6060", "sample_id": 418, "src_lang": "en", "tgt_lang": "en", "output": "Hi, my name is Antoine and I'm from Maastricht University. I will be presenting my joint work with Jerry which is about a new dataset for statutory article retrieval. Legal issues are an integral part of many people's lives, but the majority of citizens have little to no knowledge about their rights and fundamental legal processes. As a result, many vulnerable citizens who cannot afford the costly assistance of a legal expert are left unprotected or, worst, exploited. Our work aims to bridge the gap between people and the law by developing effective retrieval systems for statutory articles. Such a system could provide a free, legal help service for unskilled humans. Before diving into the main contribution of this work, let's first describe the problem of statutory article retrieval. Given a simple question on a legal matter, such as what do I risk if I violate professional confidentiality, a model is required to retrieve all relevant statutory articles from a large body of legislation. This information retrieval task comes with its own set of challenges. First, it deals with two types of language, common natural language for the questions and complex illegal language for the statutes. This difference in language distributions makes it harder for a system to retrieve relevant candidates, as it indirectly requires an inherent interpretation system that can translate a natural question to a legal question that matches the terminology of statutes. Besides, statutory law is not a stack of independent articles that can be treated as a complete source of information on their own, like news or recipes for example. Instead, it's a structure collection of legal provision that have a whole meaning only when considered in their overall context, that is together with the supplementary information from their neighbouring articles, the fields and subfields they belong to, and their place in the structure of the law. Lastly, statutory articles are in small paragraph, which usually is the typical retrieval unit in most retrieval works. Here, there are long documents that may be up to 6,000 words. The recent advances in NLP have sparked huge interest in many legal tasks, such as legal judgment prediction or automated contract review, but statutory article retrieval has remained mainly untouched due to the lack of large and high quality label datasets. In this work, we present a new French-native citizen-centric dataset to whether retrieval model can approximate the efficiency and reliability of legal experts for the task of statutory article retrieval. Our Belgian statutory article retrieval data set, PSART, consists of more than 1100 legal questions posed by Belgian citizens. These questions cover a wide range of topics, from family, housing, money, to work and social security. Each of them has been labeled by experienced jurists with references to relevant articles from a corpus of more than 22,600 legal articles from Belgian codes of law. Let's now talk about how we collected this data set. First, we started by compiling a large corpus of legal articles. We considered 32 publicly available Belgian codes and extracted all their articles as well as the corresponding section headings. Then, we gathered legal questions with references to relevant statutes. To do so, we partner with a Belgian law firm that receives each year around 4,000 emails from Belgian citizens who ask for advice on a personal legal issue. We were lucky enough to get access to their websites, where their team of experienced jurists addresses Belgian most common legal issues. We collected thousands of questions, annotated with categories, subcategories, and legal references to relevant statutes. Lastly, we parsed the legal references and filtered out the questions whose references were not articles in one of the codes of law we considered. The remaining references were matched and converted to the corresponding article IDs from our corpus. We eventually ended up with 1108 questions, each carefully labeled with the IDs of the relevant articles from our large corpus of 22,633 statutory articles. In addition, each question comes with a main category and a concatenation of subcategories, and each article comes with a concatenation of their subsequent heading in the structure of the law. This extra information is not used in the present work, but might be of interest for future research on legal information retrieval or legal text classification. Let's look at some characteristics of our dataset. The questions are between 5 and 44 words long, with a median of 40 words. The articles are much longer, with a median length of 77 words, with 142 of them exceeding 1000 words, the lengthiest one being up to 5790 words. As previously mentioned, the questions cover a wide range of topics, with around 85% of them being either about family, housing, money or justice, while the remaining 15% concern either social security, foreigners or work. The articles are also very diverse, as they come from 32 different Belgian codes that cover a large number of legal topics. Here is the total number of articles collected from each of these Belgian codes. Out of the 22,633 articles, only 1,612 are referred to as relevant to at least one question in the data set. And around 80% of these cited articles come from either the civil code, judicial code, criminal investigation code or penal codes. Meanwhile, 18 out of 32 codes have less than 5 articles mentioned as relevant to at least one question, which can be explained by the fact that those codes focus less on individuals and their concerns. Overall, the median number of citations for these cited articles is 2, and less than 25% of them are cited more than 5 times. Using our datasets, we benchmark several retrieval approaches, including lexical and dense architecture. Given a query and an article, a lexical model assigns a score to the query-article pair by computing the sum over the query terms of the weights of each of these terms in that article. We experiment with the standard TF-IDF and BM25 ranking functions. The main problem with these approaches is that they can only retrieve articles that contain keywords present in the query. To overcome this limitation, we experiment with a neural-based architecture that can capture semantic relationships between queries and articles. We use a b-encoder model that maps queries and articles into dense vector representations, and calculates a relevant score between a query-article pair by the similarity of their embeddings. into dense vector representations, and calculate a relevant score between a query-article pair by the similarity of their embeddings. These embeddings typically result from a pooling operation on the output of a word embedding model. First, we study the effectiveness of Siamese b-encoders in a zero-shot evaluation setup, meaning that pre-trained word embedding models are applied out of the box without any additional fine-tuning. We experiment with context-independent text encoders, namely Word2Vec and FastText, and context-dependent embedding models, namely Robota and more specifically Camembert, which is a French Robota model. Additionally we train our own Camembert based model b-encoders on our datasets. Note that for training we experiment with the two flavors of the b-encoder architecture. Siamese which uses a unique word embedding model that maps the query and article together in a shared dense vector space, and toTower, which uses two independent word embedding models that encode the query and article separately into different embedding spaces. We experiment with mean, max, and CLS pooling, as well as dot product and cosine for computing similarities. Here are the results of our baseline on the set with the le the lexical methods above, the Siamese b-encoders evaluated in a zero-shot setup in the middle, and the fine-tuned b-encoders below. Overall, the fine-tuned b-encoders significantly outperform all the other baselines. The two-tower model improves over its Siamese variant on recall at 100, but performs similarly on the other metrics. Although BM25 underperformed the trained B-Encoder significantly, its performance indicates that it's still a strong baseline for domain-specific retrieval. Regarding the zero-shot evaluation of Siamese B-Encoder, we find that directly using the embeddings of a pre-trained Camembert model without optimizing for the information retrieval task gives poor results, which is consistent with previous findings. Furthermore, we observed that the Word2Vec-based biancoder significantly outperformed the FastText and BERT-based model, suggesting that maybe pre-trained word level embeddings are more appropriate for the task than character level or subword level. model, suggesting that maybe pre-trained word-level embeddings are more appropriate for the task than character-level or sub-word-level embeddings when used out of the box. Although promising, these results suggest ample opportunity for improvement compared to a skilled legal expert who can eventually retrieve all relevant articles to any question and thus get perfect scores. Let's conclude by discussing two limitations of all datasets. First, the corpus of articles is limited to those collected from the 32 considered Belgian codes, which does not cover the entire Belgian law, as articles from decrees, directives and ordinances are missing. During the data set construction, all references to these uncollected articles are ignored, which causes some question to end up with only a fraction of the initial number of relevant articles. This information loss implies that the answer contained in the remaining relevant articles might be incomplete, although it's still completely appropriate. Second, we should note that not all legal questions can be answered with statutes alone. For instance, the question, can I evict my tenants if they make too much noise, might not have a detailed answer within statutory law that quantifies a specific noise threshold at which eviction is allowed. Instead, the landlord should probably rely more on case law and find precedents seminar today. that quantifies a specific noise threshold at which eviction is allowed. Instead, the landlord should probably rely more on case law and find precedents similar to their current situation. For example, the tenant makes two parties a week until 2am. Hence, some questions are better suited than others to the statutory article retrieval task, and the domain of the less suitable ones remains to be determined. We hope that our work sparks interest in developing practical and reliable statutory article retrieval models that can help improve access to justice for all. You can check out our paper, dataset and code at the following links. Thank you."}
{"dataset_id": "acl_6060", "sample_id": 419, "src_lang": "en", "tgt_lang": "en", "output": "Hello! We are happy to present our work on VALS, a task-independent benchmark meant for testing vision and language models with specific linguistic phenomena. Why did we do the trouble in setting up this benchmark? Well, during the last years we have seen an explosion of transformer-based vision and language models, pre-trained on large amounts of image text pairs. Each one of these models pushes state-of-the-art on vision and language tasks, such as visual question answering, visual common sense reasoning, image retrieval, phrase grounding. So we got a message â€“ the accuracies on these task-specific benchmarks are increasing steadily. But do we know what the models have actually learned? What is it that a vision and language transformer understood when assigning a high score for this image and this sentence to match, and a low score for this one. Do vision and language models focus on the right thing, or do they focus on biases as shown by previous work? To shed more light on this aspect, we propose a more task-agnostic direction and introduce valves that test the sensitivity of vision and language models to specific linguistic phenomena that affect both the linguistic and the visual modalities. We target existence, plurality, counting, spatial relations, actions, entity coreference. But how do we test whether the vision and language models have captured these phenomena? By FOILing, a method previously applied for vision and language models, only for noun phrases by Ravi Shekhar and collaborators, on counting by us in previous work. Foiling basically means that we take the caption of an image and produce a foil by altering the caption such that it does not describe the image anymore. And we do these phrase alterations by focusing on six specific pieces, such as existence, plurality, counting, spatial relations, actions, and entity coreference, where each piece can consist of one or more instruments, in case we found more than one interesting way to create FOIL instances. For example, in the case of the actions piece, we have two instruments, one in which the action verb is changed with a different action, and one in which actants are swapped. Counting and coreference also are pieces that have more than one instrument. And we create these FOILs by making sure that they fail to describe the image, that they are grammatical and otherwise valid sentences. This is not easy to do, because a foiled caption may be less likely than the original caption. For example, though it's not impossible, it is statistically less likely for plants to cut a man than a man to cut plants, and large vision and language models could pick up on this. Therefore, to obtain valid foils, we must take action. First, we make use of strong language models to propose foils. Second, we use natural language inference, or short NLI, to filter out foils that could be still describing the image, since when constructing foils, we need to ensure that they fail to describe the image. To test this automatically, we apply natural language inference with the following rationale. We consider an image to be the premise, and its caption its entailed. In addition, we consider the caption to be the premise and the FOIL is its hypothesis. If an NLI model predicts the FOIL to contradict or to be neutral with respect to the caption, we take this as an indicator of a valid FOIL. If an NLI predicts the FOIL to be entailed by the caption, it cannot be a good FOIL, since by transitivity it will give a truthful description of the image and we filter these FOILs out. But this procedure is not perfect. It is just an indicator for valid FOIs, therefore as a third measure for generating valid FOIs, we employ human annotators to validate the data used in VALS. So, after filtering and human evaluation, we have as many test instances as described in this table. Note that VALS does not deliver any training data, but only test data, since it is a zero-shot testing benchmark only. It is designed to leverage the existing capabilities of vision and language models after pre-training. Fine-tuning would only enable models to exploit artifacts or statistical biases in the data. And we all know that these models like to cheat and take shortcuts. And as we said, we are interested in assessing what capabilities the vision and language models have after pre-training. We experiment with five vision and language models on VALS, namely with CLIP, LXMERT, Wil VILBERT, VILBERT 12 in 1, and VISUALBERT. Two of our most important evaluation metrics are the accuracy of the models in classifying image-sentence pairs into captions and foils. Perhaps more relevant for this video, we will showcase our more permissive metric, the pairwise accuracy, which measures whether the image sentence alignment score is greater for the correct image text pair than for its foiled pair. For more metrics and results on them, do check out our paper. The results with pairwise accuracy are shown here and they are consistent with the results we got from the other metrics. is that the best zero-shot performance is achieved by Wilbert 12-in-1, followed by Wilbert and they are consistent with the results we got from the other metrics, is that the best zero-shot performance is achieved by Wilbert 12 in 1, followed by Wilbert, Alex Mert, Clip, and finally Visual Bird. It's notable how instruments centered on the individual objects like existence and noun phrases are almost solved by Wilbert 12 in 1, highlighting that models that models are capable of identifying named objects and their presence in images. However, none of the remaining pieces can be reliably solved in our adversarial foiling settings. We see from the plurality and counting instruments that vision and language models have trouble distinguishing references to single versus multiple objects or counting counting them in an image. The relation piece shows that they have difficulties in correctly classifying a named spatial relation between objects in an image. They also have trouble distinguishing actions and identifying their participants, even if supported by plausibility biases, as we see in the actions piece. From the coreference piece, we find out that tracing multiple references to the same object in an image by using pronouns is also difficult for vision and language models. As a sanity check, and because it's an interesting experiment, we also benchmark two text-only models, GPT-1 and GPT-2, to assess whether VALS is solvable by these unimodal models by computing the perplexity of the correct and the foiled caption and predicting the entry with the lowest perplexity. If the perplexity is higher for the FOIL, we take this as an indication that the FOILed caption may suffer from plausibility bias or other linguistic biases. And it's interesting to see that in some cases the text-only GPT models have captured the plausibility of the world better than the vision and language models. So to sum up. VALS is a benchmark that uses the lens of linguistic constructs to help the community improve vision and language models by hard testing their visual grounding capabilities. Our experiments show that vision and language models identify named objects in their presence in images well, as shown by the existence piece, but struggle to ground their interdependence and relationships in visual scenes when forced to respect linguistic indicators. We would really like to encourage the community to use VALS for measuring progress towards language grounding with vision and language models. And even more, VALS could be used as an indirect assessment of datasets, as models could be evaluated before and after training or fine-tuning to see whether a dataset helps models improve on any of the aspects tested by VALS. If you're interested, do check out the VALS data on GitHub, and if you have any questions, do not hesitate to contact us."}
{"dataset_id": "acl_6060", "sample_id": 420, "src_lang": "en", "tgt_lang": "en", "output": "Hello, my name is Kamizawa from the University of Tokyo. I will be presenting a paper entitled RNSUN, a large-scale dataset for automatic release-note generation via commit log summarization. I will explain in this order. First, I will introduce the automatic release-note generation that we are working on in this research. Release note is a technical document that summarizes the changes distributed with each release of a software product. The image shows the release notes for version 2.6.4 of the Vue.js library. Release notes play an important role in open source development, but they are time consuming to prepare manually. Therefore, it would be very useful to be able to automatically generate high-quality release notes. I will refer to two previous researches on automatic release note generation. The first is a system called Arena, released in 2014. It takes a rule-based approach, for example, using the change extractor to extract core differences, library changes, and document changes from the differences between releases, and finally combining them. The most notable feature of this system is the issue extractor in the upper right corner, which must be linked to Jira, the issue tracker system, and can only be applied to projects that use Jira. In other words, it cannot be used for many projects on github the second Glyph, recently announced in 2020. It is available on the internet and can be stored via PIP. This system has a simple learning-based text classification model and outputs one of five levels, such as features or bug fixes, for each input commit message. The image is a sample usage that returns a corrective or bug fixes label. Glyph's training data is fairly small, about 5000, and revision in the experiments described below, the performance of the text classification model is not high. I present two related researches, but there are problems of limited applicability and scarce data resources. Our paper solves these two problems and automatically generates high-quality release nodes. For the limited applicability problem, we propose a high-quality classifier summarization method using only commit message as input. This proposed method can be used for all English repositories. For the second problem of scarce data resources, we built a R and sum data set consisting of about 82,000 pieces of data by collecting data from public GitHub repositories using RR and some data sets. Our Rnsum dataset consisting of about 82,000 pieces of data by collecting data from public GitHub repositories using the GitHub API. Next, I describe our dataset. Here is an example of data. The left side is the commit message and the right side is the release notes. The release notes are labeled as improvements of faces, etc. We have set is the commit message and the right side is the release nodes. The release nodes are labeled as improvements, bug fixes, etc. We have set up a task that takes the commit messages as input and outputs the labeled release nodes. This can be regarded as a summarization task. We have predefined four labels, features, improvements, bug fixes, deprecations, removals, and breaking changes. These were set based on previous research and other factors. The least nodes on the bottom right are extracted from the least nodes shown on the bottom left. At this time, it is necessary to detect the four labels that have been set up in advance. But the labels are not always consistent with each repository. For example, the improvements label includes improvements, enhancements, optimizations, and so on. We prepared a vocabulary list of our study labels for each of these notational variations, used it to detect the release note class, and correct the text of the list that follows as the release note sentence for the class need to identify the previous release version 2.5 to 18 and get it diff. This is a bit tedious and it is not enough to just get a list of releases and look at the before and after. We created a heuristic matching rule to get the previous and next versions. Day set analysis. In the end, 7,200 repositories and 82,000 pieces of data were collected. Also, the average number of release node tokens is 63, which is quite high for a summarization task. Also, the number of unique tokens is quite large, at 8,830,000. This is due to the large number of unique class and method names found in the repository. Next, I will explain the proposed method. to the large number of unique class and method names found in the repository. Next, I will explain the proposed method. The classwise extractive-then-abstractive summarization model consists of two neuralAS uses a classifier to classify each commit message into five release note classes. We choose implements, bug fixes, deprecations plus, and other. The commit messages classified as other are discarded. Then, CEAS applies the generator to the four label documents independently and generates release notes for each class. In this task, the direct correspondences between commit messages and release notes are not known. Therefore, to train the classifier, we assign pseudo-labels to each input commit message using the first 10 characters of each commit message. We model the class-wise abstractive summarization through our approach by two different methods. The first model, which we call cssingle, consists of a single set-to-set network and generates a single long piece node text, give, giving a concatenation of input commit messages. The output text networks, each of which corresponds to one of the least-known classes. Okay, let me explain the experiment. Five methods were compared, CAS, CASSingle, CASMatch, PlusSelling, and previous study, GRIF. Regarding aberration, in some cases, CSMatch, Blustering, and Previous Study Glyph. Regarding evaluation, in some cases, least-notes are output in multiple sentences. Since it is difficult to calculate the number of sentences as they are, they are combined with spaces and treated as one long sentence. The blue is penalized when the system outputs a short sentence. This penalty results in a lower blue value in the experiment results described next. Finally, we also calculate the specificity because rouge and blue cannot be calculated if the release nodes are empty. A high specificity means that the model correctly outputs an empty text in cases where the release nodes assume empty. Here are the results. Since the dataset contains email addresses, hash values, etc., we also evaluated the cleaned dataset, which excludes them. CES and CAS achieved rouge L scores more than 10 points higher than the baselines. In particular, on the clean test set, the score gap between the proposed method and the baselines jumped to more than 20 points. These results indicate that CAS and CAS are significantly effective. CAS got a better root-A score than CAS, suggesting that combining a classifier and a generator is effective in training the classifier using two-doubles. A high coverage of CAS can be achieved, probably, because the classifier can focus on selecting relevant commit messages for each class. CAS match tended to yield higher log L than CAS single, suggesting that it is also effective to independently develop differently abstracted summarization models for each release note class. Here are error analysis. CAS methods tend to output shorter sentences than human reference sentences. In the figure on the right, the reference sentence has three or four sentences, while CAS has only one. The reason for this model reluctance is that, in the training data, only 33% of the sentences are present in the features label and 40% in the improvements label. Furthermore, CES methods cannot generate accurate release notes without additional information. The top example on the right is an example of a very messy commitment CS methods cannot generate accurate release note without additional information. The top example on the right is an example of a very messy commit message, and the complete sentence cannot be generated without reference to the corresponding pro request or issue. The example below shows that the two commit messages in the input are related and should be combined into one sentence, but it fails to do so. Finally, a conclusion. We have built a new dataset for automatic list notation. We have also formed the task of entering commit messages and summarize them so that it is applicable to all projects written in English. Our experiment shows that the proposed method generates less noisy leads note at higher coverage than the baselines. Please check out our Descent only tab. Thank you."}
