{"dataset_id": "mcif_v0.2", "dataset_type": "unseen", "sample_id": 0, "src_audio": "/Users/ahrii/Documents/workspace/Research/MTM/SLT/MCIF_V0.2/LONG_AUDIOS/ICWfTnUMio.wav", "src_ref": "Hi! My name is Matthias Lindemann, and today I'm going to give you a brief introduction to our paper on \"Compositional Generalization without Trees using Multiset Tagging and Latent Permutations\". This is joint work with my advisors Alexander Koller and Ivan Titov. Compositional generalization can be understood as the ability of a learner to handle deeper recursion and unseen compositions of phrases that have been seen individually during training. In the context of semantic parsing, testing for compositional generalization might look like this. As usual, we have a training set of utterances. In this case, \"The girl slept.\" And \"Mary knew that the girl slept.\" These utterances are paired with logical forms that represent core aspects of their meaning. In contrast to standard machine learning evaluation, the test set does not come from the same distribution but contains structurally unseen logical forms. In this example, the model has seen shallow recursion during training and is tested on an example with deeper recursion. Naive seq2seq models struggle with this kind of out-of-distribution generalization and often produce outputs that are detached from the input. In particular, they often fail to reproduce the systematic correspondences between input and output, such as those that are color-coded in the example. A popular method to address this is to integrate trees into the models. The trees are intended to capture the compositional process that relates utterances with the logical forms. This works well, but trees are usually not given and need to be obtained somehow. This can be complicated and sometimes a computationally expensive process. Typically, this involves considerable formalism-specific pre-processing of the logical forms, for example, to handle variable symbols. Obtaining trees may also involve specialized grammar-induction procedures. In this paper, we don't use trees and introduce a neural seq2seq model that directly models the correspondences between fragments of the input and fragments of the output. For the first time, we show strong generalization to deeper recursion without relying on trees. Our approach predicts the output from the input in two steps. First, we tag each input token with an unordered multiset of tokens that will appear in the output. After the first step, we have all the right tokens, but they're not ordered. That's why in the second step we use another model to predict a permutation to put them into the right order. We introduce a new method to predict the permutation that does not put any hard constraints on the possible permutations. This makes our approach quite flexible and expressive. Conceptually, our permutation model works roughly like this. We go from left to right over the output and determine which multiset token to put in every position. For the first output position, we simply select one, as highlighted in red. Then we jump to the next multiset token, to determine the second token in the output. We determine the third token in the output in a similar way by jumping to another multiset token. We continue this process until every token from the first stage has been visited exactly once. To give you a teaser of the experimental results, here we compare our method with other treeless models on the COGS benchmark. Our model outperforms the others by a large margin on generalization to deeper recursion. Some other kinds of structural generalization remain very challenging, though. In our paper, we solve a couple of interesting technical challenges. First of all, the alignment between input and output is not given in the training data. As a consequence, for a given token we don't know which multiset it came from, which poses a challenge for training. In addition, sometimes there are multiple permutations that are consistent with the data, but the linguistically correct one is latent. We address this by inducing the alignment as part of the training. Our permutation method is very flexible, but it brings the challenge that finding the highest-scoring permutation is NP-hard. That's because this is related to the \"Traveling Salesman\" problem. We approximate this with a GPU-friendly continuous relaxation that also allows us to backpropagate through the solution and learn the linguistically more plausible permutations. If you want to learn more about our experiments and how we address these challenges, please have a look at our paper or come to our poster.", "tgt_ref": "Hallo!\nMein Name ist Matthias Lindemann und ich werde heute eine kurze Einführung in unsere Arbeit „Compositional Generalization without Trees using Multiset Tagging and Latent Permutations“ geben.\nDies ist eine gemeinsame Arbeit mit meinen Betreuern Alexander Koller und Ivan Titov.\nKompositionelle Generalisierung kann als die Fähigkeit eines Lerners verstanden werden, mit tieferen Rekursionen und unsichtbaren Kompositionen von Phrasen umzugehen, die während des Trainings einzeln gesehen wurden.\nIm Kontext des semantischen Parsens könnte ein Test der kompositionellen Generalisierung wie folgt aussehen.\nWie üblich haben wir eine Trainingsmenge von Äußerungen.\nIn diesem Fall: „Das Mädchen schlief“.\nUnd: „Maria wusste, dass das Mädchen schlief“.\nDiesen Äußerungen werden logische Formen zugeordnet, die Kernaspekte ihrer Bedeutung darstellen.\nIm Gegensatz zur Standardauswertung des maschinellen Lernens ist die Testmenge nicht gleichverteilt, sondern enthält strukturell unsichtbare logische Formen.\nIn diesem Beispiel hat das Modell während des Trainings eine flache Rekursion gesehen und wird an einem Beispiel mit einer tieferen Rekursion getestet.\nNaive seq2seq-Modelle haben mit dieser Art von Generalisierung außerhalb der Verteilung zu kämpfen und produzieren oft Ausgaben, die nicht mit den Eingaben übereinstimmen.\nInsbesondere sind sie oft nicht in der Lage, systematische Korrespondenzen zwischen Input und Output zu reproduzieren, wie diejenigen, die im Beispiel farblich markiert sind.\nEine beliebte Methode, um dieses Problem zu lösen, ist die Einbeziehung von Bäumen in die Modelle.\nDie Bäume sollen den Kompositionsprozess erfassen, der Aussagen mit logischen Formen in Beziehung setzt.\nDas funktioniert gut, aber Bäume sind in der Regel nicht gegeben und müssen irgendwie beschafft werden.\nDies kann ein komplizierter und manchmal rechenintensiver Prozess sein.\nIn der Regel ist eine umfangreiche formalismusspezifische Vorverarbeitung der logischen Formen erforderlich, zum Beispiel um mit variablen Symbolen umgehen zu können.\nDie Extraktion von Bäumen kann auch spezielle Grammatikinduktionsverfahren umfassen.\nIn dieser Arbeit verwenden wir keine Bäume und führen ein neuronales seq2seq-Modell ein, das direkt die Korrespondenzen zwischen Eingabe- und Ausgabefragmenten modelliert.\nZum ersten Mal zeigen wir eine starke Generalisierung auf tiefere Rekursionen, ohne Bäume zu verwenden.\nUnser Ansatz sagt den Output aus dem Input in zwei Schritten voraus.\nIm ersten Schritt markieren wir jedes Eingabe-Token mit einer ungeordneten Menge von Token, die in der Ausgabe vorkommen werden.\nNach dem ersten Schritt haben wir alle richtigen Token, aber sie sind nicht geordnet.\nDeshalb verwenden wir im zweiten Schritt ein anderes Modell, um eine Permutation vorherzusagen, die sie in die richtige Reihenfolge bringt.\nWir führen eine neue Methode zur Vorhersage der Permutation ein, die den möglichen Permutationen keine harten Beschränkungen auferlegt.\nDadurch wird unser Ansatz sehr flexibel und leistungsfähig.\nKonzeptionell funktioniert unser Permutationsmodell ungefähr so.\nWir gehen die Ausgabe von links nach rechts durch und entscheiden, welches Multiset-Token wir an die jeweilige Position setzen.\nFür die erste Ausgabeposition wählen wir einfach eine, die rot markiert ist.\nDann springen wir zum nächsten Multiset-Token, um das zweite Token in der Ausgabe zu bestimmen.\nDas dritte Token in der Ausgabe bestimmen wir auf die gleiche Weise, indem wir zu einem weiteren Multiset-Token springen.\nSo geht es weiter, bis jedes Token in der ersten Phase genau einmal besucht wurde.\nUm Ihnen einen Vorgeschmack auf die experimentellen Ergebnisse zu geben, vergleichen wir hier unsere Methode mit anderen baumlosen Modellen im COGS Benchmark.\nUnser Modell übertrifft die anderen bei der Generalisierung auf tiefere Rekursionen bei weitem.\nEinige andere Arten der strukturellen Generalisierung bleiben jedoch eine große Herausforderung.\nIn unserem Beitrag lösen wir einige interessante technische Herausforderungen.\nErstens ist das Alignment zwischen Input und Output in den Trainingsdaten nicht gegeben.\nDaher ist für ein bestimmtes Token nicht bekannt, aus welchem Multiset es stammt, was eine Herausforderung für das Training darstellt.\nAußerdem gibt es manchmal mehrere Permutationen, die den Daten entsprechen, aber die linguistisch korrekte ist nicht bekannt.\nWir lösen dieses Problem, indem wir das Alignment als Teil des Trainings durchführen.\nUnsere Permutationsmethode ist sehr flexibel, aber die Herausforderung besteht darin, dass das Auffinden der Permutation mit der höchsten Punktzahl NP-schwer ist.\nDies ist auf das Problem des „Traveling Salesman“ zurückzuführen.\nWir nähern uns diesem Problem mit einer GPU-freundlichen kontinuierlichen Relaxation, die es uns auch erlaubt, die Lösung rückwärts zu verarbeiten und die linguistisch plausibleren Permutationen zu lernen.\nWenn Sie mehr über unsere Experimente und unsere Herangehensweise an diese Herausforderungen erfahren möchten, werfen Sie einen Blick auf unsere Arbeit oder besuchen Sie unser Poster.", "src_lang": "eng", "ref_lang": "deu", "benchmark_metadata": {"subset": "long", "task": "IF", "audio_file": "ICWfTnUMio.wav", "sources": {"ref_xml": "MCIF0.2.IF.long.de.ref.xml", "src_text_source": "LONG_TEXTS"}}}
{"dataset_id": "mcif_v0.2", "dataset_type": "unseen", "sample_id": 1, "src_audio": "/Users/ahrii/Documents/workspace/Research/MTM/SLT/MCIF_V0.2/LONG_AUDIOS/JRrbTnEZbF.wav", "src_ref": "Hi, I'm Myra and today I'll be talking about our paper \"Marked Personas: Using Natural Language Prompts to Measure Stereotypes in Language Models.\" This work is done in collaboration with Esin Durmus and Dan Jurafsky. In recent years, many have documented the prevalence of social bias and stereotypes in large language models, or LLMs. However, these measures have various limitations. They usually rely on hand-constructed data sets that are very time-consuming to curate and they also usually only. measure very specific stereotypes, meaning that they don't generalize well to other demographics or contexts, or they simply capture very general broad associations, like negative associations with particular groups. Furthermore, most work in this space doesn't account for intersectionality, which is the notion that multi-faceted social identities can compound biases and be unique loci of harm. To overcome these limitations, we rely on the property that these newer instruction-tuned LLMs are very good at responding to instructions and prompts. So we can ask the model to generate a persona, which is a depiction of an imagined individual using a prompt like \"Imagine you are an Asian woman. Describe yourself.\". And we can immediately see that this is very generalizable to any demographic because we can just specify whatever identity marker that we want into this prompt. So here are some example generations from GPT-4. Immediately we see that, while the outputs aren't overtly negative or toxic in the traditional sense of these words, there are some interesting patterns. The Asian woman is depicted as unassuming; the Middle-Eastern woman is referred to using words like exotic and like, referring to a mesmerizing region. And both of the women of color personas make references to ancestry while the white man persona has nothing of the sort. To capture these patterns, our method has two parts. The first one is generating these personas. Our prompts to generate these personas were inspired by a study where they gave these prompts to human subjects, finding that by giving it to human subjects, they also were able to surface racial stereotypes. And also this enables direct comparison between our generated personas and the human written responses. The second part is marked words, which is a method to identify the words that distinguish marked groups from unmarked ones, which I'll elaborate on shortly. The benefit of this is that we get really specific stereotypes and patterns, without having to rely on any specific lexicon. So the Marked Words method draws upon the sociolinguistic concept of \"markedness\", which states that there is an unmarked default, and any group that differs from that default is linguistically marked. So for instance, the word \"warrior\" is usually associated with men. So when people are describing a warrior who is a woman, they'll usually actually specify \"woman warrior\" and mark the term with \"woman\". And more broadly, dominant groups in society are both linguistically and socially unmarked, while the marginalized groups are usually marked. So in our method, we first designate what the unmarked and marked groups are, and then we compare the personas using the Fightin’ Words method, which is basically using weighted log-odds ratios to distinguish the top words for each marked group. So for instance, for the personas of black women, we would do Fightin’ Words and compare the log-odds ratios against both white personas and man personas because those are the two corresponding unmarked groups. Now for some results. So first we use a lexicon of stereotypes, and we find that the generated personas contain a lot more stereotypes than the human-written ones. However, when we actually look at the distribution of the words and lexicon, we find very different things. So, while the generated personas have much higher rates of the lexicon words, the human-written ones have a much wider distribution of words, while the stereotype words that are in the generated personas are really just the words \"tall\" and \"athletic\". So, really just only the positive or at least non-negative ones. And in fact, this lexicon doesn't really capture many of the harmful patterns that we saw in the earlier slides well at all. So instead to do that, we'll turn to the results from our Marked Words method to show how these positive-seeming words facilitate stereotypes and essentializing narratives. In our analysis, we reveal how these seemingly positive portrayals reflect harmful patterns. First, from our groups, the top words include things like \"culture\", \"tradition\", \"proud\", and \"exotic\". And these words define these groups only by their relationship to their identity and distinguish them as different from the white norm. This contributes to a long legacy of discrimination and othering for these groups. Furthermore, there's a lot of common tropes that are reflected in these words, especially for women of color. So for example, the words describing Latina women include things like \"vibrant\" and \"curvaceous\" which connect to a trope of tropicalism. For Asian women, the words are things like \"petite\" and \"delicate\" and \"silky\" which connects to a long history of Asian women being hyper-sexualized, seen as very docile and submissive, and so on. And finally, for black women, we see that some of the top words are things like \"strong\" and \"resilient\". This connects to an archetype that people have called the \"Strong Black Women\" archetype. And while it sounds positive at first glance, there's been work showing that this kind of archetype actually is very harmful because it puts a lot of pressure on these demographics to be resilient and strong against societal obstacles. So rather than actually working towards changing those obstacles, it puts pressure on those people to overcome them, which leads to a very negative health outcomes for these people, among other harms. More broadly, we find that the words for each marked group pretty much just reflect very essentializing narratives. So based on these patterns, we conclude with three recommendations for model owners. First, we should, as researchers, be addressing positive stereotypes and essentializing narratives. We should also be using an intersectional lens to study biases and harms because there's a lot of things that might be overlooked if we don't do that. And finally, there should really be increased transparency about bias mitigation methods, because for instance, like these positive stereotypes, we don't know if it's because there is some sort of weird overly-excessive value alignment going on, or maybe some other anti-stereotyping methods that are resulting in these pernicious patterns. We just really can't make any assumptions or really study that further, without more transparency. Thank you so much for listening. Have a good time at ACL.", "tgt_ref": "Hallo, mein Name ist Myra und ich werde heute über unsere Arbeit „Marked Personas: Using Natural Language Prompts to Measure Stereotypes in Language Models“ sprechen.\nEs handelt sich dabei eine Zusammenarbeit mit Esin Durmus und Dan Jurafsky.\nIn den letzten Jahren haben viele die Prävalenz von sozialen Vorurteilen und Stereotypen in großen Sprachmodellen (LLMs) dokumentiert.\nDiese Messungen weisen jedoch einige Einschränkungen auf.\nSie basieren in der Regel auf manuell erstellten Datensätzen, deren Zusammenstellung sehr zeitaufwändig ist, und sie tendieren dazu, nur sehr spezifische Stereotypen zu messen, was bedeutet, dass sie nicht gut auf andere demografische Gruppen oder Kontexte verallgemeinert werden können, oder sie erfassen einfach sehr allgemeine Assoziationen, z. B. negative Assoziationen mit bestimmten Gruppen.\nDarüber hinaus berücksichtigen die meisten Arbeiten in diesem Bereich nicht die Intersektionalität, das heißt die Idee, dass mehrere soziale Identitäten Vorurteile verstärken und einzigartige Orte der Benachteiligung sein können.\nUm diese Einschränkungen zu überwinden, machen wir uns die Tatsache zunutze, dass diese neueren LLMs sehr gut auf Anweisungen und Prompts reagieren können.\nBeispielsweise können wir das Modell auffordern, eine Persona zu erstellen, das heißt die Darstellung einer imaginären Person, indem wir einen Prompt wie „Stellen Sie sich vor, Sie sind eine asiatische Frau.\nBeschreiben Sie sich selbst“ eingeben.\nUnd wir können sofort sehen, dass dies für jede Bevölkerungsgruppe verallgemeinerbar ist, da wir jedes Identitätsmerkmal in diesen Prompt einfügen können.\nHier sind also einige Beispielgenerationen von GPT-4.\nWir können sofort erkennen, dass die Ergebnisse nicht eindeutig negativ oder toxisch im traditionellen Sinne dieser Wörter sind, aber es gibt einige interessante Muster.\nDie asiatische Frau wird als bescheiden dargestellt; die Frau aus dem Nahen Osten wird mit Wörtern wie exotisch beschrieben und es wird bei ihr auf eine faszinierende Region hingewiesen.\nUnd die beiden Personas der Women-of-Colour verweisen auf ihre Abstammung, während die des weißen Mannes dies nicht tut.\nUnsere Methode zur Erfassung dieser Muster besteht aus zwei Teilen.\nDer erste Teil besteht in der Erstellung der Personas.\nUnsere Prompts für die Erstellung dieser Personas wurden von einer Studie inspiriert, in der diese Prompts menschlichen Teilnehmern vorgelegt wurden und in der festgestellt wurde, dass dadurch auch rassistische Stereotypen aufgedeckt werden konnten.\nDies ermöglicht auch einen direkten Vergleich zwischen den von uns generierten Personas und den schriftlichen Antworten von Menschen.\nDer zweite Teil ist das Tagging. Dabei handelt es sich um eine Methode zur Identifizierung von Wörtern, die getaggte Gruppen von nicht getaggten Gruppen unterscheiden.\nDer Vorteil dieser Methode besteht darin, dass wir wirklich spezifische Stereotypen und Muster erhalten, ohne auf ein spezielles Lexikon zurückgreifen zu müssen.\nDie Marked-Words-Methode basiert also auf dem soziolinguistischen Konzept der „Markierung“, das besagt, dass es eine unmarkierte Norm gibt und dass jede Gruppe, die von dieser Norm abweicht, sprachlich markiert wird.\nZum Beispiel wird das Wort „Krieger“ normalerweise mit Männern assoziiert.\nWenn man also einen Krieger beschreibt, der eine Frau ist, sagt man normalerweise „Kriegerin“ und markiert das Wort mit „in“.\nIm Allgemeinen werden dominante Gruppen in der Gesellschaft weder sprachlich noch sozial markiert, während marginalisierte Gruppen in der Regel markiert werden.\nBei unserer Methode bestimmen wir zunächst die unmarkierten und markierten Gruppen und vergleichen dann die Personas mit der „Fightin’ Words“-Methode, die im Wesentlichen gewichtete log-odds-Verhältnisse verwendet, um die Top-Wörter für jede markierte Gruppe zu unterscheiden.\nFür die schwarzen weiblichen Personas würden wir beispielsweise die „Fightin’ Words“-Methode anwenden und die log-odds-Verhältnisse sowohl mit den weißen als auch mit den männlichen Personas vergleichen, da dies die beiden entsprechenden nicht markierten Gruppen sind.\nNun zu einigen Ergebnissen.\nZuerst verwenden wir ein Lexikon von Stereotypen und stellen fest, dass die generierten Personas viel mehr Stereotypen enthalten als die von Menschen geschriebenen.\nWenn wir uns aber anschauen, wie sich die Wörter und der Wortschatz verteilen, dann stellen wir fest, dass es ganz anders aussieht.\nWährend also die generierten Personas einen viel höheren Anteil an Lexikonwörtern aufweisen, weisen die von Menschen geschriebenen Personas eine viel breitere Verteilung von Wörtern auf, während die stereotypen Wörter in den generierten Personas eigentlich nur die Wörter „groß“ und „sportlich“ sind.\nAlso wirklich nur die positiven oder zumindest nicht negativen Wörter.\nUnd in der Tat deckt dieses Lexikon nicht wirklich viele der schädlichen Muster ab, die wir auf den vorherigen Folien gesehen haben.\nStattdessen wenden wir uns den Ergebnissen unserer Marked-Words-Methode zu, um zu zeigen, wie diese positiv erscheinenden Wörter Stereotypen und essentialisierende Erzählungen fördern.\nIn unserer Analyse zeigen wir, wie diese scheinbar positiven Darstellungen schädliche Muster widerspiegeln.\nZunächst gehören zu den wichtigsten Wörtern unserer Gruppen Begriffe wie „Kultur“, „Tradition“, „stolz“ und „exotisch“.\nUnd diese Wörter definieren diese Gruppen nur in Bezug auf ihre Identität und grenzen sie von der weißen Norm ab.\nDies trägt zu einem langen Erbe der Diskriminierung und Fremdbestimmung dieser Gruppen bei.\nDarüber hinaus spiegeln sich in diesen Begriffen viele gängige Tropen wider, insbesondere für Women-of-Colour.\nSo werden beispielsweise Latina-Frauen unter anderem mit Wörtern wie „lebhaft“ und „kurvenreich“ beschrieben, die mit der Trope des Tropismus verbunden sind.\nBei asiatischen Frauen sind es Wörter wie „zierlich“ und „zart“ und „seidig“, was damit zusammenhängt, dass asiatische Frauen lange Zeit übersexualisiert und als sehr fügsam und unterwürfig angesehen wurden.\nBei den schwarzen Frauen schließlich finden sich unter den Top-Wörtern Begriffe wie „stark“ und „widerstandsfähig“.\nDies ist eine Produktkopplung mit einem Archetyp, der als „starke schwarze Frau“ bezeichnet wird.\nUnd obwohl das auf den ersten Blick positiv klingt, gibt es Arbeiten, die zeigen, dass diese Art von Archetyp eigentlich sehr schädlich ist, weil er diese Bevölkerungsgruppen unter Druck setzt, widerstandsfähig und stark gegenüber sozialen Hindernissen zu sein.\nAnstatt also wirklich daran zu arbeiten, diese Hindernisse zu verändern, setzt er diese Menschen unter Druck, sie zu überwinden, was neben anderen schädlichen Auswirkungen auch sehr negative gesundheitliche Folgen für sie hat.\nGenerell stellen wir fest, dass die Wörter für jede markierte Gruppe fast ausschließlich stark essentialisierende Narrative widerspiegeln.\nAuf der Grundlage dieser Muster schließen wir mit drei Empfehlungen für Modellierer.\nErstens sollten wir uns als Forscher auf positive Stereotype und essentialisierende Narrative konzentrieren.\nWir sollten auch eine intersektionale Linse verwenden, um Voreingenommenheit und Benachteiligung zu betrachten, denn es gibt viele Dinge, die wir sonst übersehen könnten.\nUnd schließlich sollten wir mehr Transparenz in die Methoden bringen, mit denen wir Vorurteile abbauen, denn bei diesen positiven Stereotypen wissen wir nicht, ob es sich um ein seltsames, übertriebenes Wertalignment handelt oder um andere Anti-Stereotypisierungs-Methoden, die zu diesen schädlichen Mustern führen.\nOhne mehr Transparenz können wir keine Vermutungen anstellen oder die Angelegenheit weiter untersuchen.\nVielen Dank fürs Zuhören.\nViel Spaß bei der ACL.", "src_lang": "eng", "ref_lang": "deu", "benchmark_metadata": {"subset": "long", "task": "IF", "audio_file": "JRrbTnEZbF.wav", "sources": {"ref_xml": "MCIF0.2.IF.long.de.ref.xml", "src_text_source": "LONG_TEXTS"}}}
{"dataset_id": "mcif_v0.2", "dataset_type": "unseen", "sample_id": 2, "src_audio": "/Users/ahrii/Documents/workspace/Research/MTM/SLT/MCIF_V0.2/LONG_AUDIOS/JhbtCwcsWY.wav", "src_ref": "Hello, I'm James Finch. And I'm Sarah Finch. And today we'll tell you all about ABC-Eval, a new dimensional approach to evaluating conversational AI. This work was done by the Emory NLP Lab led by Professor Jinho Choi at Emory University and in collaboration with Amazon Alexa AI. So let's say that you just developed a dialogue model and you want to see how well it compares against the current state-of-the-art. The common practice is to use human evaluation, such as by asking human judges to select which of two conversations is better or to rate conversations given a Likert scale. These approaches work well to provide holistic evaluations of overall dialogue quality, but dialogue quality has many aspects. Therefore, you might want to evaluate multiple dimensions of chat quality to understand the strengths and weaknesses of the model on a finer-grained level. One approach is to simply ask human judges to evaluate several dimensions of dialogue quality, such as the relevance of model responses using existing comparative or Likert scale methods. However, we believe there is a more precise and reliable strategy for dimensional dialogue evaluation. Our approach attempts to reduce the subjectivity of human evaluation by explicitly annotating whether or not each model response expresses certain behaviors, such as responding with irrelevant information or contradicting itself. We call this approach annotating behaviors in chat or ABC-Eval in short. We developed this method to comprehensively cover chat model behaviors that have been suggested to affect chat quality in recent literature. ABC-Eval is capable of measuring the rates at which chat models will commit various thematic errors. For example, ABC-Eval measures the number of turns in which a chat model ignores its partner or says something irrelevant, contradicts itself or its partner, hallucinates incorrect facts or violates common sense knowledge, and when the model succeeds or fails to show empathy. To determine what kind of evaluation is most effective, we selected four state-of-the-art chat models and evaluated them on 100 human-bot conversations per model using ABC-Eval. For comparison, we also evaluated these conversations using three existing methods: Likert ratings on the turn-level, Likert ratings on the dialogue-level, and dialogue-level pairwise comparisons. For each of the existing methods, we collected evaluations on eight of the most commonly measured aspects of dialogue, since this is the standard practice for evaluating chat models along multiple dimensions. From our analysis of these evaluation results, we found that ABC-Eval behavior labels are overall more reliable than labels collected by existing methods, as measured by inter-annotator agreement on 100 doubly-labeled conversations. In addition, ABC-Eval labels are more predictive of the overall conversation quality compared to metrics produced by existing methods, as shown by this simple linear regression analysis. For example, you can see how measuring the proportion of turns with self and partner contradictions explains 5% and 10% of conversation quality, respectively, while the average Likert consistency scores explain only 4% or less. Finally, we checked whether each evaluation metric captures a unique aspect of chat quality using a stepwise linear regression. You can see how the combination of all ABC-Eval metrics explains over 25% of conversation quality, and as you remove the metrics one at a time, most of them result in losing a decent amount of information about the quality. On the other hand, the combination of all turn-level Likert metrics explains far less of the quality, and fewer of these metrics carry unique information. These reliable, informative, and distinct ABC-Eval metrics enable us to evaluate conversational AI with a higher resolution than previous methods are able to achieve. You can see that in the results of our experiment that several challenges still remain and have been precisely quantified. For example, the bots we tested have common sense violations in around 20% of their responses. They produce irrelevant information in around 15% of the responses, and they contradict themselves or their partner around 10% of the time. With the rapid pace of improvement in the field, many of these error rates could see a decrease in new models released since our evaluation was conducted. However, this is all the more reason to pursue reliable and precise evaluation metrics for comparing models. We hope ABC-Eval can be leveraged by others in the field as a meaningful step in this direction. And we look forward to seeing how conversational AI will advance in the coming months and years. Thank you for watching.", "tgt_ref": "Hallo, ich bin James Finch.\nUnd ich bin Sarah Finch.\nHeute stellen wir Ihnen ABC-Eval vor, einen neuen dimensionalen Ansatz zur Evaluierung konversationaler KI.\nDiese Arbeit wurde vom Emory NLP Lab unter der Leitung von Professor Jinho Choi an der Emory University in Zusammenarbeit mit Amazon Alexa AI durchgeführt.\nAngenommen, Sie haben gerade ein Dialogmodell entwickelt und möchten wissen, wie gut es im Vergleich zum aktuellen Stand der Technik abschneidet.\nEin gängiger Ansatz ist die Verwendung menschlicher Bewertungen, zum Beispiel indem menschliche Gutachter entscheiden, welcher von zwei Dialogen besser ist, oder indem Dialoge auf einer Likert-Skala bewertet werden.\nDiese Ansätze sind gut geeignet, um eine ganzheitliche Bewertung der Gesamtqualität des Dialogs vorzunehmen, aber die Dialogqualität hat viele Aspekte.\nDaher kann es sinnvoll sein, mehrere Dimensionen der Gesprächsqualität zu bewerten, um die Stärken und Schwächen des Modells auf einer feingliedrigeren Ebene zu verstehen.\nEin Ansatz besteht darin, einfach menschliche Gutachter zu bitten, mehrere Dimensionen der Dialogqualität zu bewerten, wie zum Beispiel die Relevanz der Modellantworten unter Verwendung bestehender vergleichender oder Likert-Skala-Methoden.\nWir glauben jedoch, dass es eine genauere und zuverlässigere Strategie für die dimensionale Bewertung von Dialogen gibt.\nIn unserem Ansatz versuchen wir, die Subjektivität der menschlichen Evaluierung zu reduzieren, indem wir explizit annotieren, ob jede Modellantwort bestimmte Verhaltensweisen ausdrückt, wie zum Beispiel mit irrelevanter Information antwortet oder sich selbst widerspricht.\nWir nennen diesen Ansatz Annotation von Verhaltensweisen im Chat oder kurz ABC-Eval.\nWir haben diese Methode entwickelt, um die Verhaltensweisen von Chatmodellen umfassend zu erfassen, von denen in der neueren Literatur angenommen wird, dass sie die Chatqualität beeinflussen.\nABC-Eval ist in der Lage, die Rate zu messen, mit der Chatmodelle verschiedene thematische Fehler begehen.\nABC-Eval misst beispielsweise die Anzahl der Runden, in denen ein Chatmodell seinen Partner ignoriert oder etwas Irrelevantes sagt, sich selbst oder seinem Partner widerspricht, falsche Tatsachen halluziniert oder gegen den gesunden Menschenverstand verstößt, und in denen es dem Modell gelingt oder misslingt, Empathie zu zeigen.\nUm herauszufinden, welche Art der Evaluierung am effektivsten ist, haben wir vier hochmoderne Chat-Modelle ausgewählt und sie mit ABC-Eval anhand von 100 Mensch-Bot-Gesprächen pro Modell bewertet.\nZum Vergleich haben wir diese Gespräche auch mit drei bestehenden Methoden evaluiert: Turn-Level Likert Ratings, Dialogue-Level Likert Ratings und Dialogue-Level Pairwise Comparisons.\nFür jede der bestehenden Methoden haben wir Bewertungen für acht der am häufigsten gemessenen Aspekte des Dialogs erhoben, da dies eine gängige Praxis bei der Bewertung von Chat-Modellen entlang mehrerer Dimensionen ist.\nUnsere Analyse dieser Evaluationsergebnisse hat gezeigt, dass die ABC-Eval-Verhaltensattribute insgesamt zuverlässiger sind als die Attribute, die von bestehenden Methoden erzeugt werden. Dies wurde anhand der Übereinstimmung zwischen den Annotatoren bei 100 doppelt markierten Interviews gemessen.\nDarüber hinaus sind die ABC-Eval-Kennzeichnungen aussagekräftiger für die allgemeine Gesprächsqualität als die Metriken bestehender Methoden, wie diese einfache lineare Regressionsanalyse zeigt.\nBeispielsweise erklärt die Messung des Anteils der Turns mit Selbstwidersprüchen und Partnerwidersprüchen 5 % bzw. 10 % der Gesprächsqualität, während die durchschnittlichen Likert-Konsistenzwerte nur 4 % oder weniger erklären.\nSchließlich haben wir eine schrittweise lineare Regression durchgeführt, um zu sehen, ob jeder Indikator einen bestimmten Aspekt der Gesprächsqualität erfasst.\nEs zeigt sich, dass die Kombination aller ABC-Eval-Kennzahlen mehr als 25 % der Gesprächsqualität erklärt. Wenn man die Kennzahlen einzeln herausnimmt, geht bei den meisten eine beträchtliche Menge an Information über die Qualität verloren.\nAndererseits erklärt die Kombination aller Likert-Kennzahlen auf Turn-Ebene weit weniger von der Qualität, und weniger dieser Kennzahlen enthalten eindeutige Informationen.\nDiese zuverlässigen, informativen und eindeutigen ABC-Eval-Metriken ermöglichen es uns, KI im Gespräch mit einer höheren Auflösung zu bewerten, als es mit früheren Methoden möglich war.\nSie können in den Ergebnissen unseres Experiments sehen, dass noch einige Herausforderungen bestehen bleiben und genau quantifiziert wurden.\nDie von uns getesteten Bots verstoßen beispielsweise in etwa 20 % ihrer Antworten gegen den gesunden Menschenverstand.\nSie produzieren in etwa 15 % der Antworten irrelevante Informationen und widersprechen sich selbst oder ihrem Partner in etwa 10 % der Fälle.\nAngesichts der raschen Fortschritte auf diesem Gebiet könnten viele dieser Fehlerraten bei neuen Modellen, die seit unserer Bewertung veröffentlicht wurden, sogar noch niedriger sein.\nDies ist jedoch ein Grund mehr, zuverlässige und genaue Bewertungsmetriken für den Vergleich von Modellen zu verfolgen.\nWir hoffen, dass ABC-Eval von anderen in diesem Bereich als nützlicher Schritt in diese Richtung aufgegriffen werden kann.\nUnd wir sind gespannt, wie sich die konversationale KI in den nächsten Monaten und Jahren weiterentwickeln wird.\nVielen Dank fürs Zuschauen.", "src_lang": "eng", "ref_lang": "deu", "benchmark_metadata": {"subset": "long", "task": "IF", "audio_file": "JhbtCwcsWY.wav", "sources": {"ref_xml": "MCIF0.2.IF.long.de.ref.xml", "src_text_source": "LONG_TEXTS"}}}
{"dataset_id": "mcif_v0.2", "dataset_type": "unseen", "sample_id": 3, "src_audio": "/Users/ahrii/Documents/workspace/Research/MTM/SLT/MCIF_V0.2/LONG_AUDIOS/MjDvRpkOFq.wav", "src_ref": "Hello, my name is Vasudha and I'm a Computer Science PhD candidate at Stony Brook University. I would like to present our work accepted into ACL 2023 as a long paper, \"Transfer Learning for Dissonance Detection: Addressing the Rare-Class Challenge.\" We begin by defining cognitive dissonance and why it is an important problem to study in language. Simply put, cognitive dissonance is two beliefs or actions that are inconsistent, such as this example where a person states, \"I know that cigarettes could kill me\", and then goes on to say \"I grabbed a couple of smokes after the meeting\". This belief and action are inconsistent, and they are in dissonance. Further mentioning that \"I don't think I could keep my job without them\" justifies the second occurrence. And they have a consonance relationship. While dissonance is a very common phenomenon we experienced in daily decision making, they are really rare to find expressed in language among other kinds of discourse relations. So why does this matter? Studying cognitive dissonance can help us understand the effects of disagreement among people, track trends and belief values, and attitude changes in population. High cognitive dissonance is also related to anxiety disorders and can help understand people's mental health better. Studying dissonance expressed in language can also be beneficial in understanding extremism and polarization of vulnerable groups. Finally, cognitive dissonance is important to understand personal cognitive styles of individuals and helps us understand decision making processes better. To the goal of creating a cognitive dissonance resource, we conducted a large scale annotation of dissonance relations. We used dissonance-first approach, as seen in the flow chart here. Tweets were passed using the PDTB parser, and pairs of discourse units were annotated according to the guidelines that are described in our paper. As can be seen here, dissonance was only found in 3.5% of the annotated pairs. On collecting around 1,000 examples of discourse unit pairs, we ran training for an initial classifier trained only on 43 examples of dissonance. To no surprise, the classifier performed not much better than chance. Given the low occurrence of dissonance and absence of any prior such data set, we are facing the problem of absolute rarity. To alleviate this, we experiment over combinations of transfer learning and active learning to annotate such that more dissonant samples can be collected over lesser annotation runs, lowering the overall annotation costs while improving dissonance detection. Since the initial model was not able to capture the dissonance class at all, we start the active learning process by transferring weights from closely related tasks. We transfer from two different tasks: topic independent dissonance stance classification, a task that determines if two debate statements from different people are in agreement or in disagreement, irrespective of topic, called debate here, and on binary classification of expansion and comparison classes of PDTB since these two are closely related to the conception of consonance and dissonance and we call them CE here. We find that on transferring the zero-shot performance on the annotated data set is already much better than chance with the best, with AUC .62. Further, on iteratively fine-tuning on both tasks, we find that fine-tuning of CE tasks followed by further fine-tuning on debate yields a much better zero-shot performance. Thus, this is the model that we use to cold start the active learning. Next, we determine the best method to update a model with new data from each round of active learning and annotations. \"Cumulative\" accumulates all the data collected from active annotation so far, whereas \"Iterative\" updates the model by training on the latest set of data collected. Over the different strategies, we found that Cumulative performed equal or better than Iterative across the board. Next, to improve the number of dissonance examples, we use a Probability-of-Rare-Class strategy — PRC — to select mostly the examples that are highly likely to be descended by the current model at any round of rare. We compare this to the other state-of-the-art AL strategies that are commonly used in the community. We find that the proposed PRC strategy works better than other state-of-the-art strategies, although the difference is small. Note that the performance is significantly lower for random. On further rounds of AL with two best strategies, we improve dissonance classification AUC to 0.75, which is the best performance that we have on the task so far. We also check the feasibility of each strategy for annotation quality and costs to annotators. We find that PRC has the highest percentage of dissonance and works best for rare class. However, the annotators also find the examples difficult. In summary, we find that PRC is a simple AL strategy for rare class acquisition and cold starting AL with appropriately designed transfer learning task and help significantly. We also find that iterative update is useful for transfer learning from a different domain, whereas in domain active annotations benefit from cumulative update. These are the links to our core data set and our paper. Feel free to get in touch with us if you have any questions. Thank you.", "tgt_ref": "Hallo, mein Name ist Vasudha und ich bin Doktorand in Informatik an der Stony Brook Universität.\nIch möchte Ihnen unsere Arbeit vorstellen, die als Long Paper bei der ACL 2023 angenommen wurde: „Transfer Learning for Dissonance Detection: Addressing the Rare-Class Challenge“.\nWir beginnen mit einer Definition von kognitiver Dissonanz und erklären, warum sie ein wichtiges Problem bei der Untersuchung von Sprache darstellt.\nEinfach ausgedrückt handelt es sich bei kognitiver Dissonanz um zwei Überzeugungen oder Handlungen, die nicht miteinander vereinbar sind, wie in diesem Beispiel, in dem eine Person sagt: „Ich weiß, dass Zigaretten mich umbringen können“ und dann sagt: „Ich habe nach dem Meeting ein paar Zigaretten geraucht“.\nDiese Überzeugung und diese Handlung sind inkonsistent und stehen im Widerspruch zueinander.\nDie weitere Aussage „Ich glaube nicht, dass ich ohne sie meinen Job behalten könnte“ rechtfertigt das zweite Ereignis.\nUnd sie stehen in einer konsonanten Beziehung zueinander.\nWährend Dissonanz ein sehr häufiges Phänomen ist, das wir in der alltäglichen Entscheidungsfindung erleben, ist es sehr selten, dass sie in der Sprache unter anderen Arten von Diskursbeziehungen zum Ausdruck kommt.\nWarum ist das nun wichtig?\nDie Erforschung der kognitiven Dissonanz kann uns helfen, die Auswirkungen von Meinungsverschiedenheiten zwischen Menschen zu verstehen, Trends und Überzeugungen zu verfolgen und Veränderungen in den Einstellungen von Bevölkerungsgruppen zu beobachten.\nEine hohe kognitive Dissonanz ist auch mit Angst verbunden und kann uns helfen, die psychische Gesundheit der Menschen zu verstehen.\nDie Untersuchung der in der Sprache ausgedrückten Dissonanz kann auch nützlich sein, um Extremismus und Polarisierung unter gefährdeten Gruppen zu verstehen.\nSchließlich ist kognitive Dissonanz wichtig für das Verständnis des persönlichen kognitiven Stils von Menschen und hilft uns, Entscheidungsprozesse besser zu verstehen.\nUm eine Ressource für kognitive Dissonanz zu schaffen, haben wir eine groß angelegte Annotation von Dissonanzbeziehungen durchgeführt.\nDabei haben wir einen Ansatz gewählt, der von der Dissonanz ausgeht, wie im folgenden Flussdiagramm dargestellt.\nDie Tweets wurden durch den PDTB-Parser geleitet und die Diskurseinheitenpaare wurden gemäß den in unserer Arbeit beschriebenen Richtlinien annotiert.\nWie Sie hier sehen können, wurde Dissonanz in nur 3,5 % der annotierten Paare gefunden.\nNachdem wir ca. 1.000 Beispiele von Diskurseinheitenpaaren gesammelt hatten, trainierten wir einen ersten Klassifikator, der mit nur 43 Dissonanzbeispielen trainiert wurde.\nEs überrascht nicht, dass der Klassifikator nicht viel besser war als der Zufall.\nAngesichts der Seltenheit von Dissonanzen und des Fehlens eines früheren Datensatzes dieser Art stehen wir vor dem Problem der absoluten Seltenheit.\nUm dieses Problem zu entschärfen, experimentieren wir mit Kombinationen von Transferlernen und aktivem Lernen, um die Annotation so zu gestalten, dass mehr dissonante Proben mit weniger Annotationsläufen erfasst werden können, was die Gesamtkosten der Annotation reduziert und gleichzeitig die Erkennung von Dissonanzen verbessert.\nDa das ursprüngliche Modell nicht in der Lage war, die Dissonanzklasse zu erfassen, beginnen wir den aktiven Lernprozess, indem wir Gewichte von eng verwandten Aufgaben übertragen.\nWir gehen von zwei verschiedenen Aufgaben aus: der themenunabhängigen Klassifikation von Dissonanzhaltungen, einer Aufgabe, die unabhängig vom Thema bestimmt, ob zwei Debattenaussagen von verschiedenen Personen übereinstimmen oder nicht, hier Debatte genannt, und der binären Klassifikation von PDTB-Expansions- und Vergleichsklassen, da diese beiden eng mit dem Konzept von Konsonanz und Dissonanz verwandt sind, hier CE genannt.\nWir stellen fest, dass die Zero-Shot-Performance auf dem annotierten Datensatz mit einer AUC von 0,62 bereits deutlich besser als der Zufall ist.\nDarüber hinaus stellen wir bei der iterativen Feinabstimmung der beiden Aufgaben fest, dass die Feinabstimmung der CE-Aufgaben, gefolgt von einer weiteren Feinabstimmung der Debatte, zu einer deutlich besseren Zero-Shot-Leistung führt.\nDaher verwenden wir dieses Modell für den Kaltstart des aktiven Lernens.\nAls nächstes bestimmen wir die beste Methode, um das Modell mit neuen Daten aus jeder Runde des aktiven Lernens und der Annotation zu aktualisieren.\n„Kumulativ“ sammelt alle bisher gesammelten Daten aus der aktiven Annotation, während „Iterativ“ das Modell durch Training mit dem zuletzt gesammelten Datensatz aktualisiert.\nFür die verschiedenen Strategien haben wir festgestellt, dass „Kumulativ“ immer gleich gut oder besser als „Iterativ“ funktioniert.\nUm die Anzahl der Dissonanzbeispiele zu erhöhen, verwenden wir eine Probability-of-Rare-Class-Strategie (PRC), um in jeder Rare-Runde die meisten Beispiele auszuwählen, die mit hoher Wahrscheinlichkeit aus dem aktuellen Modell stammen.\nWir vergleichen diese Strategie mit anderen modernen AL-Strategien, die in der Community häufig verwendet werden.\nWir stellen fest, dass die vorgeschlagene PRC-Strategie besser abschneidet als die anderen modernen Strategien, obwohl der Unterschied gering ist.\nEs ist zu beachten, dass die Leistung mit Random deutlich schlechter ist.\nIn weiteren AL-Runden mit den beiden besten Strategien verbessern wir die AUC der Dissonanzklassifikation auf 0,75, was die beste Leistung ist, die wir bisher bei dieser Aufgabe erreicht haben.\nWir untersuchen auch die Durchführbarkeit jeder Strategie in Bezug auf die Qualität der Kommentare und die Kosten für die Annotatoren.\nWir stellen fest, dass PRC den höchsten Prozentsatz an Dissonanzen aufweist und am besten bei der seltenen Klasse funktioniert.\nAllerdings finden die Annotatoren die Beispiele auch schwierig.\nZusammenfassend stellen wir fest, dass PRC eine einfache AL-Strategie ist, um seltene Klassen und Kaltstart-AL mit einer gut gestalteten Transfer-Lernaufgabe zu erfassen, und dass sie sehr hilfreich ist.\nWir stellen auch fest, dass die iterative Aktualisierung für das Transferlernen aus einer anderen Domain nützlich ist, während aktive Annotationen in der Domain von der kumulativen Aktualisierung profitieren.\nDies sind die Links zu unserem Kerndatensatz und unserer Arbeit.\nWenn Sie Fragen haben, zögern Sie bitte nicht, uns zu kontaktieren.\nVielen Dank.", "src_lang": "eng", "ref_lang": "deu", "benchmark_metadata": {"subset": "long", "task": "IF", "audio_file": "MjDvRpkOFq.wav", "sources": {"ref_xml": "MCIF0.2.IF.long.de.ref.xml", "src_text_source": "LONG_TEXTS"}}}
{"dataset_id": "mcif_v0.2", "dataset_type": "unseen", "sample_id": 4, "src_audio": "/Users/ahrii/Documents/workspace/Research/MTM/SLT/MCIF_V0.2/LONG_AUDIOS/MmiKtcykVs.wav", "src_ref": "Hello everyone, I'm Akshatha, and today my co-author Martin and I are presenting our work \"The KITMUS Test: Evaluating Knowledge Integration from Multiple Sources.\" This work is a collaboration between McGill University, Mila, and Microsoft Research. Natural language understanding models draw on a variety of knowledge sources, such as knowledge contained in their parameters, usually acquired by a pretraining, and knowledge given in inputs at inference time. Recent works in tasks like question answering show that models can use pretrained-time knowledge to solve the task. But natural language understanding often requires knowledge that is also supplied at inference time. For example, in the sentence, \"John saw the newly elected president on TV.\" Pretrained parameters can contain information about what presidents do and what a TV is but they cannot reliably know who this instance-specific entity \"John\" is, or who the new president is, because the president might have changed since pretraining. Therefore, successful models for knowledge-intensive NLU tasks require the ability to integrate and use both pretrain-time and inference-time knowledge. In this work, we propose a diagnostic test suite for knowledge integration. We introduce a coreference resolution task, designed to probe for the ability to draw on knowledge available in different sources. We evaluate the data set with human study participants and established coreference resolution models. Here is an example from our data set. Servin is a judge. Kea is a Baker. Servin and Kea met at a park. After a long day at work deciding cases in a law court, he was happy to relax. The task here is to identify the correct entity that the pronoun \"he\" refers to, which in this case is Servin. The resolution of a given pronoun requires two types of information. First, entity-specific knowledge such as \"Servin is a judge.\" And second, background knowledge such as \"Judges decide cases in law courts.\" Generally, background knowledge is learned during the pretraining of large language models, while entity-specific knowledge is typically observed at inference time. We vary the availability of these two pieces of information such that it may either be found in a single source, or in multiple sources. We have defined three settings of KITMUS. First, we have the typical setting: \"Background-Pretrain\", where background knowledge is assumed to be available at pretrain time. Second, there's a \"Background-Both\" setting, where background knowledge is available both at pretrain time and inference time. Lastly, the \"Background-Inference\" setting, where both knowledge types are available only at inference time. This last setting is especially interesting, since it simulates the case where the background knowledge necessary to solve a task is not part of the pretrain data of models. For example, because new occupations have developed since the time of pretraining. Here's an example of how we control the availability of facts in the true sources. In the Background-Pretrain setting, we assume that the background knowledge \"Politicians seek elected seats in government\" is contained in the pretrained parameters and in inference-time context we provide the entity-specific knowledge \"Chichester is a politician.\" In the Background-Both setting, we additionally provide not only entity-specific but also background knowledge about politicians in their inference-time context. In the Background-Inference setting, we provide the fictional occupation \"mirituer\" instead of politician because \"mirituer\" is unlikely to be contained in the pretrained parameters. We evaluate the data set both with human study participants, and established coreference resolution models. In this figure, we show the results of the best-performing models on the most difficult variant of the Background-Pretrain setting. Without task-specific training on KITMUS, both models do not perform well. When trained on KITMUS, however, both C2F and BERT4Coref perform significantly better than the random choice. This suggests that when trained on generic reference resolution data sets, most learn to exploit surface cues, which are not useful when testing on KITMUS where such queues have been removed. Additional experiments with fictional knowledge indicated even the best performing models, cannot reliably integrate backward knowledge provided only at inference time. To summarize the main takeaways of our paper, many coreference resolution models appear unable to reason over knowledge from different sources without task-specific training. However, with task-specific training, some models successfully integrate knowledge from multiple sources. Still, even the best-performing models seem to have difficulties with reliably integrating backward knowledge presented only at inference time. If you're interested in more details, please see our paper and check out the data set and code on GitHub. Thanks for listening.", "tgt_ref": "Hallo zusammen, ich bin Akshatha und heute stellen mein Co-Autor Martin und ich unsere Arbeit „The KITMUS Test: Assessing Knowledge Integration from Multiple Sources“ vor.\nDiese Arbeit ist eine Kooperation zwischen der McGill University, Mila und Microsoft Research.\nModelle zum Verstehen natürlicher Sprache stützen sich auf eine Vielzahl von Wissensquellen, zum Beispiel das in ihren Parametern enthaltene Wissen, das normalerweise durch vorheriges Training erworben wird, und das Wissen, das in den Eingaben zur Inferenzzeit enthalten ist.\nJüngste Arbeiten zu Aufgaben wie dem Beantworten von Fragen haben gezeigt, dass Modelle vortrainiertes Wissen nutzen können, um die jeweilige Aufgabe zu lösen.\nDas Verstehen natürlicher Sprache erfordert jedoch häufig Wissen, das auch während der Inferenzzeit zur Verfügung steht.\nZum Beispiel in dem Satz „John hat den neu gewählten Präsidenten im Fernsehen gesehen“.\nVortrainierte Parameter können Informationen darüber enthalten, was Präsidenten tun und was ein Fernseher ist, aber sie können nicht zuverlässig wissen, wer diese instanzspezifische Entität „John“ ist oder wer der neue Präsident ist, da sich der Präsident seit dem Vortraining geändert haben kann.\nErfolgreiche Modelle für wissensintensive NLU-Aufgaben erfordern daher die Fähigkeit, sowohl das Wissen zum Zeitpunkt des Vortrainings als auch das Wissen zur Inferenzzeit zu integrieren und zu nutzen.\nIn dieser Arbeit schlagen wir eine diagnostische Testsuite für die Wissensintegration vor.\nWir führen eine Koreferenz-Auflösungsaufgabe ein, um die Fähigkeit zu testen, auf Wissen aus verschiedenen Quellen zuzugreifen.\nWir evaluieren den Datensatz mit menschlichen Teilnehmern und etablierten Modellen zur Koreferenzauflösung.\nHier ein Beispiel aus unserem Datensatz.\nServin ist Richter.\nKea ist Bäcker.\nServin und Kea trafen sich in einem Park.\nNach einem langen Arbeitstag, an dem er Fälle vor Gericht verhandelt hat, wollte er sich entspannen.\nDie Aufgabe besteht darin, die richtige Entität zu identifizieren, auf die sich das Pronomen „er“ bezieht, in diesem Fall Servin.\nDie Auflösung eines bestimmten Pronomens erfordert zwei Arten von Informationen.\nErstens entitätsspezifisches Wissen wie „Servin ist Richter“.\nUnd zweitens Hintergrundwissen wie „Richter entscheiden Fälle in Gerichten“.\nIm Allgemeinen wird das Hintergrundwissen während des Vortrainings von Large Language Models erworben, während das entitätsspezifische Wissen typischerweise zum Zeitpunkt der Inferenz beobachtet wird.\nWir variieren die Verfügbarkeit dieser beiden Arten von Informationen, sodass sie entweder in einer einzigen Quelle oder in mehreren Quellen gefunden werden können.\nWir haben drei Einstellungen für KITMUS definiert.\nErstens haben wir die typische Einstellung „Background-Pretrain“, bei der wir davon ausgehen, dass das Hintergrundwissen zum Zeitpunkt des Vortrainings verfügbar ist.\nZweitens gibt es die Einstellung „Background-Both“, bei der das Hintergrundwissen sowohl zum Zeitpunkt des Vortrainings als auch zum Zeitpunkt der Inferenz verfügbar ist.\nSchließlich gibt es noch die Einstellung „Background-Inference“, bei der beide Arten von Wissen nur zum Zeitpunkt der Inferenz verfügbar sind.\nDieser letzte Parameter ist von besonderem Interesse, da er den Fall simuliert, dass das für die Lösung einer Aufgabe erforderliche Hintergrundwissen in den Vortrainingsdaten der Modelle nicht enthalten ist.\nZum Beispiel, weil sich seit der Zeit des Vortrainings neue Berufe herausgebildet haben.\nHier ist ein Beispiel dafür, wie wir die Verfügbarkeit von Fakten in realen Quellen kontrollieren.\nIn der Einstellung Background-Pretrain nehmen wir an, dass das Hintergrundwissen „Politiker streben nach gewählten Sitzen in der Regierung“ in den vortrainierten Parametern enthalten ist, und im Kontext der Inferenzzeit liefern wir das entitätsspezifische Wissen „Chichester ist ein Politiker“.\nIn der Einstellung Background-Both liefern wir nicht nur entitätsspezifisches Wissen, sondern auch Hintergrundwissen über Politiker im Kontext der Inferenzzeit.\nIn der Einstellung Background-Inference stellen wir den fiktiven Beruf „Mirituer“ anstelle von „Politiker“ zur Verfügung, da es unwahrscheinlich ist, dass „Mirituer“ in den vortrainierten Parametern enthalten ist.\nWir evaluieren den Datensatz sowohl mit menschlichen Teilnehmern als auch mit etablierten Modellen zur Koreferenzauflösung.\nIn dieser Abbildung zeigen wir die Ergebnisse der leistungsstärksten Modelle für die schwierigste Variante der Einstellung Background-Pretrain.\nOhne aufgabenspezifisches Training auf KITMUS schneiden beide Modelle nicht gut ab.\nWenn sie jedoch auf KITMUS trainiert werden, schneiden sowohl C2F als auch BERT4Coref deutlich besser ab als die Zufallsauswahl.\nDies deutet darauf hin, dass die meisten Modelle, wenn sie auf generischen Referenzresolutionsdatensätzen trainiert werden, lernen, Oberflächenmerkmale zu verwenden, die nicht nützlich sind, wenn sie auf KITMUS getestet werden, bei denen solche Merkmale entfernt wurden.\nZusätzliche Experimente mit fiktivem Wissen haben gezeigt, dass selbst die leistungsfähigsten Modelle nicht in der Lage sind, retrospektives Wissen zum Zeitpunkt der Inferenz zuverlässig zu integrieren.\nUm die wichtigsten Ergebnisse unserer Arbeit zusammenzufassen: Viele Modelle zur Koreferenzauflösung scheinen ohne aufgabenspezifisches Training nicht in der Lage zu sein, Wissen aus verschiedenen Quellen zu verarbeiten.\nMit aufgabenspezifischem Training gelingt es jedoch einigen Modellen, Wissen aus verschiedenen Quellen zu integrieren.\nAllerdings scheinen selbst die leistungsfähigsten Modelle Schwierigkeiten zu haben, retrospektives Wissen, das erst zum Zeitpunkt der Inferenz präsentiert wird, zuverlässig zu integrieren.\nWenn Sie an weiteren Details interessiert sind, lesen Sie bitte unsere Arbeit und schauen Sie sich den Datensatz und den Code auf GitHub an.\nVielen Dank fürs Zuhören.", "src_lang": "eng", "ref_lang": "deu", "benchmark_metadata": {"subset": "long", "task": "IF", "audio_file": "MmiKtcykVs.wav", "sources": {"ref_xml": "MCIF0.2.IF.long.de.ref.xml", "src_text_source": "LONG_TEXTS"}}}
{"dataset_id": "mcif_v0.2", "dataset_type": "unseen", "sample_id": 5, "src_audio": "/Users/ahrii/Documents/workspace/Research/MTM/SLT/MCIF_V0.2/LONG_AUDIOS/PJWMkwXVGI.wav", "src_ref": "Hi, I'm Sara Papi from the University of Trento and Foundazione Bruno Kessler and I will briefly introduce the \"Attention as a Guide for Simultaneous Speech Translation\" paper, that is a joint work with Matteo Negri and Marco Turchi. What is simultaneous speech translation? Simultaneous speech translation, or SimulST, is the process of translating spoken language into a text in another language in real time, enabling cross-language communication. And what are the problems of the current SimulST models? Specific architectures are usually trained, introducing additional modules to be optimized. Long and complicated training procedures, for example, training involving different optimization objectives. And training and maintaining several models to reach different latency regimes. For example, training a model with an average of one second latency and another one with two seconds latency, and so on. So what is our solution? First, to use already existing offline ST models without re-training or adopting specific architecture for SimulST. Use only one model for every latency regime and handle latency through specific parameters. And leverage the knowledge already acquired by the model through the attention mechanism between audio input and textual output. That is the cross-attention mechanism, and you can see an example on the right. Our solution is to propose EDAtt, or Encoder-Decoder Attention, and it is a strategy for which we decide whether to emit or not a partial translation, based on where attention points to. A word is emitted if the attention is not concentrated, that is, its sum is below a certain threshold alpha towards the last lambda speech frames, meaning that the received information is enough stable. For example, if we receive a speech chunk containing \"I'm going to talk about...\" and our model predicts the translation in German, and we will look at the cross-attention weights, we'll see that the first two words points to the earliest received speech frames, while the last word points to the last received speech frames, as lambda speech frames. This means that the first two words will be emitted while since the sum of the cross-attention is above a certain threshold alpha, we will not emit the last word and we wait for another speech chunk. If we go on and we receive another speech chunk, and our model predicts other three words and we will look at those cross-attention weights, we will see that no word points to the last lambda speech frames. This means that these three words will be emitted. If we look at the main results of EDAtt, we'll plot the simultaneous speech translation results on graphs in which we have BLEU on one side that measures the translation quality, and average lagging that is the latency measure, and we also consider the computational aware average lagging that accounts for the model's computational times to predict the output. So we want our curves to be as high as possible on this plot. But also we want that they are shifted on the left. And we compare with popular strategies that are also applied to offline models that are the Wait-k strategy and the Local Agreement. And we compare also with the state-of-the-art architecture specifically tailored for simultaneous pre-translation. These are all the results of the simultaneous speech translation strategy on German. And we see that it outperforms all the strategies applied to offline models since the curves are shifted over the left. And we also see that if we consider the actual elapsed time or the computational-aware time, that is the fastest strategy. If you want to discover more results, read our paper. And we also released open source the code and models and simultaneous output to facilitate the reproducibility of our work. Thanks for your attention.", "tgt_ref": "Hallo, ich bin Sara Papi von der Universität Trento und der Foundazione Bruno Kessler. Ich werde kurz den Artikel „Attention as a Guide for Simultaneous Speech Translation“ vorstellen, den ich zusammen mit Matteo Negri und Marco Turchi verfasst habe.\nWas ist Simultanübersetzung?\nSimultanübersetzung oder SimulST ist der Prozess, bei dem gesprochene Sprache in Echtzeit in einen Text in einer anderen Sprache übersetzt wird, um eine interlinguale Kommunikation zu ermöglichen.\nUnd wo liegen die Probleme der aktuellen SimulST-Modelle?\nIn der Regel werden bestimmte Architekturen durch die Einführung zusätzlicher Module, die optimiert werden müssen, trainiert.\nLange und komplizierte Trainingsverfahren, z. B. Training mit verschiedenen Optimierungszielen.\nUnd Training und Wartung mehrerer Modelle, um verschiedene Latenzzeiten zu erreichen.\nBeispielsweise kann ein Modell mit einer durchschnittlichen Latenz von einer Sekunde, ein anderes mit einer Latenz von zwei Sekunden usw. trainiert werden.\nWas ist also unsere Lösung?\nZunächst einmal verwenden wir bestehende Offline-ST-Modelle, ohne sie neu zu trainieren oder eine spezielle Architektur für SimulST einzuführen.\nWir verwenden nur ein Modell für jede Latenzzeit und adressieren die Latenzzeit mit spezifischen Parametern.\nAußerdem nutzen wir das Wissen, das das Modell bereits durch den Aufmerksamkeitsmechanismus zwischen Audioeingabe und Textausgabe erworben hat.\nDies ist der Cross-Attention-Mechanismus, und rechts sehen Sie ein Beispiel.\nUnsere Lösung heißt EDAtt, Encoder-Decoder Attention, und ist eine Strategie, bei der wir entscheiden, ob wir eine Teilübersetzung ausgeben oder nicht, je nachdem, wohin die Aufmerksamkeit gerichtet ist.\nEin Wort wird ausgegeben, wenn die Aufmerksamkeit nicht fokussiert ist, das heißt wenn seine Summe unter einem bestimmten Alpha-Schwellenwert zu den letzten Lambda-Sprachrahmen liegt, was bedeutet, dass die empfangene Information ausreichend stabil ist.\nWenn wir z. B. ein Sprachfragment erhalten, das „I'm going to talk about …“ enthält, und unser Modell die Übersetzung ins Deutsche vorhersagt, und wir die Cross-Attention-Gewichte betrachten, sehen wir, dass die ersten beiden Wörter auf die ersten empfangenen Sprachrahmen verweisen, während das letzte Wort auf die letzten empfangenen Sprachrahmen als Lambda-Sprachrahmen verweist.\nDas bedeutet, dass die ersten beiden Wörter ausgegeben werden, aber da die Summe der Cross-Attention-Gewichte über einem bestimmten Alpha-Schwellenwert liegt, wird das letzte Wort nicht ausgegeben und wir warten auf ein weiteres Sprachfragment.\nWenn wir fortfahren und ein weiteres Sprachpaket erhalten und unser Modell drei weitere Wörter vorhersagt und wir uns diese Cross-Attention-Gewichte ansehen, werden wir feststellen, dass keines der Wörter auf die letzten Lambda-Sprachframes verweist.\nDas bedeutet, dass diese drei Wörter ausgesprochen werden.\nWenn wir uns die wichtigsten Ergebnisse von EDAtt ansehen, stellen wir die Ergebnisse der simultanen Sprachübersetzung in Diagrammen dar. Auf der einen Seite haben wir den BLEU, der die Qualität der Übersetzung misst, und die durchschnittliche Verzögerung, die ein Maß für die Latenz ist, und wir berücksichtigen auch die berechnete durchschnittliche Verzögerung, die die Rechenzeit des Modells für die Vorhersage der Ausgabe berücksichtigt.\nWir wollen also, dass unsere Kurven in diesem Diagramm so hoch wie möglich liegen.\nWir wollen sie aber auch nach links verschieben.\nUnd wir vergleichen sie mit beliebten Strategien, die auch in Offline-Modellen verwendet werden, nämlich der Wait-k-Strategie und der lokalen Übereinstimmung.\nUnd wir vergleichen sie auch mit dem Stand der Technik der Architektur, die speziell für die simultane Vorübersetzung entwickelt wurde.\nDas sind die Ergebnisse der Simultanübersetzungsstrategie für Deutsch.\nWir sehen, dass sie alle Strategien für Offline-Modelle übertrifft, weil die Kurven nach links verschoben sind.\nUnd wir sehen auch, dass es die schnellste Strategie ist, egal ob wir die tatsächlich benötigte Zeit oder die Rechenzeit betrachten.\nWenn Sie mehr über die Ergebnisse erfahren möchten, lesen Sie unsere Arbeit.\nWir haben auch den Code und die Modelle sowie die simultane Ausgabe Open Source veröffentlicht, um die Reproduzierbarkeit unserer Arbeit zu erleichtern.\nVielen Dank für Ihre Aufmerksamkeit.", "src_lang": "eng", "ref_lang": "deu", "benchmark_metadata": {"subset": "long", "task": "IF", "audio_file": "PJWMkwXVGI.wav", "sources": {"ref_xml": "MCIF0.2.IF.long.de.ref.xml", "src_text_source": "LONG_TEXTS"}}}
{"dataset_id": "mcif_v0.2", "dataset_type": "unseen", "sample_id": 6, "src_audio": "/Users/ahrii/Documents/workspace/Research/MTM/SLT/MCIF_V0.2/LONG_AUDIOS/QTlIuodOsA.wav", "src_ref": "Hello everyone, my name is Shuheng. Today I'm going to present our paper Do CoNLL-2003 named entity taggers still work well in 2023? Let's get started. Our paper investigated the problem of generalization using the Named Entity Recognition Task or the NER task. We observe that models have been used in CoNLL-2003 to develop NER for almost 20 years and this naturally raises several problems. Firstly, can these models generalise to modern data? And when we develop new taggers, what is needed for good generalization? At the same time, if we do observe poor generalization, what causes the performance drop of these models? To investigate these problems, we developed the CoNLL++ Dataset. This is a data set that we collected from Reuters News from 2020, and then annotated them with the same CoNLL-2003 annotation guidelines. We then fine-tuned over 20 models on CoNLL-2003. We evaluated them on both the CoNLL-03 test sets and the CoNLL++. And last but not least, we calculated the percentage change in F1 to assess the generalization of each model. So what is needed for a good generalization? Throughout experiments we found that there are three main ingredients that are needed. The first one is the model architecture. Through our experiments we found that the transformer models normally generalize better to new data. The second ingredient is the model size. We found that usually larger models lead to better generalization. And last but not least, we all know that the number of fine tuning examples directly affects the performance of a downstream task. Here we also found that more fine tuning examples, actually also leads to better generalization. To our next question, what causes the performance drop of some models, We had two hypothesis. The first one is adaptive overfitting, which is overfitting costs by reusing the same test set over and over again and this is usually manifested as the diminishing returns on a new test set. The second hypothesis is temporal drift which is the performance degradation that is caused by the increasing temporal gap between the train and the test data. For data overfitting, we saw that from the graph on the right, the red best fit line has a gradient that is greater than one. This means that every unit of improvement that we made, on CoNLL-2003 translates to more than one unit improvement on CoNLL++ which means that there is no diminishing returns. And this shows us that adaptive overfitting in this case is not observed. So what about temporal drift then? For temporal drift, we did an experiment to retrain or continue to pre-train some models with more recent data and we found that the performance degrades with larger temporal gap and this confirms our hypothesis that the main cause of the performance drop is temporal drift. Our conclusion is that, for good generalization we would need a better model architecture, larger model size, as well as more fine tuning examples. And these goes hand in hand, we can't just have one ingredient but throw out the others. At the same time, we also found that the performance drop here is caused by temporal drift and kind of surprisingly, it is not caused by adaptive overfitting even though CoNLL-2003 has been used for over 20 years. So going back to the question that we raised in the title of our paper Do CoNLL-2003 taggers still work in 2023? And we found that the answer is actually a resounding yes. We hope our paper calls for more research on how to improve generalizations of the models. And lastly, please make sure to check out our paper, our data set and if you have any questions, feel free to contact me. Thank you so much.", "tgt_ref": "Hallo zusammen, mein Name ist Shuheng.\nHeute werde ich Ihnen unsere Arbeit „Do CoNLL-2003 named entity taggers still work well in 2023?“ vorstellen.\nFangen wir an.\nIn unserem Beitrag haben wir das Problem der Generalisierung anhand der Aufgabe der Erkennung benannter Entitäten (Named Entity Recognition, NER) untersucht.\nWir haben festgestellt, dass die Modelle, die in CoNLL-2003 zur Entwicklung von NER verwendet wurden, seit fast 20 Jahren in Gebrauch sind, was natürlich einige Probleme aufwirft.\nErstens: Können diese Modelle auf moderne Daten verallgemeinert werden?\nUnd wenn wir neue Tagger entwickeln, was ist dann für eine gute Generalisierung notwendig?\nWenn wir eine schlechte Generalisierung beobachten, was ist dann der Grund für den Leistungsabfall dieser Modelle?\nUm diese Probleme zu untersuchen, haben wir den CoNLL++-Datensatz entwickelt.\nDabei handelt es sich um einen Datensatz, den wir von Reuters News aus dem Jahr 2020 gesammelt und dann mit den gleichen CoNLL-2003 Annotationsrichtlinien annotiert haben.\nAnschließend haben wir über 20 Modelle mit CoNLL-2003 feinjustiert.\nWir haben sie sowohl mit den CoNLL-03 als auch mit den CoNLL++ Testsätzen evaluiert.\nSchließlich haben wir die prozentuale Änderung von F1 berechnet, um die Generalisierung jedes Modells zu bewerten.\nWas ist also notwendig, um eine gute Generalisierung zu erreichen?\nWährend der Experimente haben wir festgestellt, dass drei Hauptkomponenten erforderlich sind.\nDie erste ist die Modellarchitektur.\nIn unseren Experimenten haben wir festgestellt, dass Transformer-Modelle tendenziell besser auf neue Daten verallgemeinern.\nDie zweite Komponente ist die Modellgröße.\nWir haben festgestellt, dass größere Modelle in der Regel zu einer besseren Generalisierung führen.\nUnd nicht zuletzt wissen wir alle, dass die Anzahl der Beispiele, die für die Feinjustierung verwendet werden, einen direkten Einfluss auf die Leistung einer nachgeschalteten Aufgabe hat.\nAuch hier haben wir festgestellt, dass mehr Beispiele für die Feinjustierung tatsächlich zu einer besseren Generalisierung führen.\nFür unsere nächste Frage nach der Ursache für den Leistungsabfall einiger Modelle hatten wir zwei Hypothesen.\nDie erste ist die adaptive Überanpassung, also eine Überanpassung der Kosten, die durch die wiederholte Verwendung desselben Testsatzes entsteht, was sich in der Regel in einer geringeren Leistung bei einem neuen Testsatz manifestiert.\nDie zweite Hypothese ist die zeitliche Drift, d. h. die Verschlechterung der Leistung, die durch den zunehmenden zeitlichen Abstand zwischen Trainings- und Testdaten verursacht wird.\nBezüglich der Überanpassung der Daten zeigt das Diagramm rechts, dass die rote Best-Fit-Linie eine Steigung von mehr als eins aufweist.\nDas bedeutet, dass jede Einheit Verbesserung, die wir in CoNLL-2003 erreicht haben, zu mehr als einer Einheit Verbesserung in CoNLL++ führt, was bedeutet, dass keine sinkenden Erträge bestehen.\nDies zeigt uns wiederum, dass in diesem Fall keine adaptive Überanpassung beobachtet wird.\nUnd was ist mit der zeitlichen Drift?\nIn Bezug auf die zeitliche Drift haben wir ein Experiment durchgeführt, um einige Modelle mit neueren Daten neu bzw. weiter zu trainieren. Dabei haben wir festgestellt, dass die Leistung mit zunehmendem Zeitabstand abnimmt, was unsere Hypothese bestätigt, dass die Hauptursache für den Leistungsabfall die zeitliche Drift ist.\nUnsere Schlussfolgerung ist, dass wir für eine gute Generalisierung eine bessere Modellarchitektur, eine größere Modellgröße und mehr Feinabstimmungsbeispiele benötigen.\nDas geht wohlgemerkt Hand in Hand, wir können nicht nur eine Komponente haben und die anderen wegwerfen.\nGleichzeitig haben wir festgestellt, dass der Leistungsabfall hier durch zeitliche Drift verursacht wird und überraschenderweise nicht durch adaptive Überanpassung, obwohl CoNLL-2003 seit über 20 Jahren im Einsatz ist.\nUm auf die im Titel unserer Arbeit gestellte Frage zurückzukommen: Werden CoNLL-2003 Tagger im Jahr 2023 noch funktionieren?\nWir haben festgestellt, dass die Antwort eigentlich ein klares Ja ist.\nWir hoffen, dass unser Artikel zu weiterer Forschung dazu anregt, wie die Generalisierung der Modelle verbessert werden kann.\nAbschließend möchten wir Sie einladen, einen Blick auf unsere Arbeit und unseren Datensatz zu werfen. Wenn Sie Fragen haben, zögern Sie bitte nicht, mich zu kontaktieren.\nVielen Dank.", "src_lang": "eng", "ref_lang": "deu", "benchmark_metadata": {"subset": "long", "task": "IF", "audio_file": "QTlIuodOsA.wav", "sources": {"ref_xml": "MCIF0.2.IF.long.de.ref.xml", "src_text_source": "LONG_TEXTS"}}}
{"dataset_id": "mcif_v0.2", "dataset_type": "unseen", "sample_id": 7, "src_audio": "/Users/ahrii/Documents/workspace/Research/MTM/SLT/MCIF_V0.2/LONG_AUDIOS/UOlPKyCVgg.wav", "src_ref": "Hi! Welcome to our presentation of DEPLAIN, a new corpus for German text identification on the document level, and on the sentence level. My name is Regina Stodden, and I will guide you through the first part of the presentation. Let's first define text simplification. Text simplification is a process of adapting a text to improve the text comprehension of it for a specific target group, as people with reading problems or non-native speakers. To train a text simplification model we require parallel pairs of text, for example of documents or sentences. And the example here, you can see a parallel aligned sentence pair of a complex German sentence and its translation into plain language. To simplify the sentence, different techniques are possible as you can see in the example, such as lexical substitution, clause deletion, reordering, or insertion of words. We now propose our new corpus, DEPLAIN because in the recent years, there were some problems with existing corpora. So for example, these corpora here are too small to train a text simplification model on. The other three models which are proposed in recent years are all automatically aligned, which means they can be error-prone in their alignments. Therefore, we propose our new corpus DEPLAIN, which is split into two subcorpora: DEPLAIN-apa and DEPLAIN-web. DEPLAIN-apa is based on news texts. In DEPLAIN-apa, we aligned 483 documents all manually. It results in roughly 13,000 parallel sentence pairs. For DEPLAIN-web, this corpus includes different domains and we also align all of these 750 documents, on the one hand manually and on the other hand with automatic alignment methods. In total we result in 30,450 sentence pairs. We analyzed our sentence pairs a little bit more, so for example, on the type of simplification. As you can see here, the Bible texts are much, stronger simplified than for example the news text, or the language learner texts. On all levels, regarding for example lexical simplification, structure simplification, also overall level of simplification. Furthermore, you can see that our DEPLAIN corpus has a high variety of different simplification transformations. So for example, in the DEPLAIN-apa corpus we have much more reorderings and word additions than we have in the DEPLAIN-web corpus. On the other hand, in the web corpus we have much more rephrasings. So let's now see what we can do with this corpus. Hello, I am Omar and now I will talk about the use cases for our data set DEPLAIN. So for the first use case, we can evaluate automatic alignment methods. In the recent years, there has been a lot of alignment methods, but in the context of machine translations, where we have two parallel documents written in different languages and we want to extract alignments of sentences in both documents. But in our use case, we are trying to extract alignments between sentences of two parallel documents having the same language, having the same content, but they are on a different complexity level. And now as we have our data set DEPLAIN, which have manually aligned sentences we can use these sentences as gold standard alignments to evaluate some of the proposed alignment methods. And we did some adaptations to the proposed methods, and we have published all these adaptations and the codes to run our experiments in the paper. At the end, we concluded that the best automatic alignment method to use for German text simplification is the method of MASSalign. And you can also find the code to run this method on your own documents in the paper. The second use case that we showed in our paper is a case of automatic text simplification by fine-tuning language models to produce simplified text from the complex input text. We have fine-tuned two different models. We have fine-tuned the model of long-mBART to produce document-level simplifications, and we also fine-tuned the normal base mBART to produce sentence-level simplifications. You can also find all the checkpoints and you can look into more details at the scores and the evaluation metrics of our experiments in the paper. We concluded that this basic fine-tuning could produce or could get scores better than the baseline scores, and we proposed those results as a base benchmark for the problem of automatic text simplification in the future. Thank you so much for your attention and we hope to meet all of you during the conference. Thank you.", "tgt_ref": "Hallo!\nHerzlich willkommen zu unserer Präsentation von DEPLAIN, einem neuen Korpus für die deutsche Texterkennung auf Dokument- und Satzebene.\nMein Name ist Regina Stodden und ich werde Sie durch den ersten Teil der Präsentation führen.\nLassen Sie uns zunächst definieren, was Textvereinfachung ist.\nUnter Textvereinfachung versteht man die Anpassung eines Textes, um ihn für eine bestimmte Zielgruppe leichter verständlich zu machen, zum Beispiel für Menschen mit Leseschwierigkeiten oder Nicht-Muttersprachler.\nUm ein Modell zur Textvereinfachung zu trainieren, benötigen wir parallele Textpaare, zum Beispiel Dokumente oder Sätze.\nIn diesem Beispiel sehen Sie ein parallel ausgerichtetes Paar aus einem komplexen deutschen Satz und seiner Übersetzung in einfache Sprache.\nUm den Satz zu vereinfachen, gibt es, wie Sie im Beispiel sehen können, verschiedene Techniken, zum Beispiel lexikalische Substitution, Streichung, das Umstellen oder Einfügen von Wörtern.\nWir schlagen jetzt unser neues Korpus DEPLAIN vor, weil es in den letzten Jahren einige Probleme mit den bestehenden Korpora gegeben hat.\nBeispielsweise sind diese Korpora zu klein, um ein Modell zur Textvereinfachung zu trainieren.\nDie anderen drei Modelle, die in den letzten Jahren vorgeschlagen wurden, werden alle automatisch abgeglichen, was bedeutet, dass sie anfällig für Alignmentfehler sind.\nAus diesem Grund schlagen wir unser neues Korpus DEPLAIN vor, das in zwei Unterkorpora unterteilt ist: DEPLAIN-apa und DEPLAIN-web.\nDEPLAIN-apa basiert auf Nachrichtentexten.\nIn DEPLAIN-apa wurden 483 Dokumente manuell abgeglichen.\nDaraus ergeben sich ca. 13.000 parallele Satzpaare.\nIn DEPLAIN-web umfasst dieses Korpus verschiedene Domains, und wir haben auch diese 750 Dokumente sowohl manuell als auch mit automatischen Alignmentmethoden abgeglichen.\nInsgesamt ergeben sich 30.450 Satzpaare.\nWir haben unsere Satzpaare etwas genauer analysiert, zum Beispiel in Bezug auf die Art der Vereinfachung.\nWie Sie hier sehen können, sind die biblischen Texte viel, viel stärker vereinfacht als zum Beispiel die Nachrichtentexte oder die Texte für Sprachschüler.\nAuf allen Ebenen, zum Beispiel lexikalische Vereinfachung, strukturelle Vereinfachung, auch die allgemeine Vereinfachungsebene.\nSie können auch sehen, dass unser DEPLAIN-Korpus eine große Vielfalt an verschiedenen Vereinfachungs-Transformationen aufweist.\nZum Beispiel haben wir im DEPLAIN-apa-Korpus viel mehr Umstellungen und Wortergänzungen als im DEPLAIN-web-Korpus.\nAndererseits haben wir im web-Korpus viel mehr Umformulierungen.\nSchauen wir also, was wir mit diesem Korpus machen können.\nHallo, mein Name ist Omar und ich werde über die Anwendungsfälle für unser DEPLAIN-Korpus sprechen.\nFür den ersten Anwendungsfall können wir automatische Alignmentmethoden evaluieren.\nIn den letzten Jahren gab es viele Alignmentmethoden, wie etwa im Kontext der maschinellen Übersetzung, bei der wir zwei parallele Dokumente in verschiedenen Sprachen haben und Alignments von Sätzen in beiden Dokumenten extrahieren möchten.\nIn unserem Anwendungsfall versuchen wir jedoch, Alignments zwischen Sätzen aus zwei parallelen Dokumenten zu extrahieren, die in derselben Sprache verfasst sind, denselben Inhalt haben, aber unterschiedlich komplex sind.\nDa wir nun über unseren DEPLAIN-Datensatz verfügen, der manuell abgeglichene Sätze enthält, können wir diese Sätze als Goldstandard-Alignments verwenden, um einige der vorgeschlagenen Alignmentmethoden zu evaluieren.\nWir haben einige Anpassungen an den vorgeschlagenen Methoden vorgenommen und all diese Anpassungen sowie die Codes zur Durchführung unserer Experimente in der Publikation veröffentlicht.\nAm Ende kamen wir zu dem Schluss, dass die beste automatische Alignmentmethode für die Vereinfachung deutscher Texte die MASSalign-Methode ist.\nSie finden in der Arbeit auch den Code, mit dem Sie diese Methode auf Ihre eigenen Dokumente anwenden können.\nDer zweite Anwendungsfall, den wir in unserer Arbeit gezeigt haben, ist ein Fall von automatischer Textvereinfachung, bei dem Sprachmodelle so abgestimmt werden, dass sie aus einem komplexen Eingabetext einen vereinfachten Text erzeugen.\nWir haben zwei verschiedene Modelle feingliedrig abgestimmt.\nWir haben das long-mBART-Modell feinabgestimmt, um Vereinfachungen auf Dokumentebene zu erzeugen, und wir haben auch das normale mBART-Basismodell feinabgestimmt, um Vereinfachungen auf Satzebene zu erzeugen.\nSie können auch alle Kontrollpunkte finden und einen genaueren Blick auf die Ergebnisse und Evaluierungsmetriken unserer Experimente in der Arbeit werfen.\nWir sind zu dem Schluss gekommen, dass diese grundlegende Feinabstimmung zu besseren Ergebnissen führen kann als die Basisergebnisse, und wir schlagen vor, dass diese Ergebnisse als grundlegende Benchmark für das Problem der automatischen Textvereinfachung in der Zukunft dienen.\nVielen Dank für Ihre Aufmerksamkeit und wir hoffen, Sie alle während der Konferenz noch persönlich zu treffen.\nVielen Dank.", "src_lang": "eng", "ref_lang": "deu", "benchmark_metadata": {"subset": "long", "task": "IF", "audio_file": "UOlPKyCVgg.wav", "sources": {"ref_xml": "MCIF0.2.IF.long.de.ref.xml", "src_text_source": "LONG_TEXTS"}}}
{"dataset_id": "mcif_v0.2", "dataset_type": "unseen", "sample_id": 8, "src_audio": "/Users/ahrii/Documents/workspace/Research/MTM/SLT/MCIF_V0.2/LONG_AUDIOS/crgYiwKDfX.wav", "src_ref": "Hi, I'm Siyu Yuan from Fudan University. I'm here to introduce our work \"Distilling Script Knowledge from Large Language Models for Constrained Language Planning\". In everyday life, humans often plan their actions by following step-by-step instructions in the form of goal-oriented scripts. Previous work has exploited language models to plan for abstract goals of stereotypical activities such as \"make a cake\". And show that large language models can effectively decompose goals into steps. However, previous work mainly focuses on planning for the abstract goals of stereotypical activities. Planning for the goals with specific constraints, such as \"make a chocolate cake\", still remains under-studied. In this paper, we define the problem of constrained language planning which imposes different constraints on the goals of planning. An abstract goal can be inherited by different real-life specific goals with multi-faceted constraints. A good planner should write scripts that are reasonable and faithful to constraints. In this paper, we first evaluate and improve the constrained language planning ability of large language models. Since no dataset of specific goals exists to support our study, we have to acquire these goals first. As shown in the table, we extend the abstract goals with multi-faceted constraints for human-in-the-loop data acquisition using InstructGPT. We sample 100 specific goals and evaluate the scripts generated from large language models. This table reports the overall accuracy of the results. We find that all language models achieve unsatisfactory results on planning for specific goals. Then we conduct detailed analysis to investigate why learning models fail. Results in the figure show that the semantic completeness in generated scripts is acceptable but the faithfulness to the constraints cannot be guaranteed. We dig into a more fine-grained topic categories of constraints defined in wikiHow. The heat map in the figure shows that the planning performance of InstructGPTs varies considerably for goals of different categories. Previous studies have shown that the output quality of language models falls in high variance, leading to bad performance. Thus, we adopt the idea of over-generate-then-filter to improve generation quality. We first show constraint types with examples for InstructGPT and obtain specific goals based on the seed abstract goals. Then, InstructGPT over-generates K scripts for specific goals. Next, a filter model is developed to select the faithful scripts. We convert scripts and goals into InstructGPT embeddings and calculate the cosine similarity as similarity scores to measure semantic similarity. In addition, we reward the script that contains the keywords of the target constraint. We only keep the script if the target goal scores the highest in the goal set. With our method, InstructGPT can generate scripts of higher quality. Our method greatly improves the planning ability both in semantic completeness and faithfulness to the constraint. Since large language models are costly to deploy, it's essential to enable language planning ability of smaller and specialized models. Creating the dataset is an essential step to this end. However, previous studies do not enable planning for specific goals and manual dataset annotation is expensive. Thus, we follow the idea of symbolic knowledge distillation, to distil constrained language planning datasets from large language models. We appy our method for building a dataset of constrained language planning, named as CoScript. In total, we generate 55,000 specific goals with scripts. To ensure the quality of the validation and test set, we ask crowd-sourced workers to find and revise the incorrect samples. This figure shows the constraint distribution of CoScript. We find CoScript shows high pluralism in the generated specific goals. With CoScript we can try smaller but specialized models for constrained language planning. We find that T5 fine-tuned on CoScript can generate scripts of higher quality than most large language models, indicating that smaller models can surpass larger models when properly trained on suitable datasets. In summary, we establish the constrained language planning problem. We evaluate constrained language planning ability of large language models and develop an over-generate-then-filter method for large language models. We use large language models to generate a high-quality script dataset, CoScript, for constrained language planning. We hope the CoScript dataset can be a valuable resource to advance research on language planning. Thanks for your time. Please find more details of CoScript in our paper.", "tgt_ref": "Hallo, ich bin Siyu Yuan von der Fudan Universität.\nIch bin hier, um unsere Arbeit „Distilling Script Knowledge from Large Language Models for Constrained Language Planning“ vorzustellen.\nIm Alltag planen Menschen ihre Handlungen oft, indem sie Schritt-für-Schritt-Anweisungen in Form von zielorientierten Skripten folgen.\nFrühere Arbeiten haben Sprachmodelle verwendet, um abstrakte Ziele für stereotype Aktivitäten wie „einen Kuchen backen“ zu planen.\nSie zeigen, dass Large Language Models Ziele effektiv in Schritte zerlegen können.\nBisherige Arbeiten haben sich jedoch hauptsächlich auf die Planung abstrakter Ziele für stereotype Aktivitäten konzentriert.\nDie Planung von Zielen mit spezifischen Beschränkungen, wie zum Beispiel „einen Schokoladenkuchen backen“, ist noch wenig erforscht.\nIn dieser Arbeit definieren wir das Problem der eingeschränkten Sprachplanung, bei dem die Planungsziele verschiedenen Beschränkungen unterliegen.\nEin abstraktes Ziel kann von mehreren konkreten, spezifischen Zielen mit mehreren Beschränkungen abgeleitet werden.\nEin guter Planer sollte Skripte schreiben, die vernünftig sind und sich an die Beschränkungen halten.\nIn dieser Arbeit evaluieren und verbessern wir zunächst die Fähigkeit von Large Language Models zur Planung mit Beschränkungen.\nDa es keinen Datensatz mit spezifischen Zielen für unsere Studie gibt, müssen wir uns diese Ziele erst beschaffen.\nWie in der Tabelle zu sehen ist, erweitern wir die abstrakten Ziele mit mehrschichtigen Beschränkungen für die Human-in-the-Loop-Datenerfassung mit InstructGPT.\nWir wählen 100 spezifische Ziele aus und evaluieren die Skripte, die aus Large Language Models generiert wurden.\nDiese Tabelle zeigt die Gesamtgenauigkeit der Ergebnisse.\nWir stellen fest, dass alle Sprachmodelle bei der Planung spezifischer Ziele unbefriedigende Ergebnisse liefern.\nAnschließend führen wir eine detaillierte Analyse durch, um die Gründe für das Versagen der Lernmodelle zu untersuchen.\nDie in der Abbildung dargestellten Ergebnisse zeigen, dass die semantische Vollständigkeit der generierten Skripte akzeptabel ist, dass aber die Beschränkungstreue nicht garantiert werden kann.\nWir betrachten einen feingliedrigeren Satz von Themenkategorien von Beschränkungen, die in wikiHow definiert sind.\nDie Heatmap in der Abbildung zeigt, dass die Planungsleistung von InstructGPTs für Ziele verschiedener Kategorien erheblich variiert.\nFrühere Studien haben gezeigt, dass die Ausgabequalität von Sprachmodellen mit hoher Varianz abnimmt, was zu einer schlechten Leistung führt.\nDaher wenden wir die Idee der Übergenerierung und anschließenden Filterung an, um die Generierungsqualität zu verbessern.\nZuerst werden Beschränkungsarten mit Beispielen für InstructGPT gezeigt und spezifische Ziele basierend auf den abstrakten Zielen des Seeds erhalten.\nDann übergeneriert InstructGPT K-Skripte für spezifische Ziele.\nAnschließend wird ein Filtermodell entwickelt, um treue Skripte auszuwählen.\nWir konvertieren die Skripte und Ziele in InstructGPT-Einbettungen und berechnen die Kosinusähnlichkeit als Ähnlichkeitswert, um die semantische Ähnlichkeit zu messen.\nZusätzlich belohnen wir das Skript, das die Schlüsselwörter der Zielbeschränkung enthält.\nWir behalten das Skript nur, wenn das Ziel die höchste Punktzahl in der Zielmenge hat.\nMit unserer Methode kann InstructGPT Skripte von höherer Qualität erzeugen.\nUnsere Methode verbessert die Planbarkeit sowohl in Bezug auf semantische Vollständigkeit als auch in Bezug auf Beschränkungstreue erheblich.\nDa Large Language Models teuer in der Bereitstellung sind, ist es wichtig, die Sprachplanungsfähigkeit auch für kleinere und spezialisiertere Modelle zu ermöglichen.\nDie Erstellung des Datensatzes ist ein wichtiger Schritt in diese Richtung.\nBisherige Studien erlauben jedoch keine Planung für spezifische Ziele, und die manuelle Annotation des Datensatzes ist teuer.\nDaher verfolgen wir die Idee der symbolischen Wissensdestillation, um eingeschränkte Sprachplanungsdatensätze aus großen Sprachmodellen zu destillieren.\nWir wenden unsere Methode zur Erstellung eines Datensatzes zur eingeschränkten Sprachplanung an, der CoScript genannt wird.\nInsgesamt generieren wir 55.000 spezifische Ziele mit Skripten.\nUm die Qualität des Validierungs- und Testdatensatzes sicherzustellen, bitten wir die Crowdsourcer, die fehlerhaften Beispiele zu finden und zu überarbeiten.\nDiese Abbildung zeigt die Verteilung der Beschränkungen von CoScript.\nEs ist zu erkennen, dass CoScript einen hohen Pluralismus der generierten spezifischen Ziele aufweist.\nMit CoScript können wir kleinere, aber spezialisierte Modelle für die eingeschränkte Sprachplanung ausprobieren.\nWir stellen fest, dass T5, das an CoScript angepasst wurde, Skripte von höherer Qualität erzeugen kann als die meisten Large Language Models, was darauf hindeutet, dass kleinere Modelle größere Modelle übertreffen können, wenn sie auf geeigneten Datensätzen richtig trainiert werden.\nZusammenfassend stellen wir das Problem der begrenzten Sprachplanung vor.\nWir evaluieren die Fähigkeit von Large Language Models zur eingeschränkten Sprachplanung und entwickeln eine Übergenerierungs- und Filterungsmethode für große Sprachmodelle.\nWir verwenden Large Language Models, um einen qualitativ hochwertigen Skriptdatensatz, CoScript, für die eingeschränkte Sprachplanung zu erzeugen.\nWir hoffen, dass der CoScript-Datensatz eine wertvolle Ressource sein wird, um die Forschung auf dem Gebiet der Sprachplanung voranzutreiben.\nVielen Dank für Ihre Zeit.\nWeitere Details zu CoScript finden Sie in unserer Arbeit.", "src_lang": "eng", "ref_lang": "deu", "benchmark_metadata": {"subset": "long", "task": "IF", "audio_file": "crgYiwKDfX.wav", "sources": {"ref_xml": "MCIF0.2.IF.long.de.ref.xml", "src_text_source": "LONG_TEXTS"}}}
{"dataset_id": "mcif_v0.2", "dataset_type": "unseen", "sample_id": 9, "src_audio": "/Users/ahrii/Documents/workspace/Research/MTM/SLT/MCIF_V0.2/LONG_AUDIOS/csJIsDTYMW.wav", "src_ref": "Hi, I am Yanis Labrak and I will present you our works on \"DrBERT: A Robust Pre-trained Model in French for Biomedical and Clinical Domains.\" In this presentation, we first talk about language modeling in healthcare. Then we will present the main contribution of our article. We introduce the first biomedical model in French named DrBERT, which is based on RoBERTa and trained on NACHOS, which is a data set of medical crawled data from the web. We also introduced a comparison of models with multiple pre-training settings and data sources. Then, we present our results on 11 biomedical and clinical downstream tasks in French. And finally, we conclude about the experiments and give you more details about how to access those models. Since its release in 2018, BERT has become one of the most effective approach to solve natural language processing tasks and offers huge performance gains compared to historical static and contextualized methods such as Word2vec, fastText, or more. Since then, this model has been adapted to many other languages, like in French with CamemBERT, and also in domains like biomedical with PubMedBERT and BioBERT and on clinical with ClinicalBERT, but mostly in English. Specialized models for other languages are scarce and are often based on continual pre-training due to the lack of in-domain data. However, French didn't have any open source model for biomedical until now. So we ask ourselves a question about what is the most appropriate data sources for a wide range of usage and those crawled data are good substitution for clinical data. To answer this question, we compare DrBERT with our ChuBERT model, which is based on anonymized data obtained from the Nantes University Hospital data warehouse. Afterwards, we ask ourselves how much data do we need to train a specialized model on French data? Is it 4 gigabytes, 8 gigabytes, or more? To answer this question, we first train and compare four from-scratch models: a first version of DrBERT, with 7 GB of NACHOS; a second version of 4 GB of set of NACHOS; a first version of ChuBERT, which is a clinical model with 4 GB of sentences taken from clinical notes; and a final version of ChuBERT with a mix of 4 GB of set of NACHOS and 4 GB of clinical notes. In addition to this comparison, we introduced three models trained on continual pre-training to analyze the impact of pre-training strategy. One based on the weight of CamemBERT and trained on a 4 GB set of NACHOS. Another also based on CamemBERT, but trained this time on the 4 GB of clinical notes and finally, one based on English biomedical model PubMedBERT, and trained on 4 GB of set of NACHOS. In total, we have seven models. To evaluate our seven models, we gather data for public and private downstream tasks such as named entity recognition, classification, part-of-speech tagging, and question answering. These models are compared to six baseline models which are CamemBERT OSCAR 138 GB, CamemBERT OSCAR 4 GB, CamemBERT CCNET 4 GB, PubMedBERT, BioBERT, and ClinicalBERT. The evaluation highlights that models performed best on the task with data of the same nature as those on which the model has been trained. However, we can observe that data from heterogeneous sources appear to be more versatile. We also observe that using more data translated to better performance. Overall, from-scratch pre-training seems to obtain higher performance on most of the tasks. However, our experiment on control pre-training using the weight and tokenization of CamemBERT trained on the four GB subset of NACHOS showed comparable results to those obtained with DrBERT 4 GB from-scratch. Which is not the case for the model based on CamemBERT weights and tokenizer, which suffer from stability issues. Finally, as a conclusion our proper system offered better performance on nine of the 11 downstream tasks and surpassed globally the result of the generic model, here CamemBERT. We are also observing that more specialized data is better, but it doesn't scale well. All the pre-trained model obtained from NACHOS are freely available on Hugging Face, and under the MIT license, and all the training scripts are on our GitHub repository. So thank you for this presentation, and we are looking forward to exchange at the poster session in Toronto.", "tgt_ref": "Hallo, mein Name ist Yanis Labrak und ich werde unsere Arbeit „DrBERT: A Robust Pre-trained Model in French for Biomedical and Clinical Domains“ vorstellen.\nIn dieser Präsentation werden wir zunächst über Sprachmodellierung im Gesundheitswesen sprechen.\nAnschließend präsentieren wir den Hauptbeitrag unserer Arbeit.\nWir werden das erste biomedizinische Modell in französischer Sprache namens DrBERT vorstellen, das auf RoBERTa basiert und auf NACHOS trainiert wurde, einem Datensatz mit medizinischen Daten, die aus dem Internet gecrawlt wurden.\nWir werden auch einen Vergleich von Modellen mit verschiedenen Vortrainingseinstellungen und Datenquellen präsentieren.\nAnschließend präsentieren wir unsere Ergebnisse für 11 biomedizinische und klinische Aufgaben in französischer Sprache.\nAbschließend fassen wir die Experimente zusammen und geben Ihnen weitere Informationen, wie Sie auf die Modelle zugreifen können.\nSeit seiner Veröffentlichung im Jahr 2018 hat sich BERT zu einem der effizientesten Ansätze für die Verarbeitung natürlicher Sprache entwickelt und bietet erhebliche Leistungsverbesserungen im Vergleich zu historischen statischen und kontextualisierten Methoden wie Word2vec oder fastText.\nSeitdem wurde dieses Modell an viele andere Sprachen angepasst, zum Beispiel an Französisch mit CamemBERT, an Domains wie Biomedizin mit PubMedBERT und BioBERT und an die klinische Domain mit ClinicalBERT, aber vor allem an Englisch.\nFür andere Sprachen gibt es nur wenige spezialisierte Modelle, die aufgrund des Mangels an Domain-eigenen Daten oft auf kontinuierlichem Vortraining basieren.\nFür Französisch gibt es jedoch noch kein Open-Source-Modell für die Biomedizin.\nWir fragen uns also, welche Datenquellen für eine breite Palette von Anwendungen am besten geeignet sind, und diese gecrawlten Daten sind ein guter Ersatz für klinische Daten.\nUm diese Frage zu beantworten, vergleichen wir DrBERT mit unserem Modell ChuBERT, das auf anonymisierten Daten aus dem Data Warehouse des Universitätsklinikums Nantes basiert.\nDann fragen wir uns: Wie viele Daten brauchen wir, um ein spezialisiertes Modell auf französischen Daten zu trainieren?\nSind es 4 Gigabyte, 8 Gigabyte oder mehr?\nUm diese Frage zu beantworten, trainieren und vergleichen wir zunächst vier Modelle von Grund auf: eine erste Version von DrBERT mit 7 GB NACHOS; eine zweite Version mit 4 GB NACHOS; eine erste Version von ChuBERT, das ist ein klinisches Modell, mit 4 GB klinischen Aufzeichnungen; und eine letzte Version von ChuBERT mit einer Mischung aus 4 GB NACHOS und 4 GB klinischen Aufzeichnungen.\nZusätzlich zu diesem Vergleich haben wir drei Modelle eingeführt, die mit kontinuierlichem Vortraining trainiert wurden, um die Auswirkungen der Vortrainingsstrategie zu analysieren.\nEin Modell basiert auf der Gewichtung von CamemBERT und wurde mit einem Satz von 4 GB NACHOS trainiert.\nEin weiteres, das ebenfalls auf CamemBERT basiert, aber dieses Mal auf den 4 GB klinischen Aufzeichnungen trainiert wurde, und schließlich ein weiteres, das auf dem englischen biomedizinischen Modell PubMedBERT basiert und auf einem 4 GB großen Satz von NACHOS trainiert wurde.\nInsgesamt verfügen wir also über sieben Modelle.\nUm unsere sieben Modelle zu evaluieren, sammeln wir Daten für öffentliche und private nachgeschaltete Aufgaben wie Named Entity Recognition, Klassifikation, Part-of-Speech Tagging und Question Response.\nDiese Modelle werden mit sechs Basismodellen verglichen: CamemBERT OSCAR 138 GB, CamemBERT OSCAR 4 GB, CamemBERT CCNET 4 GB, PubMedBERT, BioBERT und ClinicalBERT.\nDie Auswertung zeigt, dass die Modelle am besten abschneiden, wenn sie mit Daten desselben Typs arbeiten, auf dem das Modell trainiert wurde.\nWir können jedoch feststellen, dass Daten aus heterogenen Quellen vielseitiger zu sein scheinen.\nWir beobachten auch, dass die Verwendung von mehr Daten zu einer besseren Leistung führt.\nInsgesamt scheint das Vortraining bei den meisten Aufgaben zu einer besseren Leistung zu führen.\nUnser Kontrollexperiment zum Vortraining mit der Gewichtung und Tokenisierung von CamemBERT, trainiert auf der 4 GB Untermenge von NACHOS, zeigte jedoch vergleichbare Ergebnisse wie mit nicht vortrainierten 4 GB DrBERT.\nDies ist nicht der Fall für das Modell, das auf den CamemBERT-Gewichten und dem Tokenisierer basiert, bei denen Stabilitätsprobleme bestehen.\nSchließlich kommen wir zu dem Schluss, dass unser dediziertes System in neun der elf Downstream-Aufgaben eine bessere Leistung erbringt und insgesamt das Ergebnis des generischen Modells, in diesem Fall CamemBERT, übertrifft.\nWir stellen auch fest, dass mehr spezialisierte Daten besser sind, aber nicht gut skalieren.\nAlle vortrainierten Modelle, die wir von NACHOS erhalten haben, sind auf Hugging Face und unter der MIT-Lizenz frei verfügbar und alle Trainingsskripte sind in unserem GitHub Repository zu finden.\nVielen Dank für diese Präsentation und wir freuen uns auf den Austausch bei der Postersession in Toronto.", "src_lang": "eng", "ref_lang": "deu", "benchmark_metadata": {"subset": "long", "task": "IF", "audio_file": "csJIsDTYMW.wav", "sources": {"ref_xml": "MCIF0.2.IF.long.de.ref.xml", "src_text_source": "LONG_TEXTS"}}}
{"dataset_id": "mcif_v0.2", "dataset_type": "unseen", "sample_id": 10, "src_audio": "/Users/ahrii/Documents/workspace/Research/MTM/SLT/MCIF_V0.2/LONG_AUDIOS/eXmqPhcZFN.wav", "src_ref": "Hi, I'm Shangbin, PhD student in the University of Washington. Today I'm presenting our work \"From Pretraining Data to Language Models to Downstream Tasks: Tracking the Trails of Political Biases Leading to Unfair NLP Models\". So language models are trained on large scale web crawl data. Political news media are well covered in their pretraining data. According to a survey of the C4 Corpus, we can see that New York Times, Los Angeles Times, The Guardian, Huffington Post, etcetera are well covered in language model training data. This has created a mixed blessing for language model applications. So on one hand, they were able to learn from diverse perspectives, which celebrates democracy and the plurality of ideas. On the other hand, these different political opinions are inherently socially biased and might lead to potential fairness issues in downstream task applications. To this end, we propose to investigate the political bias propagation pipeline from pretraining data to language models to downstream tasks, specifically by asking the following questions: First, how do we evaluate the political leaning of language models and what role does pretraining data might have on such political biases? Secondly, how do language models with different political leanings actually perform on downstream tasks and whether that might result in fairness issues in NLP applications? So specifically, we first proposed to prompt language models with different prompt formats using the political questionnaires such as the political conference test. This ensures us to do automatic evaluation well grounded in political science literature. So some preliminary results demonstrate that first, language models do have varying political leanings. They occupy all four quadrants on the political campus. We can also see that GPT-4 is the most liberal language model of them all, and GPT series are generally more socially liberal than BART series and its variants. Secondly, we aim to investigate to which extent the political biases of language models are actually picked up from training data. So we could conduct a controlled experiment by further pretraining language model checkpoints on 6 different partisan corpora separated into news and social media, further divided into their political leaning. By further pretraining language models on such partisan corpora we can see that the ideological coordinates of the language model also correspondingly shift. For example, for RoBERTa further trained on the left-leaning Reddit corpus we can see a substantial liberal shift in terms of its political biases. And we also try to investigate whether language models can pick up the polarisation that's prevalent in our modern society. So we divide pretraining corpora, into pre 45th president of the United States and after 45th president of the United States. We separately pretrain language models on the two different temporal corpora. We can see that language models generally had a political leaning that is further away from the centre after 2017. So this indicates that language models can also pick up the polarisation in our society. So last but not least, we evaluate language models with different political leanings on hate speech detection and fake news detection to NLP applications that often involve language models and could have very significant implications. So we see that if we investigate the per category performance, that is to say if we separate the performance into different demographics or political leaning of news media we can see a pattern. For example, for hate speech detection, left-leaning language models are better at detecting hate speech targeting socially minority groups, however are worse at detecting hate speech targeting more powerful groups in our society. And vice versa, right-leaning language models are better at detecting hate speech targeting white and men, however worse at detecting hate speech targeting at black LGBTQ plus and other minority communities. Similar trends also happen for fake news detection, where we see that left-leaning language models are better at detecting misinformation from their opposite political leaning and vice versa. We further show many qualitative examples to see that language models with different political leanings do give different predictions to hate speech and misinformation examples based on their social categories. There are a bunch of more examples in the appendix to further highlight that this indicates that there is a fairness issue that is very pressing regarding the political biases of language models. For example, if right-leaning language models were to be fine-tuned on hate speech or misinformation or whatever and deployed to a popular social media platform, this would mean that, people with opposite political opinions might be marginalised and hate speech targeting minority groups might just run rampant without any control. So this has sound the alarm for us to acknowledge and tackle the fairness issues resulting by language model political leanings. So a little bit of discussion. We would also like to highlight that we expose the unique dilemma regarding language model political biases. It's like between Scylla and Charybdis. So if we do not sanitize political opinions in language model training data, the bias would propagate from pretraining data to language models to downstream tasks, ultimately creating fairness issues. If we do try to sanitaze somehow, we would also risk censorship, or exclusion. And it's incredibly hard to determine what is actually neutral and should be retaining language monitoring data. So it's kind of like the electric trolley problem. Ok, great. I think that's pretty much all I have for today. Thank you for your time.", "tgt_ref": "Hallo, ich bin Shangbin, Doktorand an der University of Washington.\nHeute werde ich unsere Arbeit „From Pretraining Data to Language Models to Downstream Tasks: Tracking the Trails of Political Biases Leading to Unfair NLP Models“ vorstellen.\nEs geht um das Training von Sprachmodellen auf großen Web-Crawl-Daten.\nPolitische Nachrichtenmedien sind in den Vortrainingsdaten gut abgedeckt.\nWenn wir uns den C4-Korpus ansehen, erkennen wir, dass die New York Times, die Los Angeles Times, der Guardian, die Huffington Post und so weiter in den Trainingsdaten für Sprachmodelle gut abgedeckt sind.\nDies ist ein für Sprachmodellanwendungen nicht immer ein Segen.\nAuf der einen Seite können sie aus verschiedenen Perspektiven lernen, was gut für die Demokratie und die Pluralität der Ideen ist.\nAuf der anderen Seite sind diese unterschiedlichen politischen Meinungen inhärent sozial voreingenommen und können zu potenziellen Fairnessproblemen in nachgelagerten Aufgaben führen.\nZu diesem Zweck schlagen wir vor, den Weg der Ausbreitung politischer Voreingenommenheit von den Vortrainingsdaten über die Sprachmodelle zu den Post-Trainingsaufgaben zu untersuchen und dabei insbesondere die folgenden Fragen zu stellen: Erstens: Wie bewerten wir die politische Voreingenommenheit von Sprachmodellen und welche Rolle könnten die Daten aus dem Vortraining dabei spielen?\nZweitens: Wie schneiden Sprachmodelle mit unterschiedlicher politischer Voreingenommenheit in nachgelagerten Aufgaben tatsächlich ab und könnte dies zu Fairnessproblemen in NLP-Anwendungen führen?\nKonkret schlagen wir zunächst vor, Sprachmodelle mit unterschiedlichen Promptformaten anhand von politischen Fragebögen wie dem Political Conference Test zu testen.\nDamit stellen wir sicher, dass wir eine automatische Evaluation durchführen können, die auf politikwissenschaftlicher Literatur basiert.\nEinige vorläufige Ergebnisse zeigen, dass erstens die Sprachmodelle unterschiedliche politische Orientierungen haben.\nSie besetzen alle vier Quadranten des politischen Campus.\nWir können auch sehen, dass GPT-4 das linkeste Sprachmodell von allen ist, und dass die GPT-Serie im Allgemeinen sozial linker ist als die BART-Serie und ihre Varianten.\nZweitens wollen wir untersuchen, inwieweit sich die politischen Verzerrungen der Sprachmodelle tatsächlich in den Trainingsdaten widerspiegeln.\nZu diesem Zweck könnten wir ein kontrolliertes Experiment durchführen, indem wir die Sprachmodelle auf 6 verschiedenen parteipolitischen Korpora vortrainieren, die in Nachrichten- und soziale Medien unterteilt sind, die dann wiederum nach ihrer politischen Ausrichtung unterteilt sind.\nDurch weiteres Vortrainieren der Sprachmodelle auf diese parteiischen Korpora können wir sehen, dass sich die ideologischen Koordinaten des Sprachmodells entsprechend verschieben.\nBei RoBERTa, das auf dem linksgerichteten Reddit-Korpus trainiert wurde, können wir zum Beispiel eine deutliche Verschiebung der politischen Orientierung in Richtung links feststellen.\nUnd wir versuchen auch herauszufinden, ob Sprachmodelle die Polarisierung, die in unserer modernen Gesellschaft vorherrscht, erfassen können.\nDeshalb teilen wir die Vortrainingskorpora in „vor dem 45. Präsidenten der Vereinigten Staaten“ und nach dem 45. Präsidenten der Vereinigten Staaten“.\nWir trainieren die Sprachmodelle getrennt auf den beiden unterschiedlichen Zeitkorpora.\nWir können feststellen, dass die Sprachmodelle nach 2017 im Allgemeinen eine politische Ausrichtung haben, die weiter von der Mitte entfernt ist.\nDies deutet darauf hin, dass Sprachmodelle auch die Polarisierung in unserer Gesellschaft erfassen können.\nSchließlich evaluieren wir Sprachmodelle mit unterschiedlichen politischen Ausrichtungen für die Erkennung von Hate Speech und Fake News in NLP-Anwendungen, wo Sprachmodelle häufig verwendet werden und einen sehr großen Einfluss haben könnten.\nBetrachtet man die Leistung pro Kategorie, also wenn man die Leistung nach verschiedenen demografischen Gruppen oder politischen Ausrichtungen der Nachrichtenmedien aufschlüsselt, lässt sich ein Muster erkennen.\nWenn es beispielsweise um die Erkennung von Hate Speech geht, sind linksgerichtete Sprachmodelle besser in der Lage, Hate Speech zu erkennen, die sich gegen soziale Minderheiten richtet, aber schlechter in der Lage, Hate Speech zu erkennen, die sich gegen mächtigere Gruppen in unserer Gesellschaft richtet.\nUmgekehrt sind rechte Sprachmodelle besser in der Lage, Hate Speech zu erkennen, die sich gegen Weiße und Männer richtet, aber weniger gut in der Lage, Hate Speech zu erkennen, die sich gegen Schwarze, LGBTQ und andere Minderheitengruppen richtet.\nÄhnliche Trends lassen sich bei der Erkennung von Fake News beobachten. Hier zeigt sich, dass linke Sprachmuster besser in der Lage sind, Fehlinformationen zu erkennen, die auf die entgegengesetzte politische Richtung abzielen, und umgekehrt.\nWir stellen auch viele qualitative Beispiele vor, um zu zeigen, dass Sprachmodelle mit unterschiedlicher politischer Ausrichtung auf der Grundlage ihrer sozialen Kategorien unterschiedliche Vorhersagen für Beispiele von Hate Speech und Fehlinformationen machen.\nIm Anhang finden Sie eine Reihe weiterer Beispiele, um zu illustrieren, dass dies darauf hindeutet, dass eine sehr dringende Frage der Fairness in Bezug auf die politische Voreingenommenheit von Sprachmodellen besteht.\nWenn zum Beispiel rechtsextreme Sprachmuster für Hate Speech, Fehlinformationen oder was auch immer fein abgestimmt und auf einer beliebten Social-Media-Plattform verwendet würden, würde dies bedeuten, dass Menschen mit gegensätzlichen politischen Ansichten ausgegrenzt werden könnten und Hassreden gegen Minderheiten einfach unkontrolliert ausufern könnten.\nEs war also ein Weckruf für uns, die Gerechtigkeitsprobleme, die sich aus der politischen Ausrichtung des Sprachmodells ergeben, zu erkennen und anzugehen.\nLassen Sie uns kurz darüber sprechen.\nWir möchten auch betonen, dass wir das einzigartige Dilemma der politischen Voreingenommenheit des Sprachmodells aufdecken.\nEs ist wie Scylla und Charybdis.\nWenn wir die politischen Meinungen in den Trainingsdaten für die Sprachmodelle nicht bereinigen, wird sich die Verzerrung von den Daten vor dem Training über die Sprachmodelle bis hin zu den nachgelagerten Aufgaben ausbreiten und schließlich zu Fairnessproblemen führen.\nWenn wir versuchen, die Daten irgendwie zu bereinigen, riskieren wir auch Zensur oder den Ausschluss von Menschen.\nUnd es ist unglaublich schwierig zu bestimmen, was wirklich neutral ist und in den Sprachüberwachungsdaten erhalten bleiben sollte.\nEs ist also ein bisschen wie das elektronische Trolley-Problem.\nOkay, gut.\nIch glaube, das ist alles, was ich heute für Sie habe.\nVielen Dank für Ihre Zeit.", "src_lang": "eng", "ref_lang": "deu", "benchmark_metadata": {"subset": "long", "task": "IF", "audio_file": "eXmqPhcZFN.wav", "sources": {"ref_xml": "MCIF0.2.IF.long.de.ref.xml", "src_text_source": "LONG_TEXTS"}}}
{"dataset_id": "mcif_v0.2", "dataset_type": "unseen", "sample_id": 11, "src_audio": "/Users/ahrii/Documents/workspace/Research/MTM/SLT/MCIF_V0.2/LONG_AUDIOS/gUAIqKCjIt.wav", "src_ref": "Hi, everyone. I'm Koustav Sinha, and I'm pleased to welcome you to our talk of our ACL 2023 paper. Language model acceptability judgments are not always robust to context. This is a joint work with John Gauthier, Aaron Mueller, Kanishka Misra, Karen Fences, Roger Levy, and Adina Williams. So in this work, we revisit the minimal pair paradigms. So the minimal pair paradigm basically evaluates language models on top of acceptability judgments. Which can also include grammaticality like BLiMP, SyntaxGym, or acceptability in terms of stereotypes such as CrowS pairs. And in this, minimal pair paradigm, the typical way to evaluate language models is that you show like an acceptable sentence or a grammatical sentence and then you show an acceptable sentence or an ungrammatical sentence. And then the hope is that the model, basically, puts more probability to the acceptable sentence. The current MPP pipeline basically doesn't allow us to evaluate a model's acceptance towards longer sentences. These days large language models are coming up with longer and longer context windows. So it's crucial that we evaluate the models' acceptability throughout the context window and that is what we are trying to do here. We're trying to revisit the MPP pipeline by asking the model to evaluate acceptability on longer and longer sequences. So that is the approach. So what we do is that to simulate these longer sequences, we revisit the data sets themselves and then we recreate sentences by choosing acceptable or unacceptable sentences from those datasets. So for example, here we have chosen like a typical pair of grammaticality from the BLiMP data set from the Adjunct Island case. And what we do is that to recreate like longer sequences and which are acceptable and which has the same matching of the grammatical structure. We extract grammatical sentences from Adjunct Island and then we add it as a prefix to both the acceptable query and the unacceptable query. So we can do the same thing by choosing unacceptable sentences from the same matching, and that could also be used to test the models acceptability. And we can also do the same by choosing sentences from a different subset or a different data set. So that is what we call as the mismatch scenario. So here the sentences are still coming from a, relevant data sets but it's not from the same data set that you are evaluating with. And we can do the same for unacceptability case. Finally, we can choose sentences from a completely unrelated domain such as Wikipedia. So this will tell us like whether the models acceptability judgments are actually impacted by any context, like, whether the context is coming from a different subset of the data set, or whether it's like completely irrelevant, to the current like to the sentence that we are looking at. So how does the model do? So first, we look at the Wikipedia sentences, which are completely irrelevant to the current query pair, and there we find that the MPP judgments are mostly robust for arbitrary context length. We increase the context length toward up to 1024 for to max out OPT and GPT 2 models. And we saw here in the orange dotted line, the MPP judgments are relatively stable. Now, what happens when we choose sentences from the same data set? So here we are choosing or creating sentences from acceptable and unacceptable domains from the same BLiMP or SyntaxGym dataset. And there we see that the MPP judgments either increase or decrease significantly when you add either acceptable prefixes or unacceptable prefixes. But when we match the structure, that is when we choose the sentences from the same phenomena in BLiMP or SyntaxGym, we see a massive increase or a massive decrease of the MPP judgement for the model, depending on whether the chosen prefix is acceptable or unacceptable. Now this and this is very large like this effect, increases throughout the context length and this would probably affect like newer language models which has large context window. So why does the match prefix affect the language model judgement so much? So we did a series of analysis where we tried to perturb the input sentence by, trying to preserve the relevant structure but adding like noise to the input. And after doing like several of these perturbations, we find that none of these noises are actually making the model like change its course in terms of how it shows us the MPP judgement print. Basically, we find that the models are sensitive to the perturbed sentences in similar ways. That is, when we perturb the sentences in the acceptable domain, we see similar increase in all the perturbations and when we perturb the sentences in the unacceptable domain, we see decrease in MPP judgments in similar fashion. So, the key takeaways of our work is that language models are sensitive to latent syntactic and semantic features which are shared across the sentences. And the MPP evaluation the way that we do it currently with short and single sentence input, may not fully capture the language models abstract knowledge throughout the context window. Please read our paper for more details of our experiments. Thank you for listening.", "tgt_ref": "Hallo zusammen.\nMein Name ist Koustav Sinha und ich freue mich, Sie zu unserer Präsentation unserer Arbeit für die ACL 2023 begrüßen zu dürfen.\nDie Bewertung der Akzeptanz von Sprachmodellen ist nicht immer kontextabhängig.\nDies ist eine gemeinsame Arbeit mit John Gauthier, Aaron Mueller, Kanishka Misra, Karen Fences, Roger Levy und Adina Williams.\nIn dieser Arbeit greifen wir auf das Minimal-Pair-Paradigma zurück.\nDas Minimal-Pair-Paradigma bewertet Sprachmodelle im Wesentlichen auf der Basis von Akzeptanzurteilen.\nDies kann Grammatikalität wie BLiMP, SyntaxGym oder die Akzeptanz von Stereotypen wie CrowS-Paare betreffen.\nUnd in diesem Paradigma der minimalen Paare besteht die typische Art und Weise, Sprachmodelle zu evaluieren, darin, einen akzeptablen Satz oder einen grammatikalischen Satz und dann einen akzeptablen Satz oder einen nicht grammatikalischen Satz zu zeigen.\nDann hofft man, dass das Modell dem akzeptablen Satz eine höhere Wahrscheinlichkeit einräumt.\nDie aktuelle MPP-Pipeline erlaubt es uns im Grunde nicht, die Akzeptanz eines Modells für längere Sätze zu bewerten.\nHeutzutage haben große Sprachmodelle immer längere Kontextfenster.\nDaher ist es wichtig, die Akzeptanz der Modelle über das gesamte Kontextfenster zu bewerten, und genau das versuchen wir hier.\nWir versuchen, die MPP-Pipeline zu überdenken, indem wir das Modell auffordern, die Akzeptanz in immer längeren Sequenzen zu bewerten.\nDas ist also der Ansatz.\nUm diese längeren Sequenzen zu simulieren, verwenden wir die Datensätze selbst und erstellen dann Sätze, indem wir akzeptable oder inakzeptable Sätze aus diesen Datensätzen auswählen.\nHier haben wir zum Beispiel ein typisches Grammatikalitätspaar aus dem BLiMP-Datensatz für den Fall Adjunct Island ausgewählt.\nUnd wir reproduzieren längere Sequenzen, die akzeptabel sind und die gleiche grammatikalische Struktur aufweisen.\nWir extrahieren grammatikalische Sätze aus Adjunct Island und fügen sie als Präfix sowohl der akzeptablen als auch der inakzeptablen Abfrage hinzu.\nWir können dasselbe tun, indem wir inakzeptable Sätze aus der gleichen Konkordanz auswählen, und dies könnte auch verwendet werden, um die Akzeptanz der Modelle zu testen.\nUnd wir können dasselbe tun, indem wir Sätze aus einer anderen Teilmenge oder einem anderen Datensatz auswählen.\nDies wird als Mismatch-Szenario bezeichnet.\nIn diesem Fall stammen die Datensätze immer noch aus einem relevanten Datensatz, aber es ist nicht derselbe Datensatz, mit dem die Auswertung durchgeführt wird.\nDasselbe können wir für den Fall der Nichtakzeptanz tun.\nSchließlich können wir auch Sätze aus einer völlig fremden Domain wie Wikipedia auswählen.\nAuf diese Weise können wir feststellen, ob die Akzeptanzurteile des Modells tatsächlich von einem Kontext beeinflusst werden, das heißt ob der Kontext aus einer anderen Teilmenge des Datensatzes stammt oder ob er für den aktuell betrachteten Satz völlig irrelevant ist.\nWie funktioniert das Modell?\nNun, zunächst schauen wir uns die Wikipedia-Sätze an, die für das aktuelle Abfragepaar völlig irrelevant sind, und stellen fest, dass die MPP-Urteile für beliebige Kontextlängen weitgehend robust sind.\nWir erhöhen die Kontextlänge auf bis zu 1024, um die Modelle OPT und GPT 2 voll auszunutzen.\nUnd wir haben hier an der orange gepunkteten Linie gesehen, dass die MPP-Urteile relativ stabil sind.\nWas passiert nun, wenn wir Sätze aus demselben Datensatz auswählen?\nHier wählen oder erzeugen wir Sätze aus akzeptablen und inakzeptablen Domains aus demselben BLiMP- oder SyntaxGym-Datensatz.\nUnd wir sehen, dass die MPP-Werte entweder signifikant steigen oder fallen, wenn wir entweder akzeptable oder inakzeptable Präfixe hinzufügen.\nAber wenn wir die Struktur anpassen, also wenn wir Sätze aus den gleichen Phänomenen in BLiMP oder SyntaxGym auswählen, sehen wir einen massiven Anstieg oder einen massiven Abfall der MPP-Werte für das Modell, je nachdem, ob das ausgewählte Präfix akzeptabel oder inakzeptabel ist.\nDieser Effekt ist sehr stark und nimmt mit der Länge des Kontexts zu. Dies könnte sich auf neuere Sprachmodelle auswirken, die ein großes Kontextfenster haben.\nWarum also beeinflusst das Match-Präfix die Bewertung des Sprachmodells so stark?\nWir haben eine Reihe von Analysen durchgeführt, bei denen wir versucht haben, den Eingabesatz zu stören, indem wir versucht haben, die relevante Struktur beizubehalten, aber eine Art Rauschen hinzuzufügen.\nUnd nachdem wir mehrere dieser Störungen durchgeführt hatten, stellten wir fest, dass keine dieser Störungen das Modell tatsächlich dazu veranlasste, seinen Kurs in Bezug auf die Darstellung des MPP-Bewertungsdrucks zu ändern.\nWir stellten fest, dass die Modelle ähnlich empfindlich auf die Störungen reagierten.\nWenn wir die Sätze in der akzeptablen Domain stören, sehen wir also einen ähnlichen Anstieg bei allen Störungen, und wenn wir die Sätze in der inakzeptablen Domain stören, sehen wir einen ähnlichen Rückgang bei den MPP-Urteilen.\nDas wichtigste Ergebnis unserer Arbeit ist also, dass Sprachmodelle empfindlich auf latente syntaktische und semantische Merkmale reagieren, die in allen Sätzen vorhanden sind.\nUnd die MPP-Evaluierung, wie wir sie derzeit mit kurzen, satzweisen Eingaben durchführen, erfasst möglicherweise nicht vollständig das abstrakte Wissen der Sprachmodelle im gesamten Kontextfenster.\nWeitere Details zu unseren Experimenten finden Sie in unserer Arbeit.\nVielen Dank fürs Zuhören.", "src_lang": "eng", "ref_lang": "deu", "benchmark_metadata": {"subset": "long", "task": "IF", "audio_file": "gUAIqKCjIt.wav", "sources": {"ref_xml": "MCIF0.2.IF.long.de.ref.xml", "src_text_source": "LONG_TEXTS"}}}
{"dataset_id": "mcif_v0.2", "dataset_type": "unseen", "sample_id": 12, "src_audio": "/Users/ahrii/Documents/workspace/Research/MTM/SLT/MCIF_V0.2/LONG_AUDIOS/krJSAnVcGR.wav", "src_ref": "Hello, I am Dawei, a PhD student at Saarland University in Germany. In this video, I would like to present our recent work \"Weaker Than You Think: A Critical Look at Weakly Supervised Learning.\" This is joint work with Xiaoyu Shen, Marius Mosbach, Andreas Stephan, and Dietrich Klakow. I'd like to begin with a brief introduction to weak supervision and weakly supervised learning. In weak supervision, you do not manually label the data. Instead, we label the data using weak labeling sources, such as simple heuristic rules, knowledge bases, or low-quality crowdsourcing, as illustrated in the figure on the right. When compared to human annotations, the weaker annotations are much cheaper, yet they are also noisy, meaning that a certain amount of the annotations are incorrect. If we directly train neural networks on weakly labeled data, the neural networks tend to memorize the label noise and do not generalize. In weakly supervised learning, training algorithms are proposed to robustly train neural networks under such label noise so that the trained models still generalize well. In recent works in WSL, so WSL stands for Weakly Supervised Learning, a common claim is that people say that they only train models on the weakly labeled data and achieve high performance on clean test sets. Technically, this claim is not wrong, but there's a catch, which is that people do assume that there's an additional clean validation set available for model selection. We can't stop on this problem setting, but this implies that additional manual annotations are required in weakly supervised learning. But like an elephant in the room this necessity is often overlooked. The aforementioned doubt is asked to ask three research questions. First, is clean validation data necessary for WSL or can we maybe use a noisy validation set instead? Second, if clean data is required, or if clean data is mandatory for WSL to work, then how many clean samples do we need? Finally, should we only use the clean samples for validation, or there are better ways to utilize them? We addressed these research questions in our work and our findings are as follows. First, we find that, interestingly, recent WSL methods indeed require clean validation samples to work properly. Otherwise, there is a large performance drop. As shown in this figure, if there are no clean validation samples, then the trained models cannot generalize beyond the original weak labels, meaning that the training is pointless. This indicates that WSL approaches actually require cleanly labeled data to work properly, and the annotation cost for obtaining clean validation samples should not be overlooked. Our second finding is that increasing the number of clean validation samples will help WSL approaches to achieve better performance, as shown in the figure on the left. Typically we only need 20 samples per class to attain high performance. But that's not the end of the story, because if we either way decide to access clean samples, then training on them directly will even achieve better performance. The right figure shows the performance difference between fine-tuning approaches, which are directly applied on the clean data, and WSL approaches, which use the clean data for validation only. As we can see, if we have 10 samples per class, direct fine-tuning starts to beat WSL approaches. Finally, the performance improvement claimed in previous WSL approaches can be easily achieved by allowing to continue fine-tuning on the clean validation samples. As we can see from the figures, the vanilla model, termed FTw, initially underperforms more complicated WSL methods, like COSINE. However, if we allow to continue fine-tuning on the clean samples, then FTw performs equally well as other methods. So in practice, there's no reason to choose more complex WSL methods which require more computation time and disk space. To summarize, we showed that recent WSL approaches require clean, manually annotated samples for them to work properly. Their performance gain and practicality are heavily overestimated. Our concrete recommendations for future work are as follows. First, report the model selection criteria. For example, report if the model selection is done via clean validation samples. Second, WSL approaches should be compared with few-shot learning baselines, as both work on clean samples. Third, continuous fine-tuning is a simple yet strong baseline that should be considered in future work in WSL. Finally, we have open-sourced our code. You can find it via the QR code on this slide. Please feel free to check it out. Thank you and enjoy the conference.", "tgt_ref": "Hallo, ich bin Dawei, Doktorand an der Universität des Saarlandes in Deutschland.\nIn diesem Video möchte ich Ihnen unsere aktuelle Arbeit „Weaker Than You Think: A Critical Look at Weakly Supervised Learning“ vorstellen.\nDies ist eine gemeinsame Arbeit mit Xiaoyu Shen, Marius Mosbach, Andreas Stephan und Dietrich Klakow.\nIch möchte mit einer kurzen Einführung in die schwache Überwachung und das schwach überwachte Lernen beginnen.\nBei der schwachen Überwachung werden die Daten nicht manuell mit Labeln versehen.\nStattdessen werden die Daten mit schwachen Annotationsquellen wie einfachen heuristischen Regeln, Wissensdatenbanken oder minderwertigem Crowdsourcing annotiert, wie in der Abbildung rechts dargestellt.\nIm Vergleich zu menschlichen Annotationen sind diese schwächeren Annotationen viel billiger, aber sie weisen auch Rauschen auf, was bedeutet, dass ein gewisser Prozentsatz der Annotationen falsch sein wird.\nWenn wir neuronale Netze direkt mit schwach annotierten Daten trainieren, erinnern sich die neuronalen Netze tendenziell an das Rauschen der Annotationen und können nicht verallgemeinern.\nDas schwach überwachte Lernen schlägt Trainingsalgorithmen vor, mit denen neuronale Netze auch in einem solchen Label-Rauschen robust trainiert werden können, sodass die trainierten Modelle noch gut verallgemeinert werden können.\nIn neueren Arbeiten auf dem Gebiet des WSL (WSL steht für: Weakly Supervised Learning) wird oft behauptet, dass man Modelle nur auf schwach markierten Daten trainieren müsse, um eine hohe Leistung auf sauberen Testdatensätzen zu erzielen.\nTechnisch gesehen ist diese Aussage nicht falsch, aber die Sache hat einen Haken: Man geht davon aus, dass ein zusätzlicher sauberer Validierungssatz für die Modellauswahl zur Verfügung steht.\nDies impliziert jedoch, dass beim schwach überwachten Lernen zusätzliche manuelle Anmerkungen erforderlich sind.\nAber wie ein Elefant im Raum wird diese Notwendigkeit oft übersehen.\nDie oben genannten Zweifel führen zu drei Forschungsfragen.\nErstens: Sind saubere Validierungsdaten für die WSL erforderlich, oder können wir stattdessen einen Validierungsdatensatz verwenden, der ein Rauschen enthält?\nZweitens: Wenn saubere Daten erforderlich sind, oder wenn saubere Daten für WSL zwingend benötigt werden, wie viele saubere Proben brauchen wir dann?\nUnd drittens: Sollen wir nur die sauberen Proben für die Validierung verwenden oder gibt es bessere Möglichkeiten?\nWir haben uns in unserer Arbeit mit diesen Forschungsfragen beschäftigt und sind zu folgenden Ergebnissen gekommen.\nErstens haben wir festgestellt, dass die neuesten WSL-Methoden tatsächlich saubere Validierungsproben benötigen, um richtig zu funktionieren.\nAndernfalls nimmt die Leistungsfähigkeit stark ab.\nWie in dieser Abbildung zu sehen ist, können die trainierten Modelle ohne saubere Validierungsmuster nicht über die ursprünglichen schwachen Labels hinaus verallgemeinern, was bedeutet, dass das Training sinnlos ist.\nDies deutet darauf hin, dass WSL-Ansätze tatsächlich sauber annotierte Daten benötigen, um richtig zu funktionieren, und dass die Annotationskosten für die Beschaffung sauberer Validierungsproben nicht vernachlässigt werden sollten.\nUnsere zweite Erkenntnis ist, dass WSL-Ansätze besser funktionieren, wenn wir die Anzahl der sauberen Validierungsproben erhöhen, wie in der Abbildung links dargestellt.\nNormalerweise brauchen wir nur 20 Beispiele pro Klasse, um eine gute Leistung zu erzielen.\nAber das ist noch nicht das Ende der Geschichte, denn wenn wir uns entscheiden, auf saubere Proben zuzugreifen, dann wird das Training direkt auf diesen Proben eine noch bessere Leistung erzielen.\nDie Abbildung rechts zeigt den Leistungsunterschied zwischen Fine-Tuning-Ansätzen, die direkt auf sauberen Daten trainieren, und WSL-Ansätzen, bei denen saubere Daten nur zur Validierung verwendet werden.\nWie man sehen kann, beginnt die direkte Feinabstimmung ab 10 Proben pro Klasse die WSL-Ansätze zu schlagen.\nSchließlich kann die geforderte Leistungssteigerung der bisherigen WSL-Ansätze leicht durch eine weitere Feinabstimmung an den eigenen Validierungsproben erreicht werden.\nWie in den Abbildungen zu sehen ist, schneidet das Vanilla-Modell FTw zunächst schlechter ab als die komplexeren WSL-Methoden wie COSINE.\nWenn wir jedoch die Feinabstimmung an den sauberen Proben fortsetzen, schneidet FTw gleich gut ab wie die anderen Methoden.\nIn der Praxis gibt es also keinen Grund, komplexere WSL-Methoden zu wählen, die mehr Rechenzeit und Speicherplatz benötigen.\nZusammenfassend haben wir gezeigt, dass neuere WSL-Ansätze saubere, manuell annotierte Stichproben benötigen, um richtig zu funktionieren.\nIhr Leistungsgewinn und ihre Praxistauglichkeit werden stark überschätzt.\nUnsere konkreten Empfehlungen für zukünftige Arbeiten lauten wie folgt.\nErstens sollten die Kriterien für die Modellauswahl spezifiziert werden.\nZum Beispiel sollte angegeben werden, ob die Modellauswahl durch eigene Validierungsstichproben erfolgt.\nZweitens sollten die WSL-Ansätze mit den Basismodellen für das Lernen mit wenigen Shots verglichen werden, da beide mit sauberen Stichproben arbeiten.\nDrittens ist das kontinuierliche Fein-Tuning eine einfache, aber wirkmächtige Grundlage, die bei zukünftigen Arbeiten an WSL berücksichtigt werden sollte.\nSchließlich haben wir unseren Code als Open Source zur Verfügung gestellt.\nSie finden ihn über den QR-Code auf dieser Folie.\nSchauen Sie doch mal rein!\nVielen Dank und viel Spaß bei der Konferenz.", "src_lang": "eng", "ref_lang": "deu", "benchmark_metadata": {"subset": "long", "task": "IF", "audio_file": "krJSAnVcGR.wav", "sources": {"ref_xml": "MCIF0.2.IF.long.de.ref.xml", "src_text_source": "LONG_TEXTS"}}}
{"dataset_id": "mcif_v0.2", "dataset_type": "unseen", "sample_id": 13, "src_audio": "/Users/ahrii/Documents/workspace/Research/MTM/SLT/MCIF_V0.2/LONG_AUDIOS/miPjvjWOvI.wav", "src_ref": "Hello everyone, my name is David Vilar, and I will be giving a short review of the paper \"Prompting PaLM for Translation: Assessing Strategies and Performance.\" This is joint work with my colleagues from Google Translate. PaLM is a 540 billion-parameter large language model presented last year in 2022. It's trained on a large collection of text, comprising 780 billion tokens. At the time of publication, it achieved state-of-the-art in hundreds of NLP tasks. In this work, we present the first systematic study of large language model prompting for machine translation. We evaluated the transition capability of such models using the best practices of the MT community. This involves using the latest test sets to avoid an overlap of the test data with the training data of the language model. And we compared to state-of-the-art systems, so the best performing system, so the WMT evaluation. We use state-of-the-art, neural MT metrics, and additionally also show expert-based human evaluation results. Finally, we provide some recommendations for prompt selection strategies. The prompting has a big influence on the performance of the LLMs for translation, as we can see in a simple experiment, where we used one-shot prompting and provided two different prompts for each sentence. The majority of sentences 516 out of 1,000. The difference observed is of more than one BLEURT points. And this can go, in extreme cases, up to 40 BLEURT points. So, it's important to select a good prompting strategy. In our experiments, we settled for a 5-shot prompting strategy where we just marked each sentence that we provide to the system, with the language it's in. So in this example here, where we perform translation from German into English, the German sentences, the source sentences, are marked with German colon and the English translations with English colon. We saw that the actual form of the prompting doesn't have a big influence in the case of several short promptings. It's crucial for zero and one-shot prompting. And when we go, as in our case, to five-shot prompting, there is nearly no difference to the actual form of the prompting. It's the examples that carry most of the weight. The summary of our experimental results is that the example quality is more important than the similarity to the source sentence. So it's important to select the examples from high-quality translations. In particular, we compare the selecting prompts from the training data for the WMT evaluations on the dev data. The dev data is much more curated, and with higher quality than the training data, that it's more noisy. And their results so a better performance when using the dev data. Nevertheless, specialized state-of-the-art systems have a substantial advantage over the PaLM translations. But, PaLM comes pretty close to a commercial system. In our case, we chose to evaluate with Google Translate. The insights that we gained from the human evaluation that we performed using the MQM framework said that the fluency of PaLM is comparable to state-of-the-art systems but the main difference comes from the accuracy. So, in particular, the most common errors are omission errors. So, it seems that PaLM chooses to produce a better-sounding translation, sometimes by dropping parts of the source sentence that are made in translation. However, the \"Style/Awkward\" category for PaLM is lower than for the state-of-the-art systems, which is an additional signal that PaLM provides really fluent output, but still with some problems of accuracy. And that's it for this really short overview. For more details, please come to the full presentation of the paper. Thank you very much.", "tgt_ref": "Hallo zusammen, mein Name ist David Vilar und ich werde einen kurzen Überblick über die Arbeit „Prompting PaLM for Translation: Evaluating Strategies and Performance“ geben.\nDies ist eine gemeinsame Arbeit mit meinen Kollegen von Google Translate.\nPaLM ist ein Large Language Model mit 540 Milliarden Parametern, das im Jahr 2022 vorgestellt wurde.\nEs wurde mit einer großen Sammlung von 780 Milliarden Token trainiert.\nZum Zeitpunkt der Veröffentlichung hatte es in hunderten von NLP-Aufgaben die beste Leistung erzielt.\nIn dieser Arbeit stellen wir die erste systematische Studie über Prompts in Large Language Models für die maschinelle Übersetzung vor.\nWir haben die Übertragbarkeit dieser Modelle auf der Grundlage der Best Practices der MT-Community bewertet.\nDazu gehört die Verwendung der neuesten Testsätze, um Überschneidungen zwischen den Testdaten und den Trainingsdaten der Sprachmodelle zu vermeiden.\nUnd wir haben sie mit Systemen verglichen, die dem neuesten Stand der Technik entsprechen, das heißt mit dem leistungsfähigsten System, der WMT-Evaluation.\nWir verwenden neuronale MT-Metriken, die dem neuesten Stand der Technik entsprechen, und zeigen zusätzlich die Ergebnisse der menschlichen Bewertung durch Experten.\nAbschließend geben wir einige Empfehlungen für Strategien zur Auswahl von Prompts ab.\nPrompting hat einen großen Einfluss auf die Übersetzungsleistung von LLMs, wie ein einfaches Experiment mit One-Shot-Prompting zeigt, bei dem für jeden Satz zwei verschiedene Prompts ausgegeben wurden.\nDie Mehrheit der Sätze waren 516 von 1.000.\nDer beobachtete Unterschied betrug mehr als einen BLEURT-Punkt.\nIm Extremfall können es bis zu 40 BLEURT-Punkte sein.\nEs ist also wichtig, eine gute Prompting-Strategie zu wählen.\nIn unseren Experimenten haben wir uns für eine 5-Shot-Prompting-Strategie entschieden, bei der wir einfach jeden Satz, den wir dem System geben, mit der Sprache markieren, in der er geschrieben ist.\nIn diesem Beispiel, in dem wir vom Deutschen ins Englische übersetzen, sind also die deutschen Sätze, die Ausgangssätze, mit einem deutschen Doppelpunkt, und die englischen Übersetzungen mit einem englischen Doppelpunkt markiert.\nWir haben gesehen, dass die Form des Prompts selbst keinen großen Einfluss hat, wenn es mehrere kurze Prompts gibt.\nBei Null- und One-Shot-Prompts ist sie entscheidend.\nUnd wenn wir, wie in unserem Fall, zu Five-Shot-Prompts übergehen, gibt es fast keinen Unterschied in der Form des Prompts selbst.\nDie Beispiele haben das größte Gewicht.\nZusammenfassend kann gesagt werden, dass die Qualität des Beispiels wichtiger ist als seine Ähnlichkeit mit dem Ausgangssatz.\nDaher ist es wichtig, Beispiele aus qualitativ hochwertigen Übersetzungen auszuwählen.\nWir vergleichen insbesondere die Auswahlprompts der Trainingsdaten für die WMT-Auswertungen mit den Dev-Daten.\nDie Dev-Daten sind sehr viel stärker kuratiert und von höherer Qualität als die Trainingsdaten, das heißt sie sind stärker mit Rauschen durchsetzt.\nDaher sind die Ergebnisse besser, wenn die Dev-Daten verwendet werden.\nDennoch haben spezialisierte State-of-the-Art-Systeme einen klaren Vorteil gegenüber PaLM-Übersetzungen.\nAber PaLM kommt einem kommerziellen System sehr nahe.\nIn unserem Fall haben wir uns für eine Bewertung mit Google Translate entschieden.\nDie Ergebnisse der menschlichen Evaluierung, die wir mithilfe des MQM-Frameworks durchgeführt haben, zeigen, dass PaLM in der Flüssigkeit mit den modernsten Systemen vergleichbar ist, der Hauptunterschied jedoch in der Genauigkeit liegt.\nInsbesondere sind die häufigsten Fehler Auslassungsfehler.\nEs scheint also, dass PaLM eine besser klingende Übersetzung erstellt, indem es manchmal Teile des Ausgangssatzes in der Übersetzung weglässt.\nAllerdings ist die Kategorie „Stil/Schwierigkeit“ für PaLM niedriger als für die modernsten Systeme, was ein weiteres Signal dafür ist, dass PaLM eine wirklich flüssige Ausgabe liefert, aber immer noch einige Probleme bei der Genauigkeit bestehen.\nUnd das war‘s für diesen wirklich kurzen Überblick.\nWeitere Details finden Sie in der vollständigen Präsentation der Arbeit.\nVielen Dank.", "src_lang": "eng", "ref_lang": "deu", "benchmark_metadata": {"subset": "long", "task": "IF", "audio_file": "miPjvjWOvI.wav", "sources": {"ref_xml": "MCIF0.2.IF.long.de.ref.xml", "src_text_source": "LONG_TEXTS"}}}
{"dataset_id": "mcif_v0.2", "dataset_type": "unseen", "sample_id": 14, "src_audio": "/Users/ahrii/Documents/workspace/Research/MTM/SLT/MCIF_V0.2/LONG_AUDIOS/rOwZgUjcwB.wav", "src_ref": "Hello everyone, my name is Jingwei Yi from the University of Science and Technology of China. It's my pleasure to give a short advertisement video of our paper. Are you copying my model? Protecting the copyright of large language models for embedding as services via backdoor watermark. Let's first introduce the background about embedding as services. Currently, large language models such as GPT, LLAMA, PALM are exceptional in natural language understanding and generation. Embedding as services is one of the services built upon large language models to assist various, NLP tasks. For example, OpenAI offers a GPT based embedding API. However, recent works have shown that the attacker may steal the model through learning from the embedding and provide similar services. Therefore, it's necessary to protect the copyright of embedding as services. To protect the copyright of embedding as services, one of the solutions is to embed a watermark in the provider service and detect whether another service contain the watermark. The watermark method need to meet the following properties. First the method should be applicable to embedding as services. Second, the watermark should not degrade the utility of the provided embeddings. Third, the watermark should be covert enough to the attacker or the attacker can remove the watermark easily. Finally, the watermark needs to be transferable to the attacker's services during the model extraction process. Existing works can be broadly classified into four categories. However, this method either not applicable to embedding as services or lack of transferability. Therefore, in this paper we propose Embedding marker, which is a backdoor based watermark method applicable to embedding as services. Then let me introduce the details of our embedding marker. Embedding marker contains two main steps. Watermark injection and copyright verification. Before these main steps, we first select a trigger set. The trigger set is a group of words in a moderate frequency interval. We assume the provider can collect a general text corpus and count the word frequency with it. In watermark injection, we first define a target embedding. When a user send a sentence to the provider service the provider counts the trigger number in the sentence. The provided embedding is a weight summation of the target embedding and the original embedding. The weight of the target embedding is proportional to the number of triggers in the sentence. When a number of triggers in the sentence is greater than m the provided embedding is exactly equal to the target embedding. Copyright verification is to detect whether a model behind another service contains the word mark. We first construct a back door and a benign data set. Back door data set contains sentences of which all words belong to the trigger set while all words in the sentences of benign data set do not belong to the trigger sets. Then the provider requests the embeddings from the stealer's service with the data set. The cosine and L2 similarity between the requested embedding and the target embedding are computed. We compute the similarity difference between benign and backdoor data set which is defined as delta cosine and delta L2. Meanwhile, we also apply KS test and use its p-value as the third metric. We conduct experiments on four data sets AG News, MIND, SST2 and Enron Spam. We assume the provider apply wiki text data set to count word frequency. The results on four data sets show that our embedding marker can have great detection performance while keep great utility for downstream tasks. We also validate the covertness of the provided embedding by visualising the embedding of sentences on four datasets via PCA. The legend of the figures means the number of triggers in each sentence. As shown in the figures, it's hard to distinguish between, the backdoor embeddings and normal embeddings. That's all. Thank you. Welcome to discuss with us.", "tgt_ref": "Hallo zusammen, mein Name ist Jingwei Yi von der University of Science and Technology of China.\nEs ist mir eine Freude, unsere Arbeit\n„Are you copying my model?\nProtecting the copyright of large language models for embedding as services via backdoor watermark“ kurz vorzustellen.\nZunächst einige Hintergrundinformationen zu Embedding-as-a-Service.\nGegenwärtig sind Large Language Models wie GPT, LLAMA und PALM außergewöhnlich gut darin, natürliche Sprache zu verstehen und zu erzeugen.\nEmbedding-as-a-Service ist einer der Dienste, die auf Large Language Models aufbauen, um verschiedene NLP-Aufgaben zu unterstützen.\nOpenAI bietet zum Beispiel eine auf GPT basierende Einbettungs-API an.\nNeuere Arbeiten haben jedoch gezeigt, dass der Angreifer das Modell stehlen kann, indem er aus der Einbettung lernt und ähnliche Dienste anbietet.\nDaher ist es notwendig, das Urheberrecht an Embedding-as-a-Service zu schützen.\nUm das Urheberrecht des Embedding-as-a-Service zu schützen, besteht eine Lösung darin, ein Wasserzeichen in den Dienst des Anbieters einzubetten und zu erkennen, ob ein anderer Dienst das Wasserzeichen enthält.\nDie Wasserzeichenmethode muss die folgenden Eigenschaften erfüllen.\nErstens sollte das Verfahren auf Embedding-as-a-Service anwendbar sein.\nZweitens sollte das Wasserzeichen die Verwendbarkeit der angebotenen Einbettungen nicht beeinträchtigen.\nDrittens sollte das Wasserzeichen für den Angreifer unauffällig sein, damit er es nicht leicht entfernen kann.\nSchließlich muss das Wasserzeichen während der Modellextraktion auf die Dienste des Angreifers übertragbar sein.\nDie bestehenden Arbeiten lassen sich grob in vier Kategorien einteilen.\nDiese Methode ist jedoch entweder nicht für die Einbettung in Dienste geeignet oder es mangelt ihr an Portabilität.\nDaher schlagen wir in diesem Papier einen Einbettungsmarker vor, eine Backdoor-basierte Wasserzeichenmethode, die für Embedding-as-a-Service geeignet ist.\nLassen Sie mich nun die Details unseres Einbettungsmarkers vorstellen.\nDer Einbettungsmarker besteht aus zwei Hauptschritten.\nDie Injektion des Wasserzeichens und die Überprüfung des Urheberrechts.\nVor diesen Hauptschritten wählen wir zunächst ein Trigger-Set aus.\nDas Trigger-Set ist eine Gruppe von Wörtern in einem moderaten Frequenzintervall.\nWir gehen davon aus, dass der Anbieter in der Lage ist, ein allgemeines Textkorpus zu sammeln und die Häufigkeit der Wörter zu zählen.\nFür die Wasserzeicheninjektion definieren wir zunächst eine Zieleinbettung.\nWenn ein Benutzer einen Satz an den Dienst des Anbieters sendet, zählt der Anbieter die Triggerzahl im Set.\nDie angebotene Einbettung ist eine gewichtete Summe der Zieleinbettung und der ursprünglichen Einbettung.\nDie Gewichtung der Zieleinbettung ist proportional zur Anzahl der Trigger im Datensatz.\nWenn die Anzahl der Trigger im Datensatz größer als m ist, entspricht die bereitgestellte Einbettung genau der Zieleinbettung.\nBei der Urheberrechtsprüfung geht es darum, festzustellen, ob ein Muster hinter einem anderen Dienst die Wortmarke enthält.\nWir erstellen zunächst einen Backdoor-Datensatz und einen Benign-Datensatz.\nDer Backdoor-Datensatz enthält Sätze, in denen alle Wörter zum Trigger-Set gehören, während alle Wörter in den Sätzen des Benign-Datensatzes nicht zum Trigger-Set gehören.\nDer Anbieter fordert dann die Einbettungen mit dem Datensatz des „stehlenden“ Dienstes an.\nDie Kosinus- und L2-Ähnlichkeit zwischen der angeforderten Einbettung und der Zieleinbettung wird berechnet.\nWir berechnen die Ähnlichkeitsdifferenz zwischen dem Benign- und dem Backdoor-Datensatz, definiert als Delta-Cosinus und Delta-L2.\nIn der Zwischenzeit wenden wir auch den KS-Test an und verwenden seinen p-Wert als dritte Metrik.\nWir führen Experimente mit vier Datensätzen durch: AG News, MIND, SST2 und Enron Spam.\nWir nehmen an, dass der Anbieter den Wiki-Text-Datensatz verwendet, um die Häufigkeit der Wörter zu zählen.\nDie Ergebnisse der vier Datensätze zeigen, dass unser Einbettungsmarker eine hohe Erkennungsleistung bei gleichzeitig hohem Nutzen für nachgelagerte Aufgaben aufweisen kann.\nWir validieren auch die Abdeckung der bereitgestellten Einbettung, indem wir die Einbettung von Sätzen auf vier Datensätzen mithilfe von PCA visualisieren.\nDie Legende der Abbildungen bezieht sich auf die Anzahl der Trigger in jedem Datensatz.\nWie man in den Abbildungen sehen kann, ist es schwierig, die Backdoor-Einbettungen von den normalen Einbettungen zu unterscheiden.\nDas war's für heute.\nVielen Dank.\nSie sind herzlich eingeladen, mit uns zu diskutieren.", "src_lang": "eng", "ref_lang": "deu", "benchmark_metadata": {"subset": "long", "task": "IF", "audio_file": "rOwZgUjcwB.wav", "sources": {"ref_xml": "MCIF0.2.IF.long.de.ref.xml", "src_text_source": "LONG_TEXTS"}}}
{"dataset_id": "mcif_v0.2", "dataset_type": "unseen", "sample_id": 15, "src_audio": "/Users/ahrii/Documents/workspace/Research/MTM/SLT/MCIF_V0.2/LONG_AUDIOS/vrydRuOXbT.wav", "src_ref": "Hello everyone, my name is Ying and my colleague Zhiyang and I will be presenting our research on MultiInstruct improving Multi-Modal Zero-Shot Learning via Instruction Tuning. So with the advances in large language models, many works started to explore new learning paradigms of reusing pre-trained language models for different downstream tasks in a parameter and data-efficient way. Recently, many studies have shown that instruction tuning enables large language models to perform on unseen tasks in a zero-shot manner by following natural instructions. However, most previous works on instruction tuning focused on improving the zero-shot performance on language only tasks, while computer vision and multi-modal tasks have been left out. Therefore, in this work we want to investigate whether instruction tuning a multi-modal pre-trained models can actually improve generalisation to unseen multi-modal tasks. Additionally, at the time of our research, we discovered a considerable discrepancy in the availability of instructional datasets between NLP and multi-modal. There exist more than 1600 language-only instruction tasks. However, there is no large-scale publicly-available multi-modal instruction task. Therefore, this motivates us to build a multi-modal instruction tuning dataset. Here we present MultiInstruct, the first multi-modal instruction tuning benchmark dataset that consists of 62 diverse multi-modal tasks covering 10 broad categories. These tasks are derived from 21 existing open-source dataset and each task is equipped with five expert written instructions. For investigating multi-modal instruction tuning on our proposed dataset, we take OFA, a unified multi-modal pre-trained model, as our base model. OFA uses a unified vocabulary for language, image tokens and the coordinates of a bounding box. Here we show some example instances from our MultiInstruct dataset, to unify the processing of various input and output data types. We follow the method from OFA and formulate all the tasks in a unified sequence-to-sequence format. In which the input text, images, instructions and bounding boxes are represented in the same token space. Ok, now I'm going to talk about multi-modal instruction tuning. So for the training dataset, we use 53 tasks from 9 groups for training and we sample 10,000 instances per task. For testing, we reserve the entire common sense reasoning group for testing, and we select additional 5 tasks from VQ and Miscellaneous groups. We use all the instances in the test split for each task. In addition, we randomly sample 20 tasks from the test split of natural instructions as an unseen task for NLP. So we use pre-trained OFA large model as a base model. During training, we mix all the instances for all the tasks. Each instance is randomly combined with one of its five instruction templates. So during test for each task, we conduct a total of 5 experiments by evaluating the model using one of the five instructions. In each experiment, we report the min and max performance and the standard deviation of the performance across all 5 experiments. If the task is a multi-model classification task, we report accuracy. If it's a multi-modal generation task, we report Rouge-L. For NLP task, we report Rouge-L as well. We also introduce an additional evaluation metric called sensitivity. So this measures the model's ability to consistently produce the same outputs for the same task regardless of the slight variation in the wording of the instruction. Here is our main result. As we can see, instruction tuning can significantly improve OFA's performance on seen multi-modal tasks. Also, transfer learning from natural instruction dataset can benefit instruction tuning. Here we can see, as the amount of task increases, the model achieves better performance and in the meantime, lower sensitivity. So we also did one experiment. We use one instruction versus 5 instruction. As we can see, using more instructions can improve the model's overall performance and reduce its sensitivity a lot. So this shows the effect of different fine-tuning strategies on the model sensitivity. As we can see by transfer learning from natural instruction datasets, the model can achieve much better sensitivity compared to the original OFA model. We also can see transfer learning from natural instruction datasets can help OFA to attain much better performance on the natural instruct dataset. So overall, we propose the first large scale multi-model instruction tuning dataset with significantly improved their short capability of OFA, and we explore different transfer learning technique and show their benefits. We design a new metric called sensitivity. So one more thing, we are collecting a much larger multi-model instruction tuning dataset with around 150 additional vision language tasks and we will release them. So this is a QR code for our data and model. Thank you.", "tgt_ref": "Hallo zusammen, mein Name ist Ying und mein Kollege Zhiyang und ich werden unsere Forschung zu MultiInstruct vorstellen, die das multimodale Zero-Shot-Lernen durch anweisungsbasierte Abstimmung verbessert.\nMit den Fortschritten bei Large Language Models haben viele Arbeiten begonnen, neue Lernparadigmen zu erforschen, um vortrainierte Sprachmodelle für verschiedene nachgelagerte Aufgaben in einer parameter- und datensparenden Weise wiederzuverwenden.\nIn jüngster Zeit haben viele Studien gezeigt, dass Large Language Models durch die Anweisungsabstimmung in der Lage sind, unbekannte Aufgaben in kürzester Zeit zu bewältigen, indem sie natürliche Anweisungen befolgen.\nDie meisten bisherigen Arbeiten zur Anweisungsabstimmung haben sich jedoch auf die Verbesserung der Zero-Shot-Leistung bei rein sprachlichen Aufgaben konzentriert und Computer Vision und multimodale Aufgaben außer Acht gelassen.\nDaher wollen wir in dieser Arbeit untersuchen, ob die Anweisungsabstimmung eines vortrainierten multimodalen Modells tatsächlich die Generalisierung auf ungesehene multimodale Aufgaben verbessern kann.\nDarüber hinaus haben wir zum Zeitpunkt unserer Forschung eine erhebliche Diskrepanz in der Verfügbarkeit von Anweisungsdatensätzen zwischen NLP und Multimodal festgestellt.\nEs gibt mehr als 1600 reine Sprachanweisungsaufgaben.\nEs gibt jedoch keine großen multimodalen Anweisungsaufgaben, die öffentlich verfügbar sind.\nDies hat uns motiviert, einen Datensatz mit multimodaler Anweisungsabstimmung zu erstellen.\nWir stellen hier MultiInstruct vor, den ersten multimodalen Benchmark-Datensatz für die Anweisungsabstimmung, der aus 62 verschiedenen multimodalen Aufgaben aus 10 verschiedenen Kategorien besteht.\nDiese Aufgaben stammen aus 21 bestehenden Open-Source-Datensätzen und jede Aufgabe ist mit fünf von Experten geschriebenen Anweisungen versehen.\nUm die multimodale Anweisungsabstimmung in unserem vorgeschlagenen Datensatz zu untersuchen, verwenden wir OFA, ein einheitliches multimodales vortrainiertes Modell, als Basismodell.\nOFA verwendet ein einheitliches Vokabular für Sprache, Bild-Token und Bounding-Box-Koordinaten.\nHier zeigen wir einige Beispielinstanzen aus unserem MultiInstruct-Datensatz, um die Verarbeitung verschiedener Eingabe- und Ausgabedatentypen zu vereinheitlichen.\nWir folgen der OFA-Methode und formulieren alle Aufgaben in einem einheitlichen Sequence-to-Sequence-Format,\nin dem Eingabetext, Bilder, Anweisungen und Bounding-Boxes im gleichen Tokenraum dargestellt werden.\nOk, jetzt werde ich über die multimodale anweisungsbasierte Abstimmung sprechen.\nFür den Trainingsdatensatz verwenden wir 53 Aufgaben aus 9 Gruppen für das Training und 10.000 Instanzen pro Aufgabe.\nFür den Test reservieren wir die gesamte Gruppe Common Sense Reasoning und wählen zusätzlich 5 Aufgaben aus den Gruppen VQ und Miscellaneous aus.\nFür jede Aufgabe werden alle Instanzen der Testgruppe verwendet.\nZusätzlich wählen wir zufällig 20 Aufgaben aus der Testgruppe Natürliche Anweisungen als ungesehene Aufgaben für NLP aus.\nWir verwenden also das vortrainierte große OFA-Modell als Basismodell.\nWährend des Trainings mischen wir alle Instanzen für alle Aufgaben.\nJede Instanz wird zufällig mit einer der fünf Anweisungsvorlagen kombiniert.\nBeim Testen führen wir insgesamt 5 Experimente für jede Aufgabe durch und evaluieren das Modell mit einer der fünf Anweisungsvorlagen.\nFür jedes Experiment geben wir die minimale und maximale Leistung sowie die Standardabweichung der Leistung über alle 5 Experimente an.\nHandelt es sich bei der Aufgabe um eine multimodale Klassifikationsaufgabe, geben wir die Genauigkeit an.\nWenn es sich um eine multimodale Generierungsaufgabe handelt, geben wir Rouge-L an. Für die NLP-Aufgabe geben wir ebenfalls Rouge-L an.\nWir führen auch eine zusätzliche Metrik ein, die Sensitivität genannt wird.\nDiese misst die Fähigkeit des Modells, konsistent die gleichen Ergebnisse für die gleiche Aufgabe zu liefern, unabhängig von kleinen Unterschieden in der Formulierung der Anweisungen.\nDies ist unser Hauptergebnis.\nWie wir sehen, kann die Anweisungsabstimmung die Leistung der OFA bei visuellen multimodalen Aufgaben deutlich verbessern.\nDie Anweisungsabstimmung kann auch vom Transferlernen aus dem Datensatz der natürlichen Anweisungen profitieren.\nHier sehen wir, dass das Modell mit zunehmender Anzahl von Aufgaben eine bessere Leistung bei gleichzeitig geringerer Sensitivität erreicht.\nDeshalb haben wir auch ein Experiment durchgeführt.\nWir verwenden eine Anweisung im Vergleich zu 5 Anweisungen.\nWie zu sehen ist, kann die Verwendung von mehr Anweisungen die Gesamtleistung des Modells verbessern und seine Sensitivität deutlich verringern.\nDies zeigt die Auswirkung verschiedener Tuning-Strategien auf die Empfindlichkeit des Modells.\nWie wir sehen können, kann das Modell durch Transferlernen aus natürlichen Anweisungsdatensätzen eine viel bessere Empfindlichkeit im Vergleich zum ursprünglichen OFA-Modell erreichen.\nWir können auch sehen, dass Transfer-Lernen aus natürlichen Anweisungsdatensätzen OFA dabei helfen kann, eine viel bessere Leistung auf dem natürlichen Anweisungsdatensatz zu erreichen.\nZusammenfassend stellen wir den ersten großen Multi-Modell-Datensatz für die Anweisungsabstimmung vor, der die kurzen Fähigkeiten von OFA signifikant verbessert, und wir untersuchen verschiedene Transfer-Learning-Techniken und zeigen deren Vorteile auf.\nWir entwickeln eine neue Metrik, die Sensitivität.\nUnd noch etwas: Wir sind gerade dabei, einen viel größeren multimodalen Anweisungsdatensatz mit etwa 150 zusätzlichen Bildverarbeitungsaufgaben zu erstellen und anschließend zu veröffentlichen.\nDas ist der QR-Code für unsere Daten und unser Modell.\nVielen Dank.", "src_lang": "eng", "ref_lang": "deu", "benchmark_metadata": {"subset": "long", "task": "IF", "audio_file": "vrydRuOXbT.wav", "sources": {"ref_xml": "MCIF0.2.IF.long.de.ref.xml", "src_text_source": "LONG_TEXTS"}}}
{"dataset_id": "mcif_v0.2", "dataset_type": "unseen", "sample_id": 16, "src_audio": "/Users/ahrii/Documents/workspace/Research/MTM/SLT/MCIF_V0.2/LONG_AUDIOS/wJAPXMIoIG.wav", "src_ref": "Hello everyone, my name is Yusen Zhang from the Penn State University. Today I'm going to present our work \"XSemPLR: Cross-Lingual Semantic Parsing in Multiple Natural Languages and Meaning Representations\". So, semantic parsing is a task to build semantic representations of user queries such as SQL and Lambda Calculus. And Cross-Lingual Semantic Parsing is the task to translate queries in multiple natural languages into multiple meaning representations. As shown in this figure, we need to translate the query in multiple natural languages using neural models to SQL, Lambda or FunQL, and etcetera. Existing cross-lingual semantic parsing models are separately proposed and evaluated on data set of limited tasks and applications. For instance, there are lots of coverage on certain natural languages. But Chinese is missing and lack of coverage on certain meaning representation. The Lambda calculus is missing, or they're only evaluated on certain neural models. For example, there's only one single model to evaluate them. So to this end we propose XSemPLR. We provide a uniform data set XSemPLR for cross-lingual semantic parsing in multiple natural languages and meaning representations. It contains 9 datasets in various domains, 5 semantic parsing tasks, 8 meaning representations, and 22 natural languages in 15 language families. And to better evaluate our benchmark, we consider the six settings for training and evaluation. The first one is Translate-Test. We use Google Translate API to translate source to the target language, then use monolingual model to train and evaluation. And for example, we train the English model on English query and during inference we translate the German query using API to English and then use the trained model to predict the SQL. And we'll also test Monolingual Model. In this setting, the source language is the same as target language, for example German to German or English to English. We also test Monolingual Few-shot setting by training monolingual models with only 10% of training data. And we test Multilingual Model which we train one multilingual model for all languages. For example, we put the German, English, Chinese queries together to train a multilingual model. And during inference we can use this model to translate German queries or Chinese queries, et cetera. And we also consider Cross-lingual Zero-shot and Few-shot transfer. We train on one source language and transfer to another language. So during training, we train it on English queries or the combination of English and German Few-shot queries to train a multilingual model to predict the SQL output. And we also find many interesting results. So, regarding analysis of monolingual models, we evaluate on two groups of models including Encoder-PTR which stands for Multilingual Pretrained Encoders with Pointer-based Decoders, such as XLM-R + PTR and mBERT + PTR. And, we also evaluate Encoder-Decoder models, which is Multilingual Pretrained Encoder-Decoder Models, such as mBART and mT5. We found that Encoder-Decoder obtains the best performance on all nine datasets. And we evaluate on mT5 and XLM-R + PTR on multilingual setting. We found that Encoder-Decoder or Encoder-PTR can be improved by training in a mixture of various languages. We found it is because most of the major natural languages can obtain performance gain, except that English performance drops in seven datasets and only gains in three datasets. I think this is known as the \"Curse of Multilinguality\". We also compare the cross-language performance gap. In this figure, the blue line is Cross-lingual Few-shot transfer. The orange line is Cross-lingual Zero-shot transfer. While the green line is the Monolingual Setting. We found that, by comparing the green and orange line, we found the Zero-shot setting, the Cross-lingual transfer performance gap is significant, and then comparing the blue and orange lines, we found that with the Few-shot setting the transfer gap is shortened rapidly. We also find some other interesting findings. For example, Encoder-Decoder outperforms previous work or achieves comparable results. Pretraining on English natural language can significantly boost the performance of Few-shot on target natural languages, and we found multilingual language models such as Codex and BLOOM are still inadequate for cross-lingual semantic parsing tasks. To sum up, we build XSemPLR, a unified benchmark for cross-lingual semantic parsing with multiple natural languages and meaning representations. We conduct a comprehensive benchmark study on three representative types of multilingual language models. And our results show many interesting findings. And et cetera. And welcome to visit our paper and code. Thanks for listening.", "tgt_ref": "Hallo zusammen, mein Name ist Yusen Zhang von der Penn State University.\nHeute werde ich unsere Arbeit „XSemPLR: Cross-Lingual Semantic Parsing in Multiple Natural Languages and Meaning Representations“ vorstellen.\nSemantisches Parsing ist die Aufgabe, semantische Repräsentationen von Benutzerabfragen wie SQL und Lambda Calculus zu erstellen.\nUnd sprachübergreifendes semantisches Parsing ist die Aufgabe, Anfragen in mehreren natürlichen Sprachen in mehrere Bedeutungsrepräsentationen zu übersetzen.\nWie in der Abbildung dargestellt, müssen wir die Abfrage in mehreren natürlichen Sprachen in SQL, Lambda oder FunQL usw. übersetzen, indem wir neuronale Modelle verwenden.\nBestehende sprachübergreifende semantische Parsingmodelle werden separat vorgeschlagen und anhand von Datensätzen für begrenzte Aufgaben und Anwendungen evaluiert.\nBeispielsweise gibt es eine große Menge an Daten für bestimmte natürliche Sprachen.\nChinesisch fehlt jedoch und auch bestimmte Bedeutungsrepräsentationen werden nicht abgedeckt.\nDer Lambda-Kalkül fehlt oder wird nur mit bestimmten neuronalen Modellen evaluiert.\nZum Beispiel gibt es nur ein Modell, um sie zu bewerten.\nDeshalb bieten wir XSemPLR an.\nWir stellen einen einheitlichen Datensatz XSemPLR für sprachübergreifendes semantisches Parsing in mehreren natürlichen Sprachen und Bedeutungsrepräsentationen zur Verfügung.\nEr enthält 9 Datensätze in verschiedenen Domains, 5 semantische Parsing-Aufgaben, 8 Bedeutungsrepräsentationen und 22 natürliche Sprachen in 15 Sprachfamilien.\nUm unsere Benchmark besser beurteilen zu können, betrachten wir sechs Einstellungen zum Training und zur Evaluierung.\nDie erste ist der Übersetzungstest.\nWir verwenden die Google-Translate-API, um die Ausgangssprache in die Zielsprache zu übersetzen, und anschließend das einsprachige Modell für das Training und die Evaluierung.\nZum Beispiel trainieren wir das englische Modell auf eine englische Anfrage und während der Inferenz übersetzen wir die deutsche Anfrage mit Hilfe der API ins Englische und verwenden dann das trainierte Modell, um die SQL vorherzusagen.\nWir testen auch das einsprachige Modell.\nIn dieser Einstellung ist die Ausgangssprache dieselbe wie die Zielsprache, zum Beispiel Deutsch zu Deutsch oder Englisch zu Englisch.\nWir testen auch die Einstellung Monolingual Few-shot, bei der wir monolinguale Modelle mit nur 10 % der Trainingsdaten trainieren.\nUnd wir testen das multilinguale Modell, bei dem wir ein multilinguales Modell für alle Sprachen trainieren.\nZum Beispiel fügen wir deutsche, englische und chinesische Anfragen zusammen, um ein mehrsprachiges Modell zu trainieren.\nUnd während der Inferenz können wir dieses Modell verwenden, um deutsche oder chinesische Anfragen zu übersetzen, und so weiter.\nWir betrachten auch den interlingualen Zero-Shot- und Little-Shot-Transfer.\nWir trainieren mit einer Ausgangssprache und übersetzen dann in eine andere Sprache.\nWährend des Trainings trainieren wir also englische Abfragen oder die Kombination von englischen und deutschen Zero-Shot-Abfragen, um ein mehrsprachiges Modell zur Vorhersage von SQL-Ausgaben zu trainieren.\nDabei erhalten wir viele interessante Ergebnisse.\nIm Hinblick auf die Analyse einsprachiger Modelle evaluieren wir zwei Gruppen von Modellen, darunter Encoder-PTR, das steht für Multilingual Pretrained Encoders with Pointer-based Decoders, wie XLM-R + PTR und mBERT + PTR.\nWir haben auch Encoder-Decoder-Modelle evaluiert, die für Multilingual Pretrained Encoder-Decoder Models stehen, wie mBART und mT5.\nWir haben festgestellt, dass Encoder-Decoder bei allen neun Datensätzen die beste Leistung erzielt.\nUnd wir evaluieren mT5 und XLM-R + PTR in einer mehrsprachigen Umgebung.\nWir haben festgestellt, dass Encoder-Decoder oder Encoder-PTR durch Training mit einer Mischung aus verschiedenen Sprachen verbessert werden können.\nWir haben herausgefunden, dass dies darauf zurückzuführen ist, dass die meisten der wichtigsten natürlichen Sprachen eine Leistungsverbesserung aufweisen, mit Ausnahme von Englisch, wo die Leistung in sieben Datensätzen abnimmt und nur in drei Datensätzen zunimmt.\nDas ist, so weit ich weiß, als „Fluch der Mehrsprachigkeit“ bekannt.\nWir vergleichen auch die Leistungsunterschiede zwischen den Sprachen.\nIn dieser Abbildung stellt die blaue Linie den interlingualen Transfer mit wenigen Shots dar.\nDie orangefarbene Linie stellt den interlingualen Zero-Shot-Transfer dar.\nDie grüne Linie ist der einsprachige Transfer.\nWenn wir die grüne und die orange Linie vergleichen, sehen wir, dass der Leistungsunterschied beim sprachübergreifenden Transfer in der Zero-Shot-Einstellung beträchtlich ist. Wenn wir dann die blaue und die orangefarbene Linie vergleichen, sehen wir, dass der Leistungsunterschied beim Transfer in der Few-Shot-Einstellung rasch abnimmt.\nWir finden auch einige andere interessante Ergebnisse.\nZum Beispiel übertrifft der Encoder-Decoder frühere Arbeiten oder erzielt vergleichbare Ergebnisse.\nEin Vortraining in englischer Sprache kann die Few-Shot-Leistung in den natürlichen Zielsprachen erheblich verbessern. Außerdem haben wir festgestellt, dass multilinguale Sprachmodelle wie Codex und BLOOM für sprachübergreifende semantische Parsing-Aufgaben noch unzureichend sind.\nZusammenfassend haben wir XSemPLR entwickelt, eine einheitliche Benchmark für sprachübergreifendes semantisches Parsing mit mehreren natürlichen Sprachen und Bedeutungsrepräsentationen.\nWir führen eine umfassende Benchmark-Studie mit drei repräsentativen Typen von mehrsprachigen Sprachmodellen durch.\nUnd unsere Ergebnisse zeigen viele interessante Resultate.\nUnd so weiter.\nGerne können Sie unserer Arbeit und unserem Code ansehen.\nVielen Dank fürs Zuhören.", "src_lang": "eng", "ref_lang": "deu", "benchmark_metadata": {"subset": "long", "task": "IF", "audio_file": "wJAPXMIoIG.wav", "sources": {"ref_xml": "MCIF0.2.IF.long.de.ref.xml", "src_text_source": "LONG_TEXTS"}}}
{"dataset_id": "mcif_v0.2", "dataset_type": "unseen", "sample_id": 17, "src_audio": "/Users/ahrii/Documents/workspace/Research/MTM/SLT/MCIF_V0.2/LONG_AUDIOS/wLmrUehthl.wav", "src_ref": "Hi, my name is Adam Przepiórkowski and this talk is about the Dependency Structure of Coordination. As you may know, there are different dependency structures assumed by different theories and corpus approaches. So for example, in the universal dependencies, the structure of the coordination, Lisa, Bart, and Maggie, such that the first conjunct is the head of the whole coordinate structure. So in this case, Lisa. A similar approach is assumed in Igor Mel'čuk's meaning text theory, where again, the whole coordinate structure is headed by the first conjuct. So these two approaches are asymmetric. Right. They single out one of the conjuncts. Now those are asymmetric approaches to coordinate structures, such as the Prague approach. The conjunction headed approach assumed in Prague dependency treebanks, where coordinate structures are headed by the conjunction. So, we get some dependencies from end to all the conjuncts. And finally, there's also a multi-headed approach that's used, for example, in the Hudson's Word Grammar, where they say all conjuncts are heads of the coordinate structure. So we get dependencies from the governor. Here loves to all conjuncts separately: Lisa, Bart, and Maggie. Now the aim of this paper is to produce a novel argument for the symmetric structures of coordination, like these two and against the asymmetric structures of coordination, like these two. OK. The argument is based on the principle of dependency length minimization that I will explain on the basis of these examples. So in English, as you might know, direct objects prefer to be close to the verb, while adjuncts may be further away. So \"Marge read it yesterday\" is fine because the direct object is close to the verb, while \"Marge read yesterday it\" is much worse. Right? Because here between the verb and the direct object is an adjunct: \"yesterday\". However, this effect may be ameliorated when the direct object is very heavy and very long. Because then it can be moved to the position after the adjunct. This is illustrated here. So both these sentences are fine. \"Marge read this absolutely fascinating book about bees yesterday.\" It's okay the way instead of \"it\", we have this long NP. But it's also OK to say, \"Marge read yesterday this absolutely fascinating book about bees.\" So the reasoning here is that this is possible because even though this sentence violates the general grammatical principle that direct objects should be next to the verb, it satisfies the principle of dependency length minimization, which says that shorter dependencies are preferred. So these two trees only show the length of the crucial dependencies, the ones that are not constant among these two structures. So here we have a dependency from \"read\" to the adjunct of length 7 measured in words and from \"read\" to \"book\" of length 4, so together it's 11. When you swap these two constituents, the sum of these two dependencies becomes 6. So instead of 11, 6 is much shorter. That's why this sounds quite okay. Right? It violates one principle, but it satisfies another one. Ok. So what we did, we extracted various statistics about coordination from the enhanced version of the Penn Treebank and see the paper \"Why wouldn't you use universal dependencies\" and these statistics confirm the observation made many times before that left conjuncts tend to be shorter. So, \"salt and pepper\" and not \"pepper and salt\", measured in syllables. And, also the observation that was made in parsing that this tendency grows with length difference. So when the difference between the lengths of the two conjuncts grows, the shorter conjunct prefers to be the first one, stronger, right? So the proportion is bigger of the left short conjunct. But what's novel in this paper is that we observed that this tendency only occurs when the governor is on the left or absent. Right? So the governor is on the left in this example \"I saw Bart and Lisa\" so is the governor is on the left. It's absent in the second example \"Homer came and sneezed.\" Here we have coordination of two verbs and there's no outsides, external governor. In such cases, the left conjunct prefers to be shorter; the most of the biggest difference between the two conjuncts. However, when the governor is on the right, as here, \"laughed\" governs the coordination Ted and Ned, this effect disappears. So we showed that by measuring length in characters, the first column, in syllables the middle column, and in words the right column. So I'll concentrate on the right one. What we see here is that when the governor is on the left, the tendency for the left conjunct to be shorter grows steadily, with the absolute difference in words, and the same is observed when there is no governor as in coordination of sentences. But when the governor is on the right this tendency disappears. And we show in the paper how this provides an argument against asymmetric structures of coordination, as these two, and for the symmetric structures, as these two. So see the paper for the full arguments. And talk to us about at the poster session. Thank you.", "tgt_ref": "Hallo, mein Name ist Adam Przepiórkowski und in diesem Vortrag geht es um die Abhängigkeitsstruktur der Koordination.\nWie Sie vielleicht wissen, gibt es verschiedene Abhängigkeitsstrukturen, die von verschiedenen Theorien und Korpusansätzen angenommen werden.\nZum Beispiel ist bei universellen Abhängigkeiten die Struktur der Koordination, Lisa, Bart und Maggie, so, dass der erste Konjunktor der Kopf der gesamten Koordinationsstruktur ist.\nIn diesem Fall ist dies Lisa.\nEin ähnlicher Ansatz wird in der semantischen Texttheorie von Igor Mel'čuk verfolgt, wo ebenfalls die gesamte Koordinatenstruktur von der ersten Konjunktion angeführt wird.\nBeide Ansätze sind also asymmetrisch.\nGenau.\nSie heben nur eine der Konjunktionen hervor.\nEs handelt sich also um asymmetrische Ansätze für Koordinatenstrukturen, wie der Prager Ansatz.\nDer Prager Ansatz geht davon aus, dass in den Prager Abhängigkeitsbäumen die Koordinatenstrukturen von der Konjunktion angeführt werden.\nWir erhalten also einige Abhängigkeiten vom Ende zu allen Konjunktionen.\nSchließlich gibt es noch einen Ansatz mit mehreren Köpfen, der zum Beispiel in der Hudson's Word Grammar verwendet wird, in der angenommen wird, dass alle Konjunktionen Köpfe der Koordinatenstruktur sind.\nSo erhalten wir Abhängigkeiten vom Hauptwort.\nHier haben wir alle Konjunktionen einzeln: Lisa, Bart und Maggie.\nDas Ziel dieses Artikels ist es, ein neues Argument für symmetrische Koordinationsstrukturen wie diese beiden gegenüber asymmetrischen Koordinationsstrukturen wie diesen beiden anzubieten.\nOK.\nDas Argument basiert auf dem Prinzip der Minimierung der Abhängigkeitslänge, das ich anhand dieser Beispiele erläutern werde.\nWie Sie vielleicht wissen, stehen direkte Objekte im Englischen bevorzugt in der Nähe des Verbs, während Adjunkte weiter entfernt stehen können.\nSo ist „Marge read it yesterday“ gut, weil das direkte Objekt nahe am Verb steht, während „Marge read yesterday it“ viel schlechter ist.\nNicht wahr?\nWeil zwischen dem Verb und dem direkten Objekt ein Adjektiv steht: „yesterday“.\nDieser Effekt kann jedoch verbessert werden, wenn das direkte Objekt sehr schwer und sehr lang ist.\nDann kann es nach dem Adjektiv stehen.\nDies wird hier veranschaulicht.\nDiese beiden Sätze sind also in Ordnung.\n„Marge read this absolutely fascinating book about bees yesterday.“\nDas ist in Ordnung, weil wir anstelle von „it“ diese lange NP haben.\nAber es ist auch in Ordnung zu sagen: „Marge read yesterday this absolutely fascinating book about bees“.\nDie Argumentation hier ist also, dass dies möglich ist, denn obwohl dieser Satz gegen das allgemeine grammatikalische Prinzip verstößt, dass direkte Objekte neben dem Verb stehen sollten, erfüllt er das Prinzip der Minimierung der Länge von Abhängigkeiten, das besagt, dass kürzere Abhängigkeiten bevorzugt werden.\nDiese beiden Bäume zeigen also nur die Länge der entscheidenden Abhängigkeiten an, das heißt der Abhängigkeiten, die zwischen diesen beiden Strukturen nicht konstant sind.\nHier haben wir also eine Abhängigkeit von „read“ zum Adjektiv mit einer Länge von 7 Wörtern und von „read“ zu „book“ mit einer Länge von 4 Wörtern, zusammen also 11.\nWenn man diese beiden Komponenten vertauscht, ist die Summe dieser beiden Abhängigkeiten 6.\nAnstelle von 11 ist 6 also viel kürzer.\nDeshalb klingt es relativ OK.\nNicht wahr?\nEs verletzt ein Prinzip, aber es erfüllt ein anderes.\nOk.\nWir haben also verschiedene Statistiken über die Koordination aus der erweiterten Version der Penn Treebank extrahiert, siehe auch die Arbeit „Why wouldn't you use universal dependencies“. Diese Statistiken bestätigen die schon oft gemachte Beobachtung, dass linke Konjunktionen tendenziell kürzer sind.\nAlso „Salz und Pfeffer“ und nicht „Pfeffer und Salz“, gemessen in Silben.\nUnd auch die beim Parsen gemachte Beobachtung, dass sich diese Tendenz mit zunehmendem Längenunterschied verstärkt.\nJe größer also der Längenunterschied zwischen den beiden Konjunktionen ist, desto eher kommt die kürzere Konjunktion zuerst, oder?\nDer Anteil der linken, kürzeren Konjunktion ist also größer.\nDas Neue an dieser Studie ist aber, dass wir festgestellt haben, dass diese Tendenz nur dann auftritt, wenn das Hauptwort auf der linken Seite steht oder fehlt.\nNicht wahr?\nIn diesem Beispiel, „Ich sah Bart und Lisa“, steht das Hauptwort auf der linken Seite.\nIm zweiten Beispiel, „Homer kam und nieste“ fehlt es.\nHier handelt es sich um die Koordination zweier Verben, und es gibt kein externes Hauptwort.\nIn solchen Fällen ist die linke Konjunktion eher kürzer, was den Hauptunterschied zwischen den beiden Konjunktionen ausmacht.\nBefindet sich das Hauptwort jedoch auf der rechten Seite, wie hier, wo „lachen“ die Koordination von Ted und Ned bestimmt, verschwindet dieser Effekt.\nWir haben dies also gezeigt, indem wir die Länge in Buchstaben in der ersten Spalte, in Silben in der mittleren Spalte und in Wörtern in der rechten Spalte gemessen haben.\nIch werde mich also auf die rechte Spalte konzentrieren.\nWir sehen, dass die Tendenz, dass die linke Konjunktion kürzer ist, wenn das Hauptwort auf der linken Seite steht, mit der absoluten Differenz der Wörter zunimmt, und dass dasselbe beobachtet wird, wenn es kein Hauptwort gibt, wie bei der Koordination von Sätzen.\nAber wenn das Hauptwort auf der rechten Seite steht, verschwindet diese Tendenz.\nUnd wir zeigen in der Arbeit, inwiefern dies ein Argument gegen asymmetrische Koordinationsstrukturen wie diese beiden und für symmetrische Strukturen wie diese beiden ist.\nDie vollständigen Argumente finden Sie in der Arbeit.\nUnd sprechen Sie gerne mit uns bei der Postersession darüber.\nVielen Dank.", "src_lang": "eng", "ref_lang": "deu", "benchmark_metadata": {"subset": "long", "task": "IF", "audio_file": "wLmrUehthl.wav", "sources": {"ref_xml": "MCIF0.2.IF.long.de.ref.xml", "src_text_source": "LONG_TEXTS"}}}
{"dataset_id": "mcif_v0.2", "dataset_type": "unseen", "sample_id": 18, "src_audio": "/Users/ahrii/Documents/workspace/Research/MTM/SLT/MCIF_V0.2/LONG_AUDIOS/xUDLtuhJUS.wav", "src_ref": "Hello, my name is Kayo Yin and I will be presenting our work titled \"When Does Translation Require Context? A Data-driven, Multilingual Exploration\". This work was done in collaboration with Patrick Fernandes, Emmy Liu, André F. T. Martins, and Graham Neubig. So a lot of translations depend on context. For example, how would we translate \"mole\" in this sentence? Well, if the previous sentence was \"Things could start to get dangerous if the ministers find out\", then \"mole\" refers to a spy. But if the previous sentence was \"Could it be anything serious, doctor?\", then \"mole\" refers to a birthmark. So, depending on context, the meaning of the word changes, and therefore its translation changes as well. However, evaluating how well models can translate cases like this is pretty hard. Firstly because only a small portion of translations depend on context which makes corpus-level metrics like BLEU unable to capture these translations. And some people have suggested targeted evaluation on context-dependent translations, but these resources only support limited types of context-dependent translations and limited sets of languages since they usually rely on domain knowledge and human curation. In this work, we try to answer these two questions. First, when does translation require context? And second, how well do models handle these cases? To answer the first question, we started by measuring how much a word depends on context during translation. In the previous work, we introduced CXMI as a measure for context usage by machine translation models. And this is done by measuring how much information the context C provides about the target Y, given the source X. You can think of CXMI as the information gained from giving context to the model. In this work, we extend CXMI to Pointwise CXMI which can measure context usage at the sentence level or at the word level. We can think of words that have high P-CXMI as ones that require context for translation. Now we analyze words with high P-CXMI to look for patterns between these words. And we perform our analysis on transcripts of TED talks that have been translated from English to 14 different languages. We perform our analysis at three different levels. First, we look at part-of-speech tags that have high mean P-CXMI. And this allows us to find, for example, dual pronouns in Arabic that have relatively high P-CXMI. And this can be explained because English doesn't have dual pronouns, so you need context to determine if a pronoun is dual when translating into Arabic. And similarly, we find that certain languages also require context when we want to choose the appropriate verb form. We then look at vocabulary items that have high P-CXMI averaged over all of its different occurrences. And this helps us identify cases like the one here, where in Chinese you need context to translate proper nouns to make sure that you're using the same translation within the document. And similarly, we find that context is important to translate in the right formality. And finally, we look at different individual tokens that have high P-CXMI. And this allows us to identify phenomena that cannot really be captured by the word itself, but that's rather expressed in the sentence structure, such as ellipses resolution. So now we use our findings from our analysis to design a benchmark for document-level translation. For each of the five discourse phenomena we identified, we create taggers to automatically identify words that pertain to the phenomenon. And we called our tagger the Multilingual Discourse-Aware, or MuDA tagger. We can then also note that different languages have different proportions of these discourse phenomena. We then use the MuDA tagger, by applying the tagger on a parallel corpus that we want to use for evaluation and we apply our translation metrics of choice on the context-dependent examples that the MuDA tagger has identified. And finally, we use our benchmark as well as other metrics to evaluate different models on the document-level machine translation. First of all, when we use corpus-level metrics: so for BLEU, we find that context-agnostic models have the best performance. But then if we use COMET, context-aware models perform best. And if we use word f-measure, then models with and without context have comparable performance. This again demonstrates that it is difficult to determine the best document-level translation system if we use corpus-level metrics alone. Now, we use the MuDA benchmark to evaluate models and we find that context-aware models are significantly more accurate than models that do not use context for certain discourse phenomena such as formality and lexical cohesion. But these models are not much better than models that do not use context on other phenomena like ellipsis, pronouns, and verb form. So this sort of suggests where we would need to see more progress for document-level translation. We also compared different commercial systems and our benchmark shows that DeepL is usually more accurate than Google Translate for document-level translation. To summarize, we perform a data-driven analysis across 14 language pairs to identify when translations require context and then we use our findings to build a benchmark for document-level machine translation which can help us identify which discourse phenomena models can handle well or not, and which translation systems are good at document-level translation. Thank you so much for your attention. See you in Toronto.", "tgt_ref": "Hallo, mein Name ist Kayo Yin und ich werde unsere Arbeit mit dem Titel „When Does Translation Require Context?\nA Data-Based Multilingual Investigation“ vorstellen.\nDiese Arbeit wurde in Zusammenarbeit mit Patrick Fernandes, Emmy Liu, André F. T. Martins und Graham Neubig verfasst.\nEin großer Teil der Übersetzung hängt vom Kontext ab.\nWie würden wir zum Beispiel „mole“ in diesem Satz übersetzen?\nNun, wenn der vorherige Satz lautete: „Es könnte gefährlich werden, wenn die Minister das herausfinden“, dann bezieht sich „mole“ auf einen Spion.\nLautete der vorherige Satz aber „Könnte es etwas Ernstes sein, Doktor?“, dann bezieht sich „mole“ auf ein Muttermal.\nJe nach Kontext ändert sich also die Bedeutung des Wortes und damit auch seine Übersetzung.\nEs ist jedoch schwierig zu beurteilen, wie gut Modelle solche Fälle übersetzen können.\nErstens ist nur ein kleiner Teil der Übersetzungen kontextabhängig, sodass Metriken auf Korpusebene wie BLEU diese Übersetzungen nicht erfassen können.\nZweitens wurde eine gezielte Bewertung von kontextabhängigen Übersetzungen vorgeschlagen, aber diese Ressourcen unterstützen nur begrenzte Arten von kontextabhängigen Übersetzungen und begrenzte Sätze von Sprachen, da sie in der Regel auf Domain-Wissen und menschlicher Kuratierung basieren.\nIn dieser Arbeit versuchen wir, diese beiden Fragen zu beantworten.\nErstens, wann wird Kontext für die Übersetzung benötigt?\nUnd zweitens: Wie gut können die Modelle mit diesen Fällen umgehen?\nUm die erste Frage zu beantworten, haben wir zunächst gemessen, wie stark ein Wort während der Übersetzung vom Kontext abhängt.\nIn der vorangegangenen Arbeit haben wir CXMI als Maß für die Verwendung von Kontext durch maschinelle Übersetzungsmodelle eingeführt.\nEs misst, wie viele Informationen der Kontext C über das Ziel Y liefert, wenn man die Quelle X betrachtet. CXMI kann als die Information aufgefasst werden, die durch die Bereitstellung von Kontext für das Modell gewonnen wird.\nIn dieser Arbeit erweitern wir CXMI zu Pointwise CXMI, das die Kontextnutzung auf Satz- oder Wortebene messen kann.\nWir können uns Wörter mit hohem P-CXMI als Wörter vorstellen, die Kontext für die Übersetzung benötigen.\nNun analysieren wir Wörter mit hohem P-CXMI, um nach Mustern zwischen diesen Wörtern zu suchen.\nUnd wir führen unsere Analyse an Transkripten von TED-Talks durch, die aus dem Englischen in 14 verschiedene Sprachen übersetzt wurden.\nDie Analyse erfolgt auf drei verschiedenen Ebenen.\nZunächst betrachten wir die Part-of-Speech-Tags, die einen hohen durchschnittlichen P-CXMI aufweisen.\nAuf diese Weise können wir beispielsweise Dualpronomen im Arabischen finden, die einen relativ hohen P-CXMI aufweisen.\nDies liegt daran, dass es im Englischen keine Dualpronomen gibt, sodass man den Kontext braucht, um zu bestimmen, ob ein Pronomen dual ist, wenn es ins Arabische übersetzt wird.\nÄhnlich verhält es sich mit einigen Sprachen, bei denen wir ebenfalls den Kontext benötigen, um die richtige Verbform zu wählen.\nDann schauen wir uns die Vokabeln an, die einen hohen P-CXMI-Wert haben, gemittelt über alle ihre verschiedenen Auftritte.\nUnd das hilft uns, Fälle wie diesen zu identifizieren, bei denen man im Chinesischen bei der Übersetzung von Eigennamen den Kontext braucht, um sicherzustellen, dass man im Dokument die gleiche Übersetzung verwendet.\nUnd wir stellen fest, dass der Kontext auch wichtig ist, wenn es darum geht, in der richtigen Form zu übersetzen.\nSchließlich untersuchen wir verschiedene einzelne Token, die einen hohen P-CXMI aufweisen.\nAuf diese Weise können wir Phänomene identifizieren, die nicht wirklich durch das Wort selbst erfasst werden können, sondern sich eher in der Satzstruktur ausdrücken, wie zum Beispiel die Auflösung von Ellipsen.\nWir verwenden nun die Ergebnisse unserer Analyse, um einen Benchmark für die Übersetzung auf Dokumentebene zu entwickeln.\nFür jedes der fünf Diskursphänomene, die wir identifiziert haben, haben wir Tagger erstellt, die automatisch Wörter identifizieren, die zu diesem Phänomen gehören.\nWir haben unseren Tagger Multilingual Discourse-Aware oder MuDA-Tagger genannt.\nWir können dann auch sehen, dass die verschiedenen Sprachen unterschiedliche Anteile dieser Diskursphänomene aufweisen.\nAnschließend wenden wir den MuDA-Tagger auf ein Parallelkorpus an, das wir für die Evaluierung verwenden wollen. Dann wenden wir die von uns ausgewählten Übersetzungsmetriken auf die kontextabhängigen Beispiele an, die der MuDA-Tagger identifiziert hat.\nSchließlich verwenden wir unseren Benchmark und andere Metriken, um verschiedene maschinelle Übersetzungsmodelle auf Dokumentenebene zu evaluieren.\nZuerst, wenn wir Metriken auf Korpusebene verwenden, wie bei BLEU, sehen wir, dass kontextunabhängige Modelle am besten abschneiden.\nAber wenn wir dann COMET verwenden, schneiden die kontextabhängigen Modelle am besten ab.\nUnd wenn wir f-measure verwenden, dann haben kontextabhängige und kontextunabhängige Modelle eine vergleichbare Leistung.\nDies zeigt erneut, dass es schwierig ist, das beste Übersetzungssystem auf Dokumentebene zu bestimmen, wenn wir nur Metriken auf Korpusebene verwenden.\nWir verwenden nun den MuDA-Benchmark, um die Modelle zu evaluieren, und stellen fest, dass die kontextbewussten Modelle für bestimmte Diskursphänomene wie Formalität und lexikalische Kohäsion deutlich genauer sind als Modelle, bei denen der Kontext nicht einfließt.\nBei anderen Phänomenen wie Ellipsen, Pronomen und Verbformen sind diese Modelle jedoch nicht viel besser als Modelle, bei denen der Kontext einfließt.\nDies deutet darauf hin, dass bei der Übersetzung auf Dokumentebene noch weitere Fortschritte erzielt werden müssen.\nWir haben auch verschiedene kommerzielle Systeme verglichen und unser Benchmark zeigt, dass DeepL bei der Übersetzung auf Dokumentenebene in der Regel genauer ist als Google Translate.\nZusammenfassend lässt sich sagen, dass wir eine datenbasierte Analyse für 14 Sprachpaare durchführen, um festzustellen, wann Übersetzungen Kontext benötigen. Anschließend verwenden wir unsere Ergebnisse, um eine Benchmark für die maschinelle Übersetzung auf Dokumentebene zu erstellen, mit deren Hilfe wir feststellen können, mit welchen Diskursphänomenen die Modelle gut oder schlecht umgehen können und welche Übersetzungssysteme gut für die Übersetzung auf Dokumentebene geeignet sind.\nVielen Dank für Ihre Aufmerksamkeit.\nWir sehen uns in Toronto.", "src_lang": "eng", "ref_lang": "deu", "benchmark_metadata": {"subset": "long", "task": "IF", "audio_file": "xUDLtuhJUS.wav", "sources": {"ref_xml": "MCIF0.2.IF.long.de.ref.xml", "src_text_source": "LONG_TEXTS"}}}
{"dataset_id": "mcif_v0.2", "dataset_type": "unseen", "sample_id": 19, "src_audio": "/Users/ahrii/Documents/workspace/Research/MTM/SLT/MCIF_V0.2/LONG_AUDIOS/xiSxNRoOzm.wav", "src_ref": "Hi everyone. I'm Jenny, a first year PhD student at Carnegie Mellon University and today I'll be presenting your work NLPositionality characterising design biases of datasets and Models. This work was done in collaboration with some folks at the University of Washington and the Allen Institute for AI, namely Sebastian Santy, Ronan Le Bras, Katharina Reinecke and Maarten Sap. So let's start off by imagining that you're working for a newspaper and you're sifting through comments under your news article trying to remove toxic content. You might turn towards a popular API like Prospective API for toxicity detection, and this works really well if you're Carl Jones. Where prospective API is able to detect correctly toxic instances. But that's not really the case for Aditya Sharma. Where prospective AP is really not as sensitive to offensive terms that are more common in Indian contexts. This is an example of a design bias where we see systematic performance differences of technology between populations. Design biases like the one that we just saw before might occur due to the positionality of the NLP researchers and model developers. Positionality is simply the perspectives that people hold as a result of their demographics, identity, and life experiences. This is a concept widely used in critical studies, specifically in feminist and queer academic spaces. And as a researcher, positionality can influence the research process and its outcomes and results because it can change the decisions that researchers make. And so one question that people might ask is, do datasets and models have positionality? And we're not trying to say that models themselves in data sets themselves have demographic identities and life experiences, but they do aggregate judgments and opinions of real people, and can thus represent certain positionalities over others. So prior work has suggested some anecdotal evidence of having positionality, such as cultural gaps and models and data sets, as well as theoretical definitions of model positionality. However these works really don't look at comparing end users with the datasets and models themselves, and studying model and data set positionality is increasingly important as NLP tasks become more subjective and socially oriented, and it's challenging to characterise how these positionalities are skewed because not all decisions are documented and many models are hidden behind APIs. So to study data set and model positionality, we actually compare the annotations with real users with existing datasets and models. We do this through our framework NLPositionality. Our framework works in two main steps. The first step is to re annotate data sets with diverse annotators. And we ought to do this over looking at the demographics of original data sets annotators, because, usually only a few annotators annotate each instance and because demographics are rarely collected and shared. And so we opt to re annotate data to get many annotates for instance and to get a rich set of demographic data. We then take the annotations by demographic and compare them to the models and datasets using a Pearson's R correlation score, and thus our framework actually differs from annotator disagreement literature by comparing end users with models and datasets, predictions and labels, as opposed to looking at just annotator agreement or modelling annotator distributions. Our frame is largely enabled through Lab in the Wild and online crowdsourcing platform for where HCI collaborator. In Live in the Wild is an online experimentation platform where we can recruit divers volunteers. Compared to the platforms like M Turk which largely have participants from the US or India and further Lab in the Wild still is able to get high quality data. We host 2 tasks on lab in the wild, one of them being social acceptability, and the way this works is that participants will read a situation from the social chemistry dataset and, then they'll write how socially acceptable a situation is. Afterwards to stay engaged in the study, they can compare their responses to an AI and others. We've then compared these, annotations with Social Chemistry, Delphi and GPT 4. We then replicate a very similar setup for the toxicity and hate speech detection task, where they'll read an instance from Dynahate and write whether they think it's instance of hate speech. We then compared these annotations with Dynahate, Perspective API, Rewire API, Hate Roberta and GPT 4. Our study in the end amassed over 16,000 annotations from over 1000 annotators from 87 countries. So now we're better equipped to answer who do NLP datasets and models align with the most. We find that there is positionality in NLP. For example, we find that data sets and models are most aligned to English speaking countries. So for the GPT 4 social acceptability analysis, we find that it's most aligned to confucian and English speaking countries. We find that Dynahate is also most aligned to English speaking countries. We also find most additional alignment with people who have a college education. So for GPT 4, in the social acceptability task, we find that it's most aligned to people with a college education or Graduate School education and we find the same for Dynahate where it's most aligned to people with a college education. However, when models and data sets are aligned to specific populations, some are inevitably left behind. An example of this is that datasets and models are less aligned to non binary people compared to the men and women counterparts. We find this in the GPT 4 social acceptability task as well as the Dynahate task analysis as well. So, given that there is positionality in NLP, what can we do about it? So we have a few recommendations for this. First one is keep a record of all relevant design choices throughout the research process. And the other is to do NLP research with the lens of perspectivism. Our third recommendation is to build specialised datasets and models within 4 specific communities. And a good example of this is the Masakhani initiative. I mean, we want to emphasise that inclusive NLP isn't just making. You know, all technologies work for everyone. And so that concludes our presentation. But if you'd like to learn more, feel free to check out our dashboard for the most updated analysis results and our paper. Thank you.", "tgt_ref": "Hallo zusammen.\nMein Name ist Jenny, ich bin Doktorandin im ersten Jahr an der Carnegie Mellon University und ich werde heute meine Arbeit „LPositionality characterising design biases of datasets and Models“ vorstellen.\nDiese Arbeit wurde in Zusammenarbeit mit Kollegen von der University of Washington und dem Allen Institute for AI durchgeführt, nämlich Sebastian Santy, Ronan Le Bras, Katharina Reinecke und Maarten Sap.\nStellen Sie sich vor, Sie arbeiten für eine Zeitung und durchsuchen die Kommentare unter Ihren Nachrichtenartikeln, um schädliche Inhalte zu entfernen.\nSie könnten sich an eine beliebte API wie Prospective API wenden, um toxische Inhalte zu erkennen, und das funktioniert wirklich gut, wenn Sie Carl Jones sind.\nProspective API ist in der Lage, toxische Instanzen korrekt zu erkennen.\nAber das ist nicht wirklich der Fall für Aditya Sharma.\nHier ist Prospective API nicht so empfindlich gegenüber anstößigen Begriffen, die in indischen Kontexten häufiger vorkommen.\nDies ist ein Beispiel für eine Designverzerrung, bei der wir systematische Unterschiede in der Leistung der Technologie zwischen Bevölkerungsgruppen feststellen.\nDesignverzerrungen, wie wir sie gerade gesehen haben, können aufgrund der Positionalität von NLP-Forschern und Modellentwicklern auftreten.\nPositionalität ist einfach die Perspektive, die Menschen aufgrund ihrer demographischen Zugehörigkeit, Identität und Lebenserfahrung haben.\nDieses Konzept wird häufig in Critical Studies verwendet, insbesondere in feministischen und queeren akademischen Kreisen.\nAls Forschende kann Positionalität den Forschungsprozess und seine Ergebnisse und Erkenntnisse beeinflussen, da sie die Entscheidungen der Forschenden verändern kann.\nEine Frage, die man sich also stellen könnte, lautet: Haben Datensätze und Modelle eine Positionalität?\nWir wollen damit nicht sagen, dass die Modelle in den Datensätzen selbst demographische Identitäten und Lebenserfahrungen haben, aber sie aggregieren die Urteile und Meinungen realer Menschen und können daher bestimmte Positionalitäten gegenüber anderen vertreten.\nFrühere Arbeiten haben einige anekdotische Hinweise auf Positionalität gegeben, wie zum Beispiel kulturelle Unterschiede zwischen Modellen und Datensätzen, sowie theoretische Definitionen von Modellpositionalität.\nDiese Arbeiten befassen sich jedoch nicht wirklich mit dem Vergleich zwischen Endanwendern und den Datensätzen und Modellen selbst. Die Untersuchung der Positionalität von Modellen und Datensätzen wird immer wichtiger, da NLP-Aufgaben zunehmend subjektiver und sozialer werden und es schwierig ist, genau zu charakterisieren, wie diese Positionalitäten verzerrt werden, da nicht alle Entscheidungen dokumentiert werden und viele Modelle hinter APIs versteckt sind.\nUm die Positionalität von Datensätzen und Modellen zu untersuchen, vergleichen wir daher die Kommentare von realen Benutzern mit bestehenden Datensätzen und Modellen.\nDazu verwenden wir unser Framework NLPositionality.\nUnser Framework arbeitet in zwei Hauptschritten.\nDer erste Schritt besteht darin, Datensätze mit verschiedenen Annotatoren neu zu annotieren.\nDazu müssen die demographischen Daten der Annotatoren der ursprünglichen Datensätze untersucht werden. Normalerweise annotieren nur wenige Annotatoren jede Instanz, und demographische Daten werden selten erhoben und geteilt.\nWir entscheiden uns daher, die Daten erneut zu annotieren, um viele Annotatoren und einen umfangreichen Satz demografischer Daten zu erhalten.\nWir nehmen dann die Annotationen nach demographischen Merkmalen und vergleichen sie mit den Modellen und Datensätzen mithilfe eines R-Korrelationsscores nach Pearson. Damit unterscheidet sich unser System von der Literatur über Annotator-Uneinigkeiten, da wir die Endanwender mit den Modellen und Datensätzen, den Vorhersagen und den Labels vergleichen und nicht nur die Annotator-Übereinstimmung oder die Modellierung der Annotator-Verteilung betrachten.\nUnser Framework wird größtenteils durch Lab in the Wild und eine Online-Crowdsourcing-Plattform für HCI-Mitarbeiter ermöglicht.\nLab in the Wild ist eine Online-Experimentierplattform, auf der wir verschiedene Freiwillige rekrutieren können.\nIm Vergleich zu Plattformen wie M Turk, wo die meisten Teilnehmer aus den USA oder Indien kommen, ist Lab in the Wild immer noch in der Lage, qualitativ hochwertige Daten zu erhalten.\nBei Lab in the Wild haben wir zwei Aufgaben. Die erste ist die soziale Akzeptanz. Die Teilnehmer lesen eine Situation aus dem Social-Chemistry-Datensatz und schreiben dann auf, wie sozial akzeptabel die Situation ist.\nUm die Teilnehmer bei der Stange zu halten, können sie ihre Antworten dann mit einer KI und anderen vergleichen.\nWir haben diese Kommentare dann mit Social Chemistry, Delphi und GPT 4 verglichen.\nDanach wiederholten wir einen sehr ähnlichen Aufbau für die Aufgabe zur Erkennung von toxischen Inhalten und Hate Speech, bei der die Teilnehmer eine Situation aus Dynahate lasen und notierten, ob es sich ihrer Meinung nach um einen Fall von Hate Speech handelte.\nDiese Kommentare wurden dann mit Dynahate, Perspective API, Rewire API, Hate Roberta und GPT 4 verglichen.\nAm Ende erhob unsere Studie mehr als 16.000 Annotationen von über 1.000 Annotatoren aus 87 Ländern.\nWir sind jetzt besser gerüstet, um die Frage zu beantworten, auf wen die NLP-Datensätze und -Modelle am ehesten ausgerichtet sind.\nWir sehen, dass es eine Positionalität in der NLP gibt.\nWir stellen zum Beispiel fest, dass die Datensätze und Modelle am ehesten auf englischsprachige Länder ausgerichtet sind.\nWenn wir also die soziale Akzeptanz von GPT 4 analysieren, stellen wir fest, dass es am ehesten auf konfuzianische und englischsprachige Länder ausgerichtet ist.\nWir stellen fest, dass Dynahate ebenfalls am stärksten auf englischsprachige Länder ausgerichtet ist.\nWir stellen auch fest, dass es am ehesten auf Personen mit Hochschulbildung ausgerichtet ist.\nWir stellen also fest, dass GPT 4 in der Aufgabe „Soziale Akzeptanz“ am stärksten auf Personen mit Hochschul- oder Fachhochschulbildung ausgerichtet ist, und dasselbe gilt für Dynahate, das am stärksten auf Personen mit Hochschulbildung ausgerichtet ist.\nWenn jedoch Modelle und Datensätze auf bestimmte Bevölkerungsgruppen ausgerichtet sind, bleiben einige zwangsläufig auf der Strecke.\nEin Beispiel dafür ist, dass Datensätze und Modelle weniger gut auf nicht-binäre Menschen ausgerichtet sind als auf ihre männlichen und weiblichen Gegenstücke.\nWir finden dies in der GPT-4-Aufgabe Soziale Akzeptanz und in der Dynahate-Aufgabenanalyse.\nWenn es also Positionalität im NLP gibt, was können wir dagegen tun?\nNun, wir haben einige Empfehlungen.\nEine davon ist, alle relevanten Designentscheidungen während des gesamten Forschungsprozesses zu protokollieren.\nDie zweite ist, NLP-Forschung unter der Linse des Perspektivismus zu betreiben.\nUnsere dritte Empfehlung ist, spezialisierte Datensätze und Modelle innerhalb bestimmter Communities zu erstellen.\nDie Masakhani Initiative ist ein gutes Beispiel dafür.\nIch denke, wir möchten betonen, dass es bei inklusivem NLP nicht nur um die Produktion geht.\nAlle Technologien müssen für alle funktionieren.\nUnd damit ist unsere Präsentation zu Ende.\nAber wenn Sie mehr erfahren möchten, können Sie sich die neuesten Analysen und unsere Arbeit auf unserem Dashboard ansehen.\nVielen Dank.", "src_lang": "eng", "ref_lang": "deu", "benchmark_metadata": {"subset": "long", "task": "IF", "audio_file": "xiSxNRoOzm.wav", "sources": {"ref_xml": "MCIF0.2.IF.long.de.ref.xml", "src_text_source": "LONG_TEXTS"}}}
{"dataset_id": "mcif_v0.2", "dataset_type": "unseen", "sample_id": 20, "src_audio": "/Users/ahrii/Documents/workspace/Research/MTM/SLT/MCIF_V0.2/LONG_AUDIOS/yBDqNxQUwV.wav", "src_ref": "Hi! I'm going to talk about our work on \"Resolving Indirect Referring Expressions for Entity Selection\", in which we introduce the AltEntities Corpus. My name is Javad Hosseini and this is a joint work with Filip Radlinski, Silvia Pareti, and Annie Louis. Our goal is to understand users’ language when they want to make a choice. Consider this alternative question. \"Did you mean 'Easy on Me' or 'I Gotta Feeling'?\" Here, a user wants to select between one of these two songs. The most obvious thing is to use a direct reference, for example by saying the name of the song \"Easy on Me\" or its position, \"the first one\". But sometimes an indirect reference is more appropriate to have a more natural conversation. This could happen when the user cannot remember the name of the song. Or the pronunciations are too similar to each other and hard to disambiguate. Or when the user wants to specify a preference. Here are some examples of indirect references for example, \"the newer one\" or \"the song that's not energetic.\" This is an important problem in conversational systems and also for benchmarking LLMs' entity understanding. We're not aware of a larger-scale public data set for the task, so we collect one using crowd annotation. Our data set covers three different domains: music, books, and recipes. Our data set collection methodology emphasizes informality using a cartoon completion setup. The cartoon has three speech bubbles. In the first bubble, Bob says, \"Remember that song we were listening to yesterday?\" And with that, Bob sets the dialogue context. In the second speech bubble, Alice says, \"Do you mean 'Easy on Me' or 'I Gotta Feeling'?\" Which is the alternative question. And in the third speech bubble, Bob uses an indirect reference to select one of these entities, for example, \"the newer one.\" We provide the first and second speech bubbles automatically, but the third one is filled in by the annotator. The first speech bubble is chosen from a few manual prompts per domain. The second one, which is the alternative question is generated as follows. We always use a simple template. Do you mean A or B? Where A and B are samples from Wikipedia. Here are the different sampling methods we've used. When we move higher in the list, the entities become more similar to each other and it's usually harder to make the disambiguation. The first one is uniform at random. The second one is when the entities have similar titles, for example, two books with the name \"The Return\". The third one is when they have similar descriptions on Wikipedia. And finally when they have similar info boxes or attributes on Wikipedia. For example, the same genre or the same artist for a song. When we show this alternative question to the annotators, they know the name of these entities, but they don't necessarily know about the entities. So what we do is that we show some background knowledge about the two entities. For songs, we simply show a Google search link to each song and then ask the annotators to listen to at least some of each song, and read about each song. Here's for example, the Google search result for the song \"Easy on Me.\" For the recipes and books domain, we show some background text from Wikipedia. For recipes, we additionally show their images, again from Wikipedia, so that the annotators know how they look like. Then, we asked the annotators to pick one of these entities, for example, here's the first one, and describe them using three to five indirect referring expressions. For example, the one with the piano music. Here are some examples from our dataset. For example, \"the one without words\", \"not the one with the 12 year old boy\", or \"the fictional one\", or \"comes from Azerbaijan\", and so on. The AltEntities Corpus has 6,000 alternative questions across three domains, and it has 42,000 indirect referring expressions. Results with T5 XL model are summarized below. If the language model has access to the exact same background knowledge as the annotators, then the accuracy is really high, it's around 92 to 95%. But this is not realistic. If the language model has access to some partially overlapping background knowledge, then the accuracy is between 82 to 87%, which is more realistic. For example, when the language model retrieves the background knowledge. If the language model has access only to entity names, then the accuracy is only 60%, so there's a lot of room for improvement. We've also shown that the models are domain-generalizable. Here is a link to our dataset. Thanks.", "tgt_ref": "Hallo!\nIch werde über unsere Arbeit „Resolving Indirect Referring Expressions for Entity Selection“ sprechen, in der wir das AltEntities-Korpus vorstellen.\nMein Name ist Javad Hosseini und diese Zusammenarbeit entstand mit Filip Radlinski, Silvia Pareti und Annie Louis.\nUnser Ziel ist es, die Sprache der Benutzer zu verstehen, wenn sie eine Wahl treffen.\nBetrachten Sie diese Alternativen-Frage.\n„Meinten Sie 'Easy on Me' oder 'I Gotta Feeling'?“\nHier möchte ein Benutzer zwischen diesen beiden Liedern wählen.\nAm naheliegendsten ist es, einen direkten Bezug zu verwenden, etwa den Namen des Liedes, „Easy on Me“, oder seine Position, „das erste“.\nManchmal ist jedoch ein indirekter Bezug besser geeignet, um ein natürlicheres Gespräch zu führen.\nDies kann der Fall sein, wenn sich der Benutzer nicht an den Namen des Liedes erinnern kann.\nOder die Aussprachen sind zu ähnlich und schwer zu unterscheiden.\nOder wenn der Benutzer eine Vorliebe ausdrücken möchte.\nHier sind einige Beispiele für indirekte Verweise wie „das neueste“ oder „das Lied, das nicht energiegeladen ist“.\nDies ist ein wichtiges Problem für Konversationssysteme und auch für das Benchmarking des Entity Understanding von LLMs.\nUns ist kein großer öffentlicher Datensatz für diese Aufgabe bekannt, also sammeln wir selbst einen mit Hilfe von Crowd-Annotation.\nUnser Datensatz umfasst drei verschiedene Domains: Musik, Bücher und Rezepte.\nUnsere Methode der Datensammlung betont den informellen Charakter, indem wir einen Cartoon als Ergänzung verwenden.\nDer Cartoon besteht aus drei Sprechblasen.\nIn der ersten Sprechblase sagt Bob: „Erinnerst du dich an das Lied, das wir gestern gehört haben?“\nDamit gibt Bob den Kontext für den Dialog vor.\nIn der zweiten Sprechblase sagt Alice: „Meinst du ‚Easy on Me‘ oder ‚I Gotta Feeling‘?“\nDas ist die Alternativfrage.\nUnd in der dritten Sprechblase verwendet Bob einen indirekten Bezug, um eine der Entitäten auszuwählen, zum Beispiel „das neuere“.\nDie erste und zweite Sprechblase werden von uns automatisch zur Verfügung gestellt, die dritte Sprechblase wird vom Annotator ausgefüllt.\nDie erste Sprechblase wird aus einer Anzahl manueller Prompts pro Domain ausgewählt.\nDie zweite Sprechblase, die Alternativfrage, wird wie folgt generiert.\nWir benutzen immer eine einfache Vorlage.\nMeinst du A oder B?\nWobei A und B Beispiele aus Wikipedia sind.\nHier sehen Sie die verschiedenen Stichprobenverfahren, die wir verwendet haben.\nJe höher wir in der Liste kommen, desto ähnlicher werden die Begriffe und desto schwieriger wird es, eine eindeutige Antwort zu finden.\nDie erste ist zufällig gleichverteilt.\nDie zweite ist, wenn die Entitäten ähnliche Titel haben, zum Beispiel zwei Bücher mit dem Titel „Die Rückkehr“.\nDie dritte ist, wenn sie ähnliche Beschreibungen in Wikipedia haben.\nUnd schließlich, wenn sie ähnliche Infoboxen oder Attribute auf Wikipedia haben.\nZum Beispiel das gleiche Genre oder der gleiche Interpret bei einem Lied.\nWenn wir den Annotatoren diese Alternativfrage stellen, kennen sie die Namen dieser Entitäten, aber sie wissen nicht unbedingt etwas von den Entitäten.\nWir zeigen also etwas Hintergrundwissen über die beiden Entitäten.\nBei den Songs zeigen wir einfach einen Google-Suchlink zu jedem Song und bitten die Annotatoren, sich zumindest einen Teil des Lieds anzuhören und etwas über das Lied zu lesen.\nHier ist zum Beispiel das Google-Suchergebnis für das Lied „Easy on Me“.\nBei den Domains Rezepte und Bücher zeigen wir einige Hintergrundtexte aus Wikipedia.\nBei den Rezepten zeigen wir auch Bilder, ebenfalls aus Wikipedia, damit die Annotatoren wissen, wie sie aussehen.\nDann haben wir die Annotatoren gebeten, eine dieser Entitäten auszuwählen, zum Beispiel hier ist die erste, und sie mit drei bis fünf indirekten Bezugsausdrücken zu beschreiben.\nZum Beispiel „das Lied mit Klaviermusik“.\nHier sind einige Beispiele aus unserem Datensatz.\nZum Beispiel „das ohne Worte“, „nicht das mit dem 12-jährigen Jungen“, oder „das fiktive“, oder „kommt aus Aserbaidschan“, und so weiter.\nDas AltEntities-Korpus enthält 6.000 Alternativfragen aus drei Domains und 42.000 indirekt verweisende Ausdrücke.\nDie Ergebnisse mit dem T5 XL Modell sind unten zusammengefasst.\nWenn das Sprachmodell Zugriff auf genau dasselbe Hintergrundwissen hat wie die Annotatoren, dann ist die Genauigkeit wirklich hoch, sie liegt zwischen 92 und 95 %.\nDies ist jedoch nicht realistisch.\nWenn das Sprachmodell Zugang zu Hintergrundwissen hat, das sich teilweise überschneidet, liegt die Genauigkeit zwischen 82 und 87 %, was realistischer ist.\nZum Beispiel, wenn das Sprachmodell auf Hintergrundwissen zurückgreift.\nWenn das Sprachmodell nur auf die Namen der Entitäten zugreift, liegt die Genauigkeit nur bei 60 %, es gibt also noch viel Raum für Verbesserungen.\nWir haben auch gezeigt, dass die Modelle auf verschiedene Domains verallgemeinert werden können.\nHier ist ein Link zu unserem Datensatz.\nVielen Dank.", "src_lang": "eng", "ref_lang": "deu", "benchmark_metadata": {"subset": "long", "task": "IF", "audio_file": "yBDqNxQUwV.wav", "sources": {"ref_xml": "MCIF0.2.IF.long.de.ref.xml", "src_text_source": "LONG_TEXTS"}}}
