{"dataset_id": "acl_6060", "sample_id": 416, "src_lang": "en", "tgt_lang": "zh", "output": "Hello, my name is Assa Farari and I will present our paper Few Short Tabular Data Enrichment Using Feintunic Transformers Architectures. Data scientists analyze data and focus mainly on manipulating the data's existing features, but sometimes these features are limited. Generation of features using another data source can add substantial information. Our research goal is automatic tabular data enrichment using external sources free text. Assume we have a tabular dataset and a knowledge base. We need an automatic process, which involves linking of entities and text analysis to extract new features from the knowledge base free text. Our framework FAST is exactly this automatic process. So let's see an example. Any datasets fed into FAST. In this example, the dataset is a university dataset when its goal is to classify universities into low ranked universities and low ranked universities. Universities and high-ranking universities. As a knowledge base, we use Wikipedia. The first phase of FEST is entity linking, when each entity, in this example, the university name is linked to an entity within the knowledge base, and the text of the entities of the knowledge base is extracted and added to the dataset. In this example, the text is the Wikipedia page abstract. Now we need to generate or extract features from the retrieved text. So we need to we need a feature extraction phase which includes text analysis and this is the main novelty of this paper and I will deep dive into it in the next slides. After the feature extraction phase there is a feature generation phase when we use the extracted features to generate a small number of new features. First, generate features in the number of classes of the original dataset. In this example, the original dataset has two classes, so first generate two new features. But if the dataset has five classes, first generate five new features. Each feature represents the likelihood for each class. To analyze the text, we use the current state of the art of text analysis, which are transformator-based language models, such as BERT, GPT, XLETs, etc. However, it is unlikely that we can train language models using the input datasets. Therefore, a naive approach will be a target task fine tuning. In the feature extraction phase, we can download a pre-trained language model, fine tuning the language model over the target dataset in this example to fine tuning the language model to classify to classify text into classes abstract into classes low or high receive the language model output which is the likelihood for each class and use as new features the problem with this approach is data sets may have few distinct entities text In our experiment, almost half of the data sets contain less than 400 samples and the smallest data set contain It contains 35 samples in its training set. Therefore, fine-tuning a language model over this dataset will be ineffective. But we can use prior knowledge about pre-analyzed datasets because we apply fast over multiple datasets. We can use the n-1 datasets to gather information about the n-1 datasets and use this information when we analyze the nth dataset. What we suggest is to add another fine-tuning phase, a preliminary multitask fine-tuning phase when we fine-tune the language model over n-1 datasets and then we execute another fine-tuning phase which is a target task fine-tuning when we fine-tune the language model over the nth target dataset. The state of the art in multitask fine-tuning called empty dnn in empty dnn empty dnnn maintain a heads in the number of tasks in the training set so if in this example there are four tasks in the training set so empty dnn maintain four heads as you can see at the image and it samples a random batch from from the training set and if the random batch belongs to for example Sing and Selt and classification tasks it executes forward and backward paths through the first head and if the random batch belongs to pairwise ranking task it executes forward and backward paths through the last head in our scenario a tableau dataset varies the number of classes so there are many tasks empty dnn maintain MTDNN maintains a number of classes heads, output layers, and additionally, MTDNN needs to initialize new heads for a new data set with a new task. Our approach called task reformulation fine tuning is in our approach task reformulation fine tuning, instead of maintaining multiple heads, we reformulate each data set into a sentence per classification problem, which is a two-class. So let's see an example. Here is our input data set which consists of entities, features, text and classes and we reformulate the task from classifying the text into low and high to classify the text, the abstract and the class into true or false. Or in other words, we train the language model to classify abstract and class to abstract and class if the abstract belong to the class or not so the label vector in this case stays always which consists always with two classes and this is the algorithm for our find or reformulated fine-tuning approach. So let's see the full framework. A data set fed into FAST and then FAST execute into the linking phase. It extract the text from the knowledge base, which in this example is the abstract of the Wikipedia page. Then it reformulates the task into sentence per classification tasks. Apply the language model to the new task and output likelihood for each class. Note that the language model is already fine-tuned over n-1 dataset using a preliminary multitask fine-tuning. Then we use the output vector of the language model as a newly generated feature in the number of classes. To evaluate our framework, we use a 17 tabth tabular classification dataset, which varies size, features, balance, domain and initial performance. And as a knowledge base, we use Wikipedia. We design our experiment as a live one out evaluation when we train fast over 16 datasets and apply it to the 17th dataset. We also split each dataset into a four-crop. We generate a fork faults and apply a fork faults cross validation. Then we generate the new feature and evaluate them using five evaluation classifiers. We use in our experiment based BERT-based architecture. Here are the results for our experiment. You can see that we compare our framework to target dataset fine tuning, target task fine tuning. and MTDNN preliminary fine-tuning and our reformulated fine-tuning achieved the best result, the best performance while MTDNN achieved 2% improvement over the target data set fine-tuning. our approach achieved 6% improvement when we look on the small data set From the dataset we can see that the performance of MTDNN decreases and the improvement of the preliminary multitask fine tuning phase decreases to 1.5 percent, but our performance increased to 11 percent compared to the target task fine tuning alone. For summing, FAST enables view shot enrichment from thirty five samples in our experiment. Our experiment uses one architecture for all tasks, datasets, and it keeps the head of the model. But it adds three formulation phases. It augments the train set and it needs a target value with semantic meaning so we can fed it into the language model and use it in the sentence per classification problem. Thank you."}
{"dataset_id": "acl_6060", "sample_id": 417, "src_lang": "en", "tgt_lang": "zh", "output": "Hello everyone. Today I am going to present our research work Learning to Reason Deductively: Metroid Problem Solving as Complex Vision Extraction. I am Alan from Biden's AI Lab, and this is a joint work with Thierry from the University of Texas in Austin and Wayloo from SUDD. First, I would like to talk about our motivation for reasoning. So here we show an example where multi-step reasoning is helpful. So this figure is taken from the POWN paper, where they perform prompting to solve the metroid problem in a future learning scenario. So on the net pen side, we can see if we give some examples with just questions and answers, we may not be able to obtain the correct answers. But if we give some more reasoning description, the model is able to predict the reasoning description and also make a correct prediction here. So it is good to have interpretable multi-step reasoning as output. And we also think that method problem is a straightforward application to evaluate such reasoning abilities. So here in our problem set.up, given the questions, we need to solve this question and obtain the numerical answers. So in our datasets, we also get the mathematical expression, which leads to this particular answer as well. So certain assumptions also apply as in previous work. We assume the precision of quantities are known and we only consider basic operators such as addition, subtraction, multiplication, division and exponential. Furthermore, complicated operators can actually be decodomposed into these basic operators. So previous work in methodological problem solving can actually be categorized into sequence to sequence and sequence to tree model. So traditional sequence to sequence model converts the expression to a specific sequence for generation and it is quite easy to implement and it can generalize to many different complicated problems. But the drawbacks are that the performance is actually generally not better than the structure model and it is lack of interpretability for the prediction. But in fact, this direction is still quite popular because of the transformator model. So in tree-based models, we actually structure these expressions in a tree-form and follow a pre-order traversal in tree-generations. So here we keep generating the operators until we reach the leaves, which are the quantities. So here the good thing is that it actually gives us this binary tree structure. But in fact it is quite counterintuitive. Because we generate the operator first and then at the end we generate the quantities. And the second thing is that it also contains some repetitive calculations. So here, if we look at this expression, eight times three plus three, it is actually generated twice. But in fact, we should reuse the results. So in our proposed approach, we want to solve those problems step by step and interpretable manners. So for example here in the second step, we can obtain the these divisors, which are 27. We can also refer back to the original questions to find the relevant contents. And in these steps, we obtain the divisors. And then in this third step, we actually get the quotient. And after these three steps, we can actually reuse the results from the second step and then get the results of the fourth step. And then finally, we can obtain the dividends. So here we actually generate the whole expression directly, rather than generating single operators or quantities. This makes the process more accurate. So in our deductive system, we first start with a bunch of quantities presented in the questions and also include some constants as our initial states. So the expression is represented by EIJOP, where we perform operators from Qi to QJ, and such an expression is actually directed. So, we also have subtraction reversed here to represent the opposite direction. This is quite similar to relation extraction. So, in a formal deductive system, at the time step t, we apply the operator between the Qi and Qj pair, and then we obtain this new expression. We add it to the next states to become a new quantity. So, these slides actually visualize the evolution of the states, where we keep adding expression to the current states. In our model implementations, we first use a pre-trained network model, which can be birds or robots, and then we code a sentence and then we obtain these quantity representations. Once we get the quantity representations, we can start doing inference. Here we show an example of Q one to obtain the representation for Q one, which will be divided by Q two and then times Q three. First, we get the pair representation, which is basically just the concatenation between Q one and Q two, and then we apply a feedforward network, which is. Which is parameterized by the operator. And then finally we obtain the expression representation q one divided by q two. But in fact, in practice, in the inference stage, we might be able to get the incorrect expression as well. So here all the possible expression is equal to three times the number of operators. So the nice thing here is that we can easily add constraints to control this search space. For example, if this expression is not allowed, we can simply remove this expression in our search space. So in the second step we do the same thing, but the only difference is one more quantity. So this quantity comes from the previously calculated expression. So finally we can obtain this final expression q three times q four. And we can also see that the number of all possible expressions is different from the previous step. So such differences make it difficult to apply. beam search because the probability distribution between these two steps is unbalanced. Therefore, the training procedure is similar to training a sequence to sequence model, where we optimize the loss at each time step, and here we also use this tau to represent when we should terminate this generation process. And here the space is different from sequence to sequence because the space is different at each time step, while in the traditional sequence to sequence model it is the number of vocabulary. It also allows us to impose certain constraints based on previous knowledge. We conduct experiments on the commonly used methodological problem datasets MAWPS, Math twenty three K, MathQA and SWAM. Here we briefly show the results compared to the previous best approaches. Our best performing variant is Roberta Deductive Reasoner. In fact, we do not use BeamSearch, on the other hand, previous approaches use are often tree-based models. Overall, our reasoner is able to significantly outperform this tree-based model, but we can see that the absolute numbers on MathQA or SWAMP are not really high. We further investigate the results on SWAMP, and this data set is challenging because the author tried to manually add something to confuse the NLP model, such as adding. For example, we add irrelevant information and extra quantities. So our model makes some predictions like this, which produces negative values. And we observe that these two expressions actually have similarity. scores. So we can actually limit this search space by removing, for example, those results are negative, so that we can make the answer correct. So we further find that such constraint actually improves quite a lot for some models. For example, for birds we improve seven points. And then for the Roberta base model we actually improve two points. So better language model has better language understanding ability so that the number here is. Here it is higher for Roberta and lower for birds. And we also try to analyze the difficulty behind this behind all these data sets. We assume that the number of unused quantities can be regarded as irrelevant information here. So here we can see that we have the percentage of samples with unused quantities and the swamp data set has the largest portion. And here we also show the overall performance for those samples without unused quantities. So the overall performance is actually higher than the. And the performance is actually higher than the overall performance. But with those samples that with unused quantity, it is actually much worse than the overall performance. For MAWPS, we don't really have too many such cases, so I just ignore this part. So finally, we want to show the interpretability through a crash and participation example. So here our model actually makes a wrong prediction at the first step. So we can actually correlate this expression with the sentence here. So we think this sentence might be misleading the model to an incorrect prediction. So here planting another thirty five makes the model think it should be an additional operator. So we try to revise the sentence to be something like the number of pear trees thirty five fewer than the apple trees. So we make it to convey more accurate semantics, so that the model is able to make the prediction correct. This study shows how interpretable predictions help us understand the model behavior. To conclude our work, our model is actually quite efficient and we are able to provide interpretable solving procedures and we can easily incorporate some prior knowledge as constraints which can help improve the performance. The last thing is that the underlying mechanism does not only apply to network problem solving tasks but also to other tasks that involve multi-step reasoning. However, we also have certain limitations. If we have a large number of operators or constants, the memory consumption could be pretty high. And the second thing is that, as mentioned, because the probability distribution is unbalanced at different time steps, so it's also pretty challenging to apply beam search strategy. So this is the end of the talk, and questions are welcome. Thank you."}
{"dataset_id": "acl_6060", "sample_id": 418, "src_lang": "en", "tgt_lang": "zh", "output": "Hello, my name is Antoine and I'm from Maastricht University. I will be presenting my joint work with Jerry, which is about a new dataset for statutory article retrieval. Legal issues are an integral part of many people's lives, but the majority of citizens have little to no knowledge about their rights and fundamental legal processes. As a result, many vulnerable citizens who cannot afford the costly assistance of a legal expert are left unprotected or worse, exploited. aims to bridge the gap between people and the law by developing effective retrieval system for statutory articles. Such a system could provide a free professional legal help service for unskilled humans. Before diving into the main contribution of this work, let's first describe the problem of statutory article retrieval. Given a simple question on a legal matter, such as what do I risk if I violate professional confidentiality? A model is required to retrieve all relevant statutory articles from a large body of legislation. This information retrieval task comes with its own set of challenges. First, it deals with two types of language common natural language for the questions and complex legal language for the statutes. This difference in language distributions makes it harder for a system to retrieve relevant candidates, as it indirectly requires an inherent interpretation system that can translate a natural question to a legal question that matches the terminology of statutes. Bes, statutory law is not a stack of independent articles that can be treated as a complete source of information on their own, like news or recipes, for example. Instead, it's a structure collection of legal provision that have a whole meaning only when considered in the overall context, that is, together with the supplementary information from the neighbouring articles, the fields and subfields they belong to, and their place in the structure of the law. Lastly, statutory articles aren't small paragraphs. which usually is the typical retrieval unit in most retrieval works. Here they are long documents that may be up to six thousand words. The recent advances in NLP have sparked huge interest in many legal tasks such as legal judgment prediction or automated contract review, but statutory article retrieval has remained mainly untouched due to the lack of large and high quality label data sets. In this work, we present a new French native citizen centric data set to study whether a retrieval model can approximate the efficiency and reliability of a legal expert for the task of statutory article retrieval. Our Belgian statutory article retrieval datasets consist of more than one thousand one hundred legal questions posed by Belgian citizens. These questions cover a wide range of topics from family, housing, money, to work and social security. Each of them has been labeled by experienced jurists with references to relevant articles from a corpus of more than twenty two thousand six hundred legal articles from Belgian codes of law. Let's now talk about how we collected this data set. First, we started by compiling a large corpus of legal articles. We considered thirty two publicly available Belgian codes and extracted all their articles as well as the corresponding section headings. Then we gathered legal questions with references to relevant statutes. To do so, we partner with a Belgian law firm that receives each year around four thousand emails from Belgian citizens who ask for advice on a personal legal issue. We were lucky enough to get access to their websites where their team of experienced jurists addresses Belgian most common legal issues. We collected thousands of questions annotated with categories, subcategories, and legal references to relevant statutes. Lastly, we passed the legal references and filtered out the questions whose references were not articles in one of the codes of law we considered. The remaining references were matched and converted to the corresponding article IDs from our corpus. We eventually ended up with one thousand one hundred eight questions, each carefully labeled with the IDs of the relevant articles from our large corpus of twenty two thousand six hundred thirty three statutory articles. In addition, each question comes with a main with a concatenation of their subsequent heading in the structure of the law. This extra information is not used in the present work, but might be of interest for future research on legal information retrieval or legal text classification. Let's look at some characteristics of our dataset. The question are between five and forty four words long with a median of forty words. The articles are much longer with a median length of seventy seven words with one hundred and forty two of them exceeding one thousand words. The longest one being up to five thousand seven hundred and ninety words. As previously mentioned, the question covered a wide range of topics, with around eighty five percent of them being either about family, housing, money, or justice, while the remaining fifteen percent concern either social security, foreigners, or work. The articles are also very diverse, as they come from thirty two different Belgian codes that cover a large number of illeg articles collected from each of these Belgian codes. Out of the 22,633 articles, only 1,612 are referred to as relevant to at least one question in the datasets, and around 80 percent of these cited articles come from either the civil code, judicial code, criminal investigation code or penal codes. Meanwhile, 18 out of 32 codes have less than five articles mentioned as relevant to at least one question. question, which can be explained by the fact that those codes focus less on individuals and their concerns. Overall, the median number of citation for these cited articles is two, and less than twenty five percent of them are cited more than five times. Using our data sets, we benchmark several retrieval approaches, including lexical and dense architecture. Given a query in an article, a lexical model assigns a score to the query article pair by computing. By calculating the sum over the query terms of the weights of each of these terms in that article. We experiment with the standard TFIDF and BM twenty five ranking functions. The main problem with these approaches is that they can only retrieve articles that contain keywords present in the query. To overcome this limitation, we experiment with a neural-based architecture that can capture semantic relationship between queries and article. We use a BEncoder model that maps queries and articles into dense vector representations. and calculate a relevant score between a query article pair by the similarity of their embeddings. These embeddings are typically the result of a pooling operation on the output of a word embedding model. First, we study the effectiveness of Siamese B encoders in a zero shot evaluation setup, meaning that pre-trained word embedding models are applied out of the box without any additional fine tuning. We experiment with context-independent text encoder, namely Word to Vec and Fast. and fast text and context dependent embedding models, namely Roberta and more specifically Camembert, which is a French Roberta model. Additionally, we train our own Camembert based model Biancoders on all data sets. Note that for training, we experiment with the two flavors of the Biancoder architecture. Siamese, which uses a unique word embedding model that maps the query and article together in a shared dense vector space. independent word embedding models that encode the query and article separately into different embedding spaces. We experiment with mean, max, and CLS pooling as well as dot product and cosine for computing similarities. Here are the results of our baseline on the test sets with the lexical methods above, the Siamese B encoders evaluated in a zero shot setup in the middle, and the fine tuned B encoders below. Overall, the fine tuned B encoders significantly outperform all the other baselines. The two tower model improves over its Siamese variant on recall at one hundred, but performs similarly on the other metrics. Although BM twenty five underperformed the trained Biancoder significantly, its performance indicates that it's still a strong baseline for domain specific retrieval. Regarding the zero shot evaluation of Siamese Biancoder, we find that directly using the embeddings of a pre trained Kamembert model without optimizing for the information retrieval task gives poor results, which is consistent with previous findings. And the word-to-vec-based Biancoder significantly outperformed the fast-text and bird-based model, suggesting that maybe pre-train word level embeddings are more appropriate for the task than character level or sub-word level embeddings when used out of the box. Although promising, these results suggest ample opportunity for improvement compared to a skilled little expert who can eventually retrieve all relevant articles to any question and thus get perfect scores. Let's conclude by discussing two limitations of all data sets. First, the corpus of articles is limited to those collected from the thirty two considered Belgian codes, which does not cover the entire Belgian law, as articles from decrees, directives, and ordinances are missing. During the data set construction, all references to these uncollected articles are ignored, which causes some question to end up with only a fraction of the initial number of relevant articles. This information loss implies that the answer contained in the remaining relevant articles. might be incomplete, although it's still completely appropriate. Second, we should note that not all legal questions can be answered with statutes alone. For instance, the question can I evict my tenants if they make too much noise might not have a detailed answer within statutory law that quantifies a specific noise threshold at which eviction is allowed. Instead, the landlord should probably rely more on case law and find precedents similar to their current situation. For example, the tenant makes two parties a week until 2 a.m. Hence, some questions are better suited than others to the statutory article retrieval task, and the domain of the less suitable ones remains to be determined. We hope that all work sparks interest in developing practical and reliable statutory article retrieval models that can help improve access to justice for all. You can check out our paper DatSet and Code at the following links. Thank you."}
{"dataset_id": "acl_6060", "sample_id": 419, "src_lang": "en", "tgt_lang": "zh", "output": "Hello, we are happy to present our work on VALS, a task independent benchmark meant for testing vision and language models with specific linguistic phenomena. Why did we do the trouble in setting up this benchmark? Well, during the last years we have seen an explosion of transformer based vision and language models pre trained on large amounts of image text pairs. Each one of these models pushes state of the art on vision and language tasks such as visual question answering visual common sense reasoning, image retrieval, phrase grounding. So we got a message the accuracies on these task specific benchmarks are increasing steadily, but do we know what the models have actually learned? What is it that a vision and language transformer understood when assigning a high score for this image and this sentence to match and a low score for this one? Do vision and language models focus on the right thing or do they focus on biases as shown by previous work. To shed more light on this aspect, we propose a more task agnostic direction and introduce valves that tests the sensitivity of vision and language models to specific linguistic phenomena that affect both the linguistic and the visual modalities. We target existence, plurality, counting, spatial relations, actions, and entity coreference. But how do we test whether the vision and language models have captured these phenomena? foiling, a method previously applied for vision and language models only for noun phrases by Ravi Shakar and collaborators and on counting by us in previous work. Foiling basically means that we take the caption of an image and produce a foil by altering the caption such that it does not describe the image anymore. And we do these phrase alterations by focusing on six specific pieces such as existence, plurality, counting, spatial relations, actions, and entity coreference. Each piece can consist of one or more instruments in case we found more than one interesting way to create foil instances. For example, in the case of the actions piece, we have two instruments, one in which the action verb is changed with a different action and one in which actants are swapped. Counting and coreference also are pieces that have more than one instrument. And we create these foils by making sure that they fail to describe the image, that they are grammatical and otherwise valid sentences. This is not easy to do because a foiled caption may be less likely than the original caption. For example, though it's not impossible, it is statistically less likely for plants to cut a man than a man to cut plants and large vision and language models could pick up on this. Therefore, to obtain valid foils we must take action. First, we make use of strong language models to propose foils. Second, we use natural language inference or short NLI to filter out foils that could be still describing the image since when constructing foils we need to ensure that they fail to describe the image. To test this automatically we apply natural language inference with the following rationale. We consider an image to be the premise and its caption its entailed hypothesis. In addition we consider the caption to be the premise and the foil is its hypothesis. If an NLI model predicts the foil to contradict or to be neutral with respect to the caption, we take this as an indicator of a valid foil. to be entailed by the caption, it cannot be a good foil since by transitivity it will give a truthful description of the image and we filter these foils out. But this procedure is not perfect. It is just an indicator for valid foils, therefore as a third measure for generating valid foils, we employ human annotators to validate the data used in Vals. So after filtering and human evaluation, we have as many test instances as described in this table. Note that Vals does not deliver any training data. but only test data since it is a zero shot testing benchmark only it is designed to leverage the existing capabilities of vision and language models after pre-training fine tuning would only enable models to exploit artifacts or statistical biases in the data and we all know that these models like to cheat and take shortcuts and as we said we are interested in assessing what capabilities the vision and language models have after pre-training we experiment with five vision and language models on valves namely with clip Clip, Alex Mert, Wilbert, Wilbert Kelvin one, and Visual Bert. Two of our most important evaluation metrics are the accuracy of the models in classifying image sentence pairs into captions and foils. Perhaps more relevant for this video, we will showcase our more permissive metric, the pairwise accuracy, which measures whether the image sentence alignment score is greater for the correct image text pair than for its foiled pair. For more metrics and results on them, do check out our paper. The results with pairwise accuracy are shown here and they are consistent with the results we got from the other metrics is that the best zero shot performance is achieved by Wilbert twelve in one followed by Wilbert, Alex Mert, Clip, and finally Visual Bird. It's notable how instruments centered on individual objects like existence and noun phrases are almost solved by Wilbert twelve in one, highlighting that models are capable of identifying named objects and their presence in images. However, none of the remaining pieces can be reliably solved in our adversarial foiling settings. instruments that vision and language models have trouble distinguishing references to single versus multiple objects or counting them in an image. The relation piece shows that they have difficulties in correctly classifying a named spatial relation between objects in an image. They also have trouble distinguishing actions and identifying their participants even if supported by plausibility biases as we see in the actions piece. From the coreference piece, we find out that tracing multiple references to the same object in an image by using pronouns is also difficult for vision and language models. As a sanity check and because it's an interesting experiment, we also benchmark two text only models GPT one and GPT two to assess whether valves is solvable by these unimodal models by computing the perplexity of the correct and the foiled caption, no image here, and predicting the entry with the lowest perplexity. If the perplexity is higher for the foil, we take this as an indication that the foiled caption may suffer from plausibility bias or other linguistic biases. And it's interesting to see that in some cases. The text only GPT models have captured the plausibility of the world better than the vision and language models. So to sum up, VALS is a benchmark that uses the lens of linguistic constructs to help the community improve vision and language models by hard testing their visual grounding capabilities. Our experiments show that vision and language models identify named objects in their presence in images well, as shown by the existence piece, but struggle to ground their interdependence and relationships in visual scenes when forced to respect linguistic indicators. We would really like to encourage the community to use Valse for measuring progress towards language grounding with vision and language models. And even more, Valse could be used as an indirect assessment of datasets, as models could be evaluated before and after training or fine tuning to see whether a dataset helps models improve on any of the aspects tested by Valse. If you're interested, do check out the Valse data on GitHub and if you have any questions, do not hesitate to contact us."}
{"dataset_id": "acl_6060", "sample_id": 420, "src_lang": "en", "tgt_lang": "zh", "output": "Hello, my name is Kamizar from the University of Tokyo. I will be presenting a paper entitled R and SAM, a large scale data set for automatic risk not duration via commit log summarization. I will explain in this order. First, I will introduce the automatic risk not duration that we are working on in this research. Release note is a technical document that summarizes the changes distributed with each release of a software product. The image shows the release notes for version two point six point four of the GBUJS library. These nodes play an important role in open source development, but they are time consuming to prepare manually. Therefore, it would be very useful to be able to automatically generate high quality release nodes. I will refer to two previous researches on automatic release note generation. The first is a system called Arena released in twenty fourteen. It takes a rule based approach, for example, using the change extractor to extract core differences library changes. and document changes from the differences between releases and finally combining them. The most notable feature of this system is the issue extractor in the upper right corner, which must be linked to Jira, the issue tocosystem and can only be applied to projects that use Jira. In other words, it cannot be used for many projects on GitHub. The second is Griff, recently announced in twenty twenty. It is available on the internet and can be stored via PIP. This system has a simple learning based text classification model and outputs one of five rubber such as features or bug fixes for each input commit message. The image is a sample usage that returns a corrective or bug fixes rubber. Queryface learning data is fairly small about five thousand and will be shown in the experiments described below. The performance of the text classification model is not high. I present two related researches but there are problems of limited applicability and scaries. Our paper solved these two problems and automatically generates high quality releases. For the limited applicability program, we propose a high quality classifier summarization method using only committee message as input. This proposed method can be used for all English repositories. For the second problem of scarce data resources, we built a RNSM data set consisting of about eighty two thousand pieces of data by collecting data from public GitHub repositories using the GitHub API. Next, I describe our data set. Here is an example of data. The left side is a commit message and the right side is the release notes. The release notes are leveled as improvements, bug fixes, etc. We have set up a task that takes the commit messages as input and outputs the leveled release notes. This can be regarded as a summarization task. We have predefined four levels features, improvements, bug fixes, deprecations, removables and braking changes. These were set based on previous research and other factors. The list notes on the bottom right are extracted from the list notes shown on the bottom left. At this time, it is necessary to detect the four rubbers that have been set up in advance, but the rubbers are not always consistent with each repository. For example, the improvements rubble includes improvements, enhancements, optimizations, and so on. We prepared a vocabulary list of study rubbers for each of these notational. with the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words of the words. and the first and last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all the last of all on the method names found in the repository. Next, I will explain the proposed method. The crosswise extractive and abstractive summarization model consists of two neural modules a classifier using bot or code bot and a generator using bot. First, GEAS uses a classifier to classify each commit message into five reason classes, features, improvements, bug fixes, deprecations, plus and other. The commit messages classified as other are discarded. Then GEAS. GAS applies a generator to the four rubble documents independently and generates reason for each class. In this task, the direct correspondences between commit messages and reason notes are not known. Therefore, to train the class wire, we assign two rubbles to each input commit message using the first ten characters of each commit message. We model the class wise abstractive summarizing approach by two different methods. The first model, which we call GAS single SECA consists of a single SECTO SEC network and generates a single long list note text giving a concatenation of input commit messages. The output text can be divided into class by segment based on special class specific endpoint symbols. The second method method which we call GSMAUC consists of four different SECTO SEC networks, each of which correspond to one of the list note classes. Okay, let me explain the experiment. Five methods were compared GS, GS single, GS march, rustling, and previous study grief. Regarding abortion, in some cases, these notes are output in multiple sentences. Since it is difficult to calculate the number of sentences at zero, they are combined with spaces and treated as one long sentence. The brew is penalized when the system outputs a short sentence. This penalty results in a lower brew value in the experiment results described next. Finally, we also calculated the specificity because Rouge and Brew cannot be calculated if the release nodes are empty. A high specificity means that the model calculated outputs are empty text in cases where the release nodes assume empty. Here are the results. Since the data set contains email addresses, hash values, etc, we also aborted the green data set, which excludes them. GAS and GAS achieved Rouge error scores more than ten points higher than the baseline. However, on the green test set, the score gap between the proposed method and the base end jumped to more than twenty points. These results indicate that GAS and GAS are significantly effective. GAS got a better lowest score than GAS, suggesting that combining a classifier and a generator is effective on training the classifier using pseudobus. The high coverage of GAS can be achieved probably because the classifier can focus on selecting relevant commit messages for each class. Shea's much tended to yield higher rudge than shea single, suggesting that it is also effective to independently develop different to your perspective summarization models for each of these not class. Here are an error analysis. Shea's methods tend to output shorter sentences than human reference sentences. In the figure on the right, the reference sentence has three or four sentences while shea's has only one. The reason for this model reluctance is that in the training data only thirty three percent of the sentences are present in the features rabble and forty percent in the improvements rabble. Furthermore, GS methods cannot generate accurate reason notes without additional information. The top example on the right is an example of a very messy commit message and the complete sentence cannot be generated without reference to the corresponding parallel request or issue. The example below shows that the two commit messages in the input are related and should be combined into one sentence but it fits. But it fails to do so. Finally, a conclusion. We have built a new data set for automatic reason not generation. We have also formatted the task of entering commit messages and summarizing them so that it is applicable to all projects written in English. Our experiments show that the proposed method generates less noisy reason not at higher coverage than the base rise. Please check out our data set on GitHub. Thank you."}
