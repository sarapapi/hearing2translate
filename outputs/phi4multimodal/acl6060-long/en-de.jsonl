{"dataset_id": "acl_6060", "sample_id": 416, "src_lang": "en", "tgt_lang": "de", "output": "Hallo, mein Name ist Asaf Farahri und ich werde unser Papier vorstellen, few-shot tabellarische Datenerweiterung mit feinabgestimmten Transformerarchitekturen. Datenwissenschaftler analysieren Daten und konzentrieren sich hauptsächlich auf die Manipulation der vorhandenen Merkmale. Aber manchmal sind diese Merkmale begrenzt. Merkmalsgenerierung mit einer anderen Datenquelle kann wesentliche Informationen hinzufügen. Unser Forschungsziel ist die automatische tabellarische Datenerweiterung mit freier Textquelle. Angenommen, wir haben eine tabellarische Datenbank und eine Wissensdatenbank. Wir brauchen einen automatischen Prozess, der Intitielinking und Textanalyse beinhaltet, um neue Merkmale aus dem Text der Wissensdatenbank zu extrahieren. Unser Framework, FIST, ist genau dieser automatische Prozess. Sehen wir uns ein Beispiel an. In einem Datensatz, der in FIST eingegeben wird, ist das Ziel der Universität, Universitäten in niedrige und hohe Universitäten einzuordnen. Als Wissensdatenbank verwenden wir Wikipedia. Die erste Phase von FIST ist Entitätserkennung, wenn jede Entität. In diesem Beispiel ist der Name der Universität mit einer Entität in der Wissensdatenbank verknüpft. Und der Text der Entitäten der Wissensdatenbank wird in den Datensatz eingefügt. In diesem Beispiel ist der Text die Wikipedia-Überschrift. Jetzt müssen wir Merkmale aus dem Text extrahieren. Wir brauchen eine Merkmalsextraktion, die Textanalyse beinhaltet. Dies ist das Hauptthema dieses Papiers und ich werde in den nächsten Folien darauf eingehen. Nach der Merkmalsextraktion gibt es eine Merkmersynthesephase, in der wir die extrahierten Merkmale verwenden, um eine kleine Anzahl neuer Merkmale zu generieren. FIST generiert neue Merkmale in der Anzahl der ursprünglichen Klassen. In diesem Beispiel hat der ursprüngliche Datensatz zwei Klassen, also generiert FIST zwei neue Merkmale. Aber wenn der Datensatz fünf Klassen hat, generiert FIST fünf neue Merkmale. Jedes Merkmal repräsentiert die Wahrscheinlichkeit für jede Klasse. Um den Text zu analysieren, verwenden wir den aktuellen Stand der Technik der Textanalyse, nämlich Transformer-basierte Sprachmodelle wie BERT, GPT, XLNET usw. Aber es ist unwahrscheinlich, dass wir ein Sprachmodell mit den Eingabedaten trainieren können. Ein naiver Ansatz wird eine Zielaufgabe feinabstimmen. In der Merkmersynthesephase können wir ein vortrainiertes Sprachmodell herunterladen und das Sprachmodell über den Zieldatensatz feinabstimmen. In diesem Beispiel ist das Ziel, den Text in zwei Klassen zu klassifizieren, abstr und Klasse, in die wir uns einordnen. Wir erhalten das Sprachmodelloutput, das die Wahrscheinlichkeit für jede Klasse ist, und verwenden es als neue Merkmale. Das Problem mit diesem Ansatz ist, dass Datensätze möglicherweise nur wenige verschiedene Entitätstexte enthalten. In unserem Beispiel enthält fast die Hälfte der Datensätze weniger als 400 Proben. Und die kleinste Datensatz enthält 35 Proben. Um also ein Sprachmodell über diesen Datensatz zu feinabstimmen, ist es unwahrscheinlich. Aber wir können die Vorwissen über voranalysierte Datensätze nutzen, weil wir FIST über mehrere Datensätze anwenden. Wir können die n-1 Datensätze verwenden, um Informationen über die n-1 Datensätze zu sammeln und diese Informationen verwenden, wenn wir den n-ten Datensatz analysieren. Was wir vorschlagen, ist, eine weitere Feinabstimmungsphase hinzuzufügen, eine vorläufige Multi-Task-Feinabstimmung, bei der wir das Sprachmodell über n-1 Datensätze feinabstimmen. Und dann führen wir eine weitere Feinabstimmungsphase durch, bei der wir das Sprachmodell über den Zieldatensatz feinabstimmen. Der Stand der Technik bei Multi-Task-Feinabstimmung heißt MTDNN. Bei MTDNN werden die Anzahl der Aufgaben in der Trainingssache beibehalten. In diesem Beispiel gibt es vier Aufgaben in der Trainingssache. Also führt MTDNN vier Köpfe ein, die aus dem Trainingssache ausgewählt werden. Und wenn die zufällige Charge aus der Trainingssache zu einer einzelnen Satzklassifizierungsaufgabe gehört, wird sie durch den ersten Kopf ausgeführt. Und wenn die zufällige Charge zu einer Paarwörter-Ranking-Aufgabe gehört, wird sie durch den letzten Kopf ausgeführt. In unserem Szenario, in dem tabellarische Datensätze die Anzahl der Klassen variieren, führt MTDNN die Anzahl der Klassen, Köpfe, Ausgabeschichten und zusätzlich eine neue Kopf für eine neue Aufgabe mit einem neuen Datensatz ein. Unser Ansatz, genannt taskreformulierte Feinabstimmung, führt in unserer Aufgabe die Aufgabe von der Klassifizierung des Textes in zwei Klassen in die Klassifizierung des Textes, des Abstracts und der Klasse in True oder False um. Also trainieren wir das Sprachmodell, um den Abstract in die Klasse zu klassifizieren, um zu bestimmen, ob der Abstract zur Klasse gehört oder nicht. Der Labelvektor in Xs Fall besteht immer aus zwei Klassen. Und dies ist der Algorithmus für unsere reformulierte Feinabstimmungsansatz. Also führen wir die gesamte Framework, einen Datensatz ein, führen die Entitätserkennungphase aus, extrahieren den Text aus der Wissensdatenbank, der in diesem Beispiel die Wikipedia-Überschrift ist, reformulieren die Aufgabe in eine Satzklassifizierungsaufgabe, wenden das Sprachmodell auf den neuen Task an und berechnen die Wahrscheinlichkeit für jede Klasse. Und notieren, dass das Sprachmodell bereits über n-1 Datensätze mit einer vorläufigen Multi-Task-Feinabstimmung feinabgestimmt wurde. Dann verwenden wir den Outputvektor des Sprachmodells als neu generierte Merkmalsvektor in der Anzahl der Klassen. Um unsere Framework zu bewerten, verwenden wir einen 17 tabellarischen Klassifizierungsdatensatz, der in Größe, Features, Balance und anfänglicher Leistung variiert. Und als Wissensdatenbank verwenden wir Wikipedia. Wir entwerfen unsere Experiment, indem wir FIST über 16 Datensätze trainieren und auf den 17. Datensatz anwenden. Wir teilen auch jeden Datensatz in eine Folds- und eine Crossvalidierung auf. Dann generieren wir die neuen Merkmale und bewerten sie mit fünf Klassifizierungsalgorithmen. Wir verwenden in unserem Experiment eine architektonische Basis. Hier sind die Ergebnisse für unser Experiment. Sie können sehen, dass wir unser Framework mit der Zieldatensatzfeinabstimmung, der Zielaufgabenfeinabstimmung und der MTDNN-Vorabstimmungsfeinabstimmung vergleichen. Unser Ansatz erreicht die beste Leistung, die beste Leistung. Während MTDNN zwei Prozent Verbesserung gegenüber der Zieldatensatzfeinabstimmung erreicht, erreicht unser Ansatz sechs Prozent Verbesserung. Wenn wir uns die kleinen Datensätze ansehen, können wir sehen, dass die Leistung von MTDNN abnimmt. Und die Verbesserung der vorläufigen Multi-Task-Feinabstimmungsphase abnimmt auf 1,5 Prozent. Aber unsere Leistung steigt im Vergleich zur Zielaufgabenfeinabstimmung um 11 Prozent. Für Summen ermöglicht FIST few-shot-Erweiterung. In unserem Experiment verwenden wir 35 Proben. Es verwendet eine Architektur für alle Aufgaben, Datensätze und behält die Modellkopfhöhe bei. Aber es fügt eine Reformulierungsphase hinzu, es erweitert das Trainingssache und benötigt einen Zielwert mit semantischer Bedeutung, damit wir ihn in das Sprachmodell einfügen und in der Satzpaarklassifizierungsaufgabe verwenden können. Vielen Dank."}
{"dataset_id": "acl_6060", "sample_id": 417, "src_lang": "en", "tgt_lang": "de", "output": "Hallo zusammen, heute werde ich unsere Forschungsarbeit vorstellen, die das Erlernen der deduktiven Beweisführung als komplexe rationale Extraktion darstellt. Ich bin Alan von Bytedance AI Lab, und dies ist eine gemeinsame Arbeit mit Cheryle von der University of Texas at Austin und Wei Luo von SUTD. Zunächst möchte ich über unsere Motivation für das Denken sprechen. Hier zeigen wir Beispiele, in denen multistep thinking hilfreich ist. In diesem Bild ist es aus dem Paper, in dem sie prompt to solve the math problem in a few-shot learning scenario. Auf der linken Seite können wir sehen, wenn wir einige Beispiele mit nur Fragen und Antworten geben, können wir die richtigen Antworten nicht erhalten. Aber wenn wir mehr reasoning description geben, ist das Modell in der Lage, die reasoning description vorherzusagen und auch die richtige Vorhersage hier zu machen. Es ist also gut, interpretierbare multistep reasoning als output zu haben. Und wir denken, dass method problem eine einfache Anwendung ist, um solche reasoning abilities zu evaluieren. In unserer Problemaufstellung müssen wir die Fragen lösen und die numerischen Antworten erhalten. In unseren Datensätzen werden uns auch die mathematischen Ausdrücke gegeben, die zu dieser bestimmten Antwort führen. So gelten bestimmte Annahmen auch. Wir gehen davon aus, dass die Präzision der Zahlen bekannt ist. Und wir betrachten nur grundlegende Operatoren wie Addition, Subtraktion, Multiplikation, Division und Exponential. Darüber hinaus können komplexe Operatoren in diese grundlegenden Operatoren zerlegt werden. So kann frühere Arbeit in method problem in die Kategorien sequence to sequence und sequence to tree model einordnen. In traditionellen sequence to sequence-Modellen wird der Ausdruck in eine bestimmte Sequenz für die Generierung umgewandelt. Und es ist ziemlich einfach zu implementieren. Und es kann sich auf viele komplizierte Probleme verallgemeinern. Aber die Leistung ist im Allgemeinen nicht besser als die Strukturmodell. Und es fehlt an interpretierbarer Vorhersage. Aber diese Richtung ist immer noch ziemlich beliebt wegen des Transformer-Modells. In tree-basierten Modellen strukturieren wir diese Ausdrücke in einer Baumform und folgen einer vorbestimmten Traversal in Baumgenerationen. Hier generieren wir also die Operatoren und bis wir die Blätter, die die Quantitäten sind, kommen. Hier ist das Gute, dass es tatsächlich diese binäre Baumstruktur gibt. Und es ist ziemlich kontextuell, weil wir zuerst den Operator generieren und dann am Ende die Quantitäten generieren. Und die zweite Sache ist, dass es auch einige wiederholte Berechnungen enthält. So hier, in diesem Ausdruck, a mal 3 plus 3, wird tatsächlich zweimal generiert. Aber eigentlich sollten wir die Ergebnisse wiederverwenden. In unserer vorgeschlagenen Methode wollen wir diese Probleme in einem schrittweisen und interpretierbaren Weg lösen. So, zum Beispiel hier in der zweiten Stufe, können wir diese Divisoren erhalten, die 27 sind. Und wir können auf die ursprünglichen Fragen zurückgreifen, um die relevanten Inhalte zu finden. Und in diesen Schritten erhalten wir tatsächlich die Quotienten. Und nach diesen drei Schritten können wir tatsächlich die Ergebnisse der vierten Stufe erhalten. Und dann können wir die Dividenden erhalten. Hier generieren wir also den gesamten Ausdruck direkt, anstatt einzelne Operatoren oder Quantitäten zu generieren. So macht der Prozess genauer. In unserem deduktiven System beginnen wir mit einer Reihe von Quantitäten, die in den Fragen präsentiert werden, und auch einige Konstanten als unsere initialen Zustände. Der Ausdruck wird durch ei, j, op dargestellt, wobei wir einen Operator von qi zu qj durchführen. Und dieser Ausdruck ist tatsächlich gerichtet. Hier haben wir auch eine Subtraktion mit vor, um die entgegengesetzte Richtung darzustellen. So in einem formalen deduktiven System, zu einem Zeitpunkt t, wenden wir den Operator zwischen den QI und QJ-Paaren an. Und dann erhalten wir diese neuen Ausdrücke, die wir zu den nächsten Zuständen hinzufügen, um eine neue Menge zu erhalten. So visualisieren diese Folien die Entwicklung der Zustände, bei der wir den Ausdruck zu den aktuellen Zuständen hinzufügen. In unseren Modellimplementierungen verwenden wir zuerst ein vortrainiertes Modell, das kann birds oder roberta sein. Und dann kodieren wir den Satz und dann erhalten wir diese quantitativen Darstellungen. Sobald wir die quantitativen Darstellungen erhalten, können wir mit der Inferenz beginnen. Hier zeigen wir ein Beispiel, um die Darstellung für Q1 zu erhalten, geteilt durch Q2 und dann multipliziert mit Q3. Zuerst erhalten wir die Paardarstellung, was im Grunde nur die Konkatentation zwischen Q1 und Q2 ist. Und dann wenden wir ein Feedforward-Netzwerk an, das durch den Operator parametrisiert ist. Und dann erhalten wir die Ausdrucksdarstellung, Q1 geteilt durch Q2. Aber in der Praxis können wir in der Inferenzphase auch die falsche Ausdrucksdarstellung erhalten. Hier sind alle möglichen Ausdrücke gleich 3 mal der Anzahl der Operatoren. Das Gute hier ist, dass wir die Suchraum einfach kontrollieren können, um diese Suchraum zu kontrollieren. Zum Beispiel, wenn dieser Ausdruck nicht erlaubt ist, können wir diesen Ausdruck einfach aus unserem Suchraum entfernen. So machen wir in der zweiten Stufe dasselbe, aber die einzige Unterschied ist, dass die vorher berechnete Ausdruckung. Und schließlich erhalten wir diese endgültige Ausdrucksdarstellung, Q3 mal Q4. Und wir können auch sehen, dass die Anzahl der möglichen Ausdrücke von der vorherigen Stufe anders ist. So macht es es schwer, die Beam Search zu verwenden, weil die Wahrscheinlichkeit der Verteilung zwischen diesen beiden Stufen ungleich ist. So ist die Trainingsmethode ähnlich wie die Training eines sequence to sequence-Modells, bei dem wir den Verlust an jedem Zeitpunkt optimieren. Und hier verwenden wir tau, um den Zeitpunkt darzustellen, an dem wir diesen generativen Prozess beenden. Und hier ist der Raum anders, weil der Raum an jedem Zeitpunkt anders ist. Und es erlaubt uns auch, bestimmte Einschränkungen aus früheren Kenntnissen einzuführen. So führen wir Experimente mit den gängigen method problem Datensätzen durch, wie mawps, math 23k, math qa und swem. Und hier zeigen wir die Ergebnisse im Vergleich zu den bisherigen besten Ansätzen. Unsere beste Leistung ist roberta deduktive reasoner. Und wir verwenden nicht im Gegensatz zu den anderen Ansätzen die Beam Search. Die besten Ansätze sind oft tree-basierte Modelle. So ist unsere reasoner in der Lage, signifikant besser zu sein als diese tree-basierte Modelle. Aber wir können sehen, dass die absolute Zahl auf math qa oder swem nicht wirklich hoch ist. Also untersuchen wir die Ergebnisse auf swem. Und dieser Datensatz ist herausfordernd, weil der Autor versucht, dem NLP-Modell etwas hinzuzufügen, wie zum Beispiel die Hinzufügung von irrelevanten Informationen und zusätzlichen Quantitäten. So finden wir in unserer Vorhersage einige der Zwischenwerte, die tatsächlich negativ sind. Zum Beispiel, in diesen Fragen, fragen wir, wie viele Äpfel hat Jake? Aber wir haben einige zusätzliche Informationen, wie 17 weniger Beeren und Steven hat 8 Beeren, was völlig irrelevant ist. So macht unser Modell eine Vorhersage wie diese, die ist, die 35 multipliziert. Und wir beobachten, dass diese beiden Ausdrücke tatsächlich ähnliche Ergebnisse haben. So können wir diesen Suchraum tatsächlich einschränken, indem wir diese Ergebnisse negativ machen, so dass wir die Antwort korrekt machen können. So verbessern wir die Leistung einiger Modelle. Zum Beispiel, für birds, verbessern wir 7 Punkte. Und dann für die roberta-basierte Modell, verbessern wir 2 Punkte. Also hat die bessere Sprachmodell eine bessere Sprachverständnisfähigkeit. Also ist die Zahl hier für roberta höher und niedriger für birds. Und wir versuchen auch, die Schwierigkeit hinter all diesen Datensätzen zu analysieren. Wir gehen davon aus, dass die Anzahl der nicht verwendeten Quantitäten als irrelevant angesehen werden kann. So können wir die Prozentsätze der Sätze mit und ohne Quantitäten sehen. Und hier haben wir die größte Portion. Und hier zeigen wir auch die Gesamtleistung. Für die Sätze ohne Quantitäten ist die Gesamtleistung tatsächlich höher als die Gesamtleistung. Aber mit diesen Sätzen mit einer nicht verwendeten Quantität ist die Gesamtleistung tatsächlich viel schlechter als die Gesamtleistung. Für mawps haben wir nicht wirklich zu viele dieser Fälle, also ignorieren wir diesen Teil. So schließen wir unsere Arbeit ab. Zuerst ist unser Modell tatsächlich ziemlich effizient. Und wir sind in der Lage, interpretierbare Lösungen zu liefern. Und wir können einige priorielle Kenntnisse als Einschränkungen einbeziehen, was die Leistung verbessern kann. Und die zugrunde Mechanismus, der nicht nur für method problem solving tasks, sondern auch für andere Aufgaben, die multistep reasoning beinhalten, gilt. Aber wir haben auch einige Einschränkungen. Wenn wir eine große Anzahl von Operatoren oder Konstanten haben, kann der Speicherverbrauch ziemlich hoch sein. Und die zweite Sache ist, dass die Wahrscheinlichkeit der Verteilung zwischen den verschiedenen Zeitstufen ungleich ist. Also ist dies das Ende des Vortrags. Und Fragen sind willkommen. Vielen Dank."}
{"dataset_id": "acl_6060", "sample_id": 418, "src_lang": "en", "tgt_lang": "de", "output": "Hallo, ich bin Antoine und komme von der Universität Maastricht. Ich werde meine gemeinsame Arbeit mit Jerry vorstellen, die sich mit einem neuen Datensatz für die Ermittlung von Rechtsartikeln befasst. Rechtsfragen sind ein integraler Bestandteil des Lebens vieler Menschen, aber die Mehrheit der Bürger hat wenig bis gar keine Kenntnisse über ihre Rechte und grundlegenden Rechtsverfahren. Unsere Arbeit zielt darauf ab, die Kluft zwischen Menschen und dem Recht zu überbrücken, indem wir ein effektives Erfassenssystem für Rechtsartikel entwickeln. Ein solches System könnte eine kostenlose, professionelle Rechtsberatung für ungeschulte Menschen bieten. Bevor wir uns mit der Hauptleistung dieser Arbeit befassen, lassen Sie uns zunächst das Problem der Ermittlung von Rechtsartikeln beschreiben. Angesichts einer einfachen Frage zu einem Rechtsanliegen, wie z. B. \"Was ist mein Risiko, wenn ich vertrauliche Informationen missbrauche?\", ist ein Modell erforderlich, um alle relevanten Rechtsartikel aus einer großen Gesetzesdatenbank zu finden. Diese Informationsabrufaufgabe birgt ihre eigenen Herausforderungen. Erstens handelt es sich um zwei Arten von Sprache: die alltägliche Sprache für die Fragen und die komplexe Sprache der Rechtsartikel. Diese Unterschiede in der Sprachverteilung machen es für ein System schwieriger, relevante Kandidaten zu finden, da es eine Interpretation erfordert, die eine natürliche Frage in eine juristische Frage umwandelt, die der Terminologie der Rechtsartikel entspricht. Darüber hinaus ist das Gesetz kein Stapel unabhängiger Artikel, der als eigenständige Informationsquelle behandelt werden kann, wie Nachrichten oder Rezepte. Stattdessen ist es eine strukturierte Sammlung von Rechtsbestimmungen, die nur im Gesamtkontext, zusammen mit den angrenzenden Informationen, den Feldern und Unterkategorien, die sie zugeordnet sind, und ihrer Platzierung in der Gesetzesstruktur, einen ganzheitlichen Sinn haben. Schließlich sind Rechtsartikel in kurzen Paragraphen, die in der Regel die typische Erfassungsgröße in den meisten Erfassungsarbeiten sind. Sie sind lange Dokumente, die bis zu 6.000 Wörter lang sein können, wobei der längste bis zu 5.790 Wörter lang ist. Die jüngsten Fortschritte in der NLP haben großes Interesse an vielen Rechtsaufgaben wie Rechtsurteilungsvorhersage oder automatisierte Vertragsprüfung geweckt, aber die Ermittlung von Rechtsartikeln ist aufgrund des Mangels an großen, hochwertigen Label-Datensätzen weitgehend unberührt geblieben. In unserer Arbeit präsentieren wir einen neuen, französischsprachigen, bürgerzentrierten Datensatz, um zu untersuchen, inwieweit ein Erfassungsmodell die Effizienz und Zuverlässigkeit eines Rechtsfachmanns bei der Aufgabe der Ermittlung von Rechtsartikeln annähern kann. Unser belgisches Erfassungsdatensatz besteht aus mehr als 1.100 juristischen Fragen, die von belgischen Bürgern gestellt wurden. Diese Fragen decken eine breite Palette von Themen ab, von Familie, Wohnung, Geld bis hin zu Arbeit und Sozialversicherung. Jede der Fragen wurde von erfahrenen Juristen mit Verweisen auf relevante Artikel aus einem Korpus von mehr als 22.633 Rechtsartikeln aus den belgischen Rechtsordnungen gekennzeichnet. Lassen Sie uns nun darüber sprechen, wie wir diesen Datensatz erstellt haben. Zuerst haben wir eine große Korpus von Rechtsartikeln erstellt. Wir haben 32 öffentlich zugängliche belgische Rechtsordnungen berücksichtigt und alle ihre Artikel sowie die entsprechenden Abschnittsüberschriften extrahiert. Dann haben wir juristische Fragen mit Verweisen auf relevante Rechtsartikel gesammelt. Um dies zu tun, haben wir uns mit einem belgischen Anwaltsbüro zusammengetan, das jedes Jahr etwa 4.000 E-Mails von belgischen Bürgern erhält, die sich mit persönlichen Rechtsfragen befasst. Wir hatten das Glück, Zugang zu ihren Websites zu erhalten, auf denen ein Team von erfahrenen Juristen die häufigsten belgischen Rechtsfragen beantwortet. Wir sammelten Tausende von Fragen, die mit Kategorien, Unterkategorien und juristischen Verweisen zu relevanten Rechtsartikeln annotiert wurden. Schließlich haben wir die juristischen Verweise überprüft und die Fragen herausgesucht, deren Verweise nicht in einer der in Betracht gezogenen Rechtsordnungen enthalten sind. Die verbleibenden Verweise wurden mit den entsprechenden Artikel-IDs aus unserem großen Korpus abglichen. Am Ende haben wir 1.108 Fragen, die sorgfältig mit den IDs der relevanten Artikel aus unserem großen Korpus gekennzeichnet wurden. Darüber hinaus kommt jede Frage mit einer Hauptkategorie und einer Kette von Unterkategorien, und jeder Artikel kommt mit einer Kette von Unterkategorien in der Struktur des Gesetzes. Diese zusätzlichen Informationen werden in der aktuellen Arbeit nicht verwendet, aber könnten für zukünftige Forschung zu Rechtsinformationen oder Rechtsklassifizierung von Interesse sein. Schauen wir uns einige Merkmale unseres Datensatzes an. Die Fragen sind zwischen 5 und 44 Wörtern lang, mit einem Mittelwert von 40 Wörtern. Die Artikel sind viel länger, mit einem Mittelwert von 77 Wörtern, wobei 142 von ihnen mehr als 1.000 Wörter lang sind, wobei der längste bis zu 5.790 Wörter lang ist. Insgesamt decken die Fragen eine breite Palette von Themen ab, wobei etwa 85% von ihnen sich mit Familie, Wohnung, Geld oder Justiz befassen, während die verbleibenden 15% sich mit Sozialversicherung, Ausländern oder Arbeit befassen. Die Artikel stammen aus 32 verschiedenen belgischen Rechtsordnungen, die eine große Anzahl von Rechtsthemen abdecken. Hier ist die Gesamtzahl der Artikel, die aus diesen Rechtsordnungen extrahiert wurden. Von den 22.633 Artikeln werden nur 1.612 als relevant für mindestens eine Frage im Datensatz abgeleitet. Und rund 80% dieser zitierten Artikel stammen aus dem Zivilgesetzbuch, dem Gerichtsordnungsgesetz, dem Strafverfolgungs- und dem Strafgesetzbuch. In der Zwischenzeit beträgt die mittlere Anzahl der Zitate für diese zitierten Artikel 2, und weniger als 25% von ihnen werden mehr als fünfmal zitiert. Mit unserem Datensatz haben wir mehrere Erfassungsansätze getestet, einschließlich lexikalischer und dichterarchitektonischer Ansätze. Bei einer Abfrage in einem Artikel weist ein lexikalischer Ansatz eine Punktzahl für die Abfrage-Artikels-Paar zu, indem er die Summe der Gewichte jedes der Begriffe in diesem Artikel in dieser Abfrage berechnet. Wir experimentieren mit den Standard-TF-IDF- und BM25-Rang-Funktionen. Die Hauptprobleme mit diesen Ansätzen besteht darin, dass sie nur Artikel abrufen können, die Schlüsselwörter enthalten, die in der Abfrage vorkommen. Um dieses Problem zu überwinden, experimentieren wir mit einem neuronalen Architekturansatz, der die semantische Beziehung zwischen Abfrage und Artikel erfassen kann. Wir verwenden einen B-Encoder, der Abfrage und Artikel in eine gemeinsame Dichtevektordarstellung abbildet und eine Relevanz zwischen Abfrage-Artikels-Paar durch die Ähnlichkeit ihrer Embeddings berechnet. Diese Embeddings resultieren in der Regel aus einer Pooling-Operation auf die Ausgabe eines Wort-Embedding-Modells. Zuerst untersuchen wir die Effektivität von Siamese B-Encoders in einem Zero-Shot-Evaluierungs-Setup, was bedeutet, dass vortrainierte Wort-Encoder ohne zusätzliche Feinabstimmung verwendet werden. Wir experimentieren mit dem Kontextunabhängigen Text-Encoder, nämlich Word2Vec und FastText, und dem Kontextabhängigen Embedding-Modell, nämlich Roberta und speziell Kamembert, das ein französisches Roberta-Modell ist. Darüber hinaus trainieren wir unsere eigenen B-Encoder auf unseren Datensätzen. Beachten Sie, dass wir für die Training experimentieren mit zwei Varianten des B-Encoder-Architektur, Siamese, die eine einzigartige Wort-Encoder-Modelle verwendet, die Abfrage und Artikel in einer gemeinsamen Dichtevektor-Darstellung abbildet, und zwei-Tower, die zwei unabhängige Wort-Encoder verwendet, die Abfrage und Artikel in zwei separate Embedding-Räume abbilden. Wir experimentieren mit Mean, Max und CLS-Pooling sowie Punktprodukt und Kosinus für die Berechnung der Ähnlichkeit. Hier sind die Ergebnisse unseres Basispunkts auf den Testsets, mit den lexikalischen Methoden oben, den Siamese B-Encoders in einem Zero-Shot-Setup in der Mitte und den feinabgestellten B-Encoders unten. Insgesamt übertrifft der feinabgestellte B-Encoder alle anderen Basispunkte, die zwei-Tower-Modelle verbessern sich bei der Erholung, aber die Leistung zeigt, dass es immer noch ein starkes Basispunkt für domänenspezifische Erfassungen ist. Die Ergebnisse des Zero-Shot-Evaluierungs-Setups der Siamese B-Encoders zeigen, dass der direkte Einsatz der Embeddings eines vortrainierten Kamembert-Modells ohne Optimierung für die Informationsabrufaufgabe schlechte Ergebnisse liefert, was mit früheren Ergebnissen übereinstimmt. Darüber hinaus beobachten wir, dass der Word2Vec-basierte B-Encoder deutlich die Fast-Text- und B-Encoder-Modelle übertrifft, was darauf hindeutet, dass möglicherweise vortrainierte Wort-Encoder für die Aufgabe des Informationsabrufs besser geeignet sind als Zeichen- oder Unterwort-Embeddings, wenn sie aus der Box verwendet werden. Obwohl diese Ergebnisse vielversprechend sind, deuten sie auf eine große Möglichkeit für Verbesserungen hin, im Vergleich zu einem Fachjuristen, der schließlich alle relevanten Artikel zu jeder Frage abrufen und perfekte Ergebnisse erzielen kann. Schließen wir mit einer Diskussion über zwei Einschränkungen unseres Datensatzes. Erstens ist der Korpus der Artikel auf die 32 in Betracht genommenen belgischen Codes beschränkt, was bedeutet, dass Artikel aus Verordnungen, Verordnungen und Verordnungen nicht berücksichtigt werden. Während der Datensatz erstellt, werden alle Verweise auf diese nicht in Betracht gezogenen Artikel ignoriert, was dazu führt, dass einige Fragen nur einen Bruchteil der ursprünglichen Anzahl der relevanten Artikel erhalten. Dies impliziert, dass die Antwort, die in den verbleibenden relevanten Artikeln enthalten ist, möglicherweise unvollständig ist, obwohl sie immer noch vollständig angemessen ist. Zweitens können nicht alle Rechtsfragen mit Statuten allein beantwortet werden. Zum Beispiel kann die Frage \"Kann ich meine Mieterin oder meinen Mieter wegen zu viel Lärm vertreiben?\" möglicherweise keine detaillierte Antwort in der Rechtsordnung haben, die eine bestimmte Lärmgrenzeilung festlegt. Stattdessen sollte das Mietrecht eher auf Präzedenzfall und Präzedenzfall basieren, z. B. Die Mieterin macht zwei Partys pro Woche bis 2:00 Uhr. Daher müssen einige Fragen besser zu der Aufgabe der Ermittlung von Rechtsartikeln geeignet sein als andere, und die Domäne der weniger geeigneten Fragen muss noch bestimmt werden. Wir hoffen, dass unsere Arbeit das Interesse an der Entwicklung praktischer und zuverlässiger Erfassungsmodelle weckt, die den Zugang zu Gerechtigkeit für alle verbessern. Sie können unseren Artikel und Code unter den folgenden Links finden. Vielen Dank."}
{"dataset_id": "acl_6060", "sample_id": 419, "src_lang": "en", "tgt_lang": "de", "output": "Hallo, wir präsentieren unsere Arbeit an Valsa, einem taskunabhängigen Benchmark, der visuelle und sprachbezogene Modelle mit bestimmten linguistischen Phänomenen testet. Warum haben wir uns die Mühe gemacht, diesen Benchmark einzurichten? Nun, in den letzten Jahren haben wir eine Explosion von vision- und sprachbasierten Modellen gesehen, die auf großen Mengen von Bildtextpaaren trainiert sind. Jedes dieser Modelle ist in der Lage, visuelle und sprachbezogene Aufgaben wie visuelle Fragebeantwortung, visuelles Common-Sense-Argument, Bildwiederherstellung, Phrase-Basierend und mehr zu bewältigen. Die Genauigkeiten auf diesen spezifischen Benchmarks steigen stetig. Aber wissen wir, was die Modelle tatsächlich gelernt haben? Was versteht ein visuelle und sprachbezogener Transformer, wenn er ein hohes Ergebnis für dieses Bild und dieses Satzpaar und ein niedriges Ergebnis für dieses Bild und dieses Satzpaar zuweisen kann? Fokussieren sich visuelle und sprachbezogene Modelle auf das Richtige oder auf Vorurteile, wie in früheren Arbeiten gezeigt? Um Licht auf diese Aspekte zu werfen, schlagen wir einen mehr taskagnostischen Ansatz vor und führen Valsa ein, der die Sensitivität von visuellen und sprachbezogenen Modellen für spezifische linguistische Phänomene testet, die sowohl die sprachliche als auch die visuelle Modalität betreffen. Wir zielen auf Existenz, Pluralität, Zählung, räumliche Beziehungen, Handlungen und Entitätsreferenz ab. Aber wie testen wir, ob die visuellen und sprachbezogenen Modelle diese Phänomene erfasst haben? Durch Foiling, ein Verfahren, das zuvor nur für nicht-Substantivphrasen von Ravi Shankar und Mitarbeitern und auf Zählung von uns in früheren Arbeiten angewendet wurde, bedeutet Foiling im Grunde, dass wir die Bildunterschrift nehmen und eine Fälschung erzeugen, indem wir die Unterschrift so ändern, dass sie das Bild nicht mehr beschreibt. Und wir machen diese Phrasenänderungen, indem wir uns auf sechs spezifische Teile konzentrieren, wie Existenz, Pluralität, Zählung, räumliche Beziehungen, Handlungen und Entitätsreferenz, wobei jeder Teil aus einem oder mehreren Instrumenten bestehen kann, falls wir mehr als einen interessanten Weg gefunden haben, um Fälschungen zu erstellen. Zum Beispiel haben wir im Fall der Handlungsinstrumente zwei Instrumente, eines, in dem das Handlungsverb mit einem anderen Handlungsverb ersetzt wird, und eines, in dem Subjekte vertauscht werden. Zählung und Referenz sind auch Teile, die mehr als ein Instrument haben. Und wir erstellen diese Fälschungen, indem wir sicherstellen, dass sie das Bild nicht mehr beschreiben, dass sie grammatikalisch und ansonsten gültige Sätze sind. Dies ist nicht einfach zu tun, da es statistisch weniger wahrscheinlich ist, dass Pflanzen einen Mann schneiden, als dass ein Mann Pflanzen schneidet. Und große visuelle und sprachbezogene Modelle könnten dies aufspüren. Um gültige Fälschungen zu erhalten, nutzen wir starke Sprachmodelle, um Fälschungen vorzuschlagen. Zweitens verwenden wir natürliche Sprachinferenz, oder kurz NLP, um Fälschungen zu filtern, die das Bild noch beschreiben könnten, da wir bei der Erstellung von Fälschungen sicherstellen müssen, dass sie das Bild nicht mehr beschreiben. Wenn ein NLP-Modell die Fälschung mit der Unterschrift des Bildes widerspricht oder neutral ist, nehmen wir dies als Indikator für eine gute Fälschung. Wenn ein NLP-Modell die Fälschung mit der Unterschrift des Bildes widerspricht oder neutral ist, kann dies ein Indikator für eine gute Fälschung sein. Aber dieses Verfahren ist nicht perfekt, es ist nur ein Indikator für gültige Fälschungen. Daher verwenden wir als drittes Maß zur Generierung gültiger Fälschungen, um menschliche Annotatoren zu verwenden, um die Daten in Valsa zu validieren. Nach der Filterung und der menschlichen Bewertung haben wir so viele Testinstanzen, wie in dieser Tabelle beschrieben. Beachten Sie, dass Valsa keine Trainingsdaten liefert, sondern nur Testdaten, da es ein Zero-Shot-Benchmark ist. Es ist so konzipiert, dass es die vorhandenen Fähigkeiten von visuellen und sprachbezogenen Modellen nach der Voreinrichtung ausnutzt. Feinabstimmung würde es nur ermöglichen, dass Modelle Artefakte oder statistische Verzerrungen in den Daten ausnutzen. Und wir alle wissen, dass diese Modelle gerne betrügen und Abkürzungen nehmen, und da wir daran interessiert sind, zu bewerten, was die Modelle nach der Voreinrichtung gelernt haben, möchten wir die Fähigkeiten der visuellen und sprachbezogenen Modelle nach der Voreinrichtung bewerten. Wir testen Valsa mit fünf visuellen und sprachbezogenen Modellen, nämlich mit Clip, XLmert, Wilbert, Wilbert 12 in 1 und Visualbert. Zwei unserer wichtigsten Bewertungsmetriken sind die Genauigkeit der Modelle bei der Klassifizierung von Bild-Satz-Paaren in Beschreibungen und Fälschungen. Vielleicht noch relevanter für dieses Video zeigen wir unsere Permissive Metrik, die misst, ob der Bild-Satz-Alignment-Score für das richtige Bild-Satz-Paar größer ist als für das Fälschungspaar. Die Ergebnisse mit der Permissiven Genauigkeit werden hier gezeigt, und sie stimmen mit den Ergebnissen aus den anderen Metriken überein. Es ist bemerkenswert, wie Instrumente, die sich auf einzelne Objekte wie Existenz und Substantivphrasen konzentrieren, von Wilbert 12 in 1 fast gelöst werden, was zeigt, dass Modelle in der Lage sind, Objekte und ihre Präsenz in Bildern zu identifizieren. Aber keiner der verbleibenden Teile kann in unseren adversarischen Fälschungssettings zuverlässig gelöst werden. Wir sehen aus den Pluralität- und Zählungsinstrumenten, dass visuelle und sprachbezogene Modelle Schwierigkeiten haben, Verweise auf einzelne versus mehrere Objekte oder Zählungen in einem Bild zu unterscheiden. Das Relationselement zeigt, dass visuelle und sprachbezogene Modelle Schwierigkeiten haben, eine benannte räumliche Beziehung zwischen Objekten in einem Bild zu klassifizieren. Sie haben auch Schwierigkeiten, Handlungen zu unterscheiden und die Teilnehmer zu identifizieren, selbst wenn sie von Plausibilitätsverzerrungen unterstützt werden, wie wir in der Handlungsphase sehen. Aus dem Referenzselement herausfinden wir, dass es für visuelle und sprachbezogene Modelle schwierig ist, mehrere Verweise auf dasselbe Objekt in einem Bild mit Pronomen zu verfolgen. Als Sanitätsscheck und weil es ein interessantes Experiment ist, bewerten wir auch zwei textbasierte Modelle, GPT 1 und GPT 2, um zu bewerten, ob Valsa von diesen einseitigen Modellen gelöst werden kann, indem wir die Perplexität der richtigen und der Fälschung von Beschreibungen und die Vorhersage des Eintrags mit der niedrigsten Perplexität vergleichen. Und es ist interessant zu sehen, dass textbasierte GPT-Modelle in einigen Fällen die Plausibilität der Welt besser erfassen als visuelle und sprachbezogene Modelle. Zusammenfassend ist Valsa ein Benchmark, der die Linsen der linguistischen Konstrukte verwendet, um die visuelle und sprachbezogenen Modelle zu verbessern, indem sie ihre visuelle Verankerung bewerten. Unsere Experimente zeigen, dass visuelle und sprachbezogene Modelle Objekte und ihre Präsenz in Bildern gut identifizieren können, wie durch das Existenzstück gezeigt, aber Schwierigkeiten haben, ihre visuelle und sprachliche Abhängigkeit und Beziehungen in visuellen Szenen zu verankern, wenn sie gezwungen werden, sich an linguistische Indikatoren zu halten. Wir würden die Community wirklich ermutigen, Valsa zur Messung des Fortschritts in der Sprachverankerung mit visuellen und sprachbezogenen Modellen zu verwenden. Und Valsa könnte auch als indirekte Bewertung von Datensätzen verwendet werden, da Modelle vor und nach der Training oder Feinabstimmung bewertet werden können, um zu sehen, ob ein Datensatz die von Valsa getesteten Aspekte verbessert. Wenn Sie an Valsa interessiert sind, schauen Sie sich die Valsa-Daten auf Github an. Und wenn Sie Fragen haben, zögern Sie nicht, uns zu kontaktieren."}
{"dataset_id": "acl_6060", "sample_id": 420, "src_lang": "en", "tgt_lang": "de", "output": "Hello, my name is Kamisaka from the University of Tokyo. I will be presenting a paper entitled \"RNSUM: A Large Scale Dataset for Automatic Release Note Generation via Commit Log Summarization\". I will explain in this order. First, I will introduce the automatic release note generation that we are working on in this research. A release note is a technical document that summarizes the changes distributed with each release of a software product. The image shows the release notes for version 2.6.4 of the Juvia library. Release notes play an important role in open source development, but they are time-consuming to prepare manually. Therefore, it would be very useful to be able to automatically generate high-quality release notes. I will refer to two previous researches on automatic release note generation. The first is a system called Alana, released in 2014. It takes a rule-based approach, for example, using the change extractor to extract core differences, library changes, and document changes from the differences between releases, and finally combining them. The most notable feature of this system is the issue extractor in the upper right corner, which must be linked to the issue tracker and can only be applied to projects that use JIRA. In other words, it cannot be used for many projects on GitHub. The second is GriF, recently announced in 2020. It is available on the internet and can be installed via pip. This system has a simple learning-based text classification model and outputs one of four labels, such as features or bug fixes, for each input commit message. The image is a sample usage that returns a corrective or bug fixes label. GriF's training data is fairly small, about 5,000, and will be shown in the experiments described below. The performance of the text classification model is not high. I present two related researches, but there are problems of limited applicability and scarce data resources. Our paper solves these two problems and automatically generates high-quality release notes. For the limited applicability problem, we propose a high-quality class-based summarization method, using only commit messages as input. This proposed method can be used for all English repositories. For the second problem of scarce data resources, we built a rnsum dataset consisting of about 82,000 pieces of data by collecting data from public GitHub repositories using the GitHub API. Next, I describe our dataset. Here is an example of data, the left side is the commit message and the right side is the release note. The release notes are labeled as improvements, bug fixes, etc. We have set up a task that takes the commit messages as input and outputs the labeled release notes. This can be regarded as a summarization task. We have predefined four labels, features, improvements, bug fixes, duplications, removals, and breaking changes. These labels are set based on previous research and other factors. The release notes on the bottom right and extracted commit release notes shown on the bottom left. At this time, it is necessary to detect the four labels that have been set up in advance. But the labels are not always consistent with each repository. For example, the improvements label includes improvements, enhancements, optimizations, and so on. We prepared a vocabulary list of art study labels for each of these notational variations. Use it to detect the release note class and correct the text of the list that follows as the release note sentence for the class. Next is the commit message. Commit messages are not tied to each release. As shown in the image below, if the current release is version 2.5.19, we need to identify the previous release version 2.5.18 and get it diff. This is a bit tedious and it is not enough to just get a list of releases and look at the before and after. We created a heuristic matching rule to get the previous and next versions. Date set analysis. In the end, 7,200 repositories and 82,000 pieces of data were collected. Also, the average number of release note tokens is 63, which is quite high for a summarization task. Also, the number of unique tokens is quite large, at 8,830,000. This is due to the large number of class and method names found in the repository. Next, I explain the proposed method. The class-wise extractive then abstractive summarization model consists of two neural modules, a classifier using BERT or KoBERT, and a generator using BART. First, CEAS uses a classifier to classify each commit message into five release note classes, features, improvements, bug fixes, and others. The commit messages classified as others are discarded. Then, CEAS applies a generator to the four labeled documents independently and generates release notes for each class. In this task, the direct correspondences between commit messages and release notes are not known, therefore to train the classifier, classifier assigns pseudo labels to each input commit message using the first ten characters of each commit message. We model the class-wise abstractive summarization approach by two different methods. The first model, which we call CAS, consists of a single seq2seq network and generates a single long release note text given a concatenation of input commit messages. The output text can be divided into classified segments based on special class-specific endpoint symbols. The second method, which we call CSM, consists of four different seq2seq networks, each corresponding to one of the release note classes. Okay, let me explain the experiment. Five methods were compared, CEAS, CSING, CSM, clustering, and previous study GRIFF. Regarding evaluation, in some cases, release notes are output in multiple sentences. Since it is difficult to count the number of sentences, they are treated as one long sentence. The BLEU is penalized when the system outputs a short sentence. This penalty results in a lower BLEU value in the experiment results described next. Finally, we calculate the specificity because the BLEU and can not be calculated if the release notes are empty. A high specificity means that the model correctly outputs an empty text in cases where the release notes assume empty. Here are the results. Since the dataset contains email addresses, hash values, etc., we also evaluated the cleaned dataset, which excludes them. CEAS and CS achieved BLEU scores more than 10 points higher than the baselines. In particular, on the cleaned test set, the score gap between the proposed method and the baselines jumped to more than 20 points. These results indicate that CEAS and CS are significantly effective. CSAS got a better BLEU score than CSAS, suggesting that combining a classifier and a generator is effective and training the classifier using pseudo labels, a high coverage of CSAS can be achieved properly. CSAS much tended to be higher BLEU than CSAS, suggesting that it is also effective to independently develop different abstractive summarization models for each release note class. Here is an error analysis. CS methods tend to output shorter sentences than human reference sentences. In the figure on the right, the reference sentence has three or four sentences, while CS has only one. The reason for this smaller sentence length is that in the training data, only 33% of the sentences are present in the features label and 40% in the improvements label. Furthermore, CS methods cannot generate accurate release notes without additional information. The top example on the right is an example of a very messy commit message, and the complete sentence cannot be generated without reference to the corresponding pull request or issue. The example below shows the two commit messages in the input are related and should be combined into one sentence, but it fails to do so. Finally, a conclusion. We have built a new dataset for automatic release note generation. We have also formulated the task of entering commit messages and summarizing them so that it is applicable to all projects written in English. Our experiment shows that the proposed methods generate less noisy release notes at higher coverage than the baselines. Please check out our dataset on GitHub. Thank you."}
