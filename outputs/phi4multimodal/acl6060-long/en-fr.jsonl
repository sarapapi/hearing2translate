{"dataset_id": "acl_6060", "sample_id": 416, "src_lang": "en", "tgt_lang": "fr", "output": "Bonjour, je m'appelle Asaf Farhi et je présenterai notre article, enrichissement rapide des données tabulaires à l'aide d'architectures de transformateurs. Les scientifiques de données analysent et se concentrent principalement sur la manipulation des données, mais parfois ces fonctionnalités sont limitées. La génération de fonctionnalités à l'aide d'une autre source de données peut ajouter des informations substantielles. Notre objectif de recherche est l'enrichissement automatique des données tabulaires à l'aide de sources de texte externes. Supposons que nous ayons un ensemble de données tabulaires et une base de connaissances. Nous avons besoin d'un processus automatique qui implique l'intelligence et l'analyse de texte pour extraire de nouvelles fonctionnalités de la base de connaissances. Notre cadre, FIST, est exactement ce processus automatique. Voyons un exemple. Dans un ensemble de données alimenté par FIST, l'objectif est de classer les universités en universités de rangs inférieurs et supérieurs. En tant que base de connaissances, nous utilisons Wikipédia. La première phase de FIST est l'intelligence d'entité, lorsque chaque entité est liée à une entité au sein de la base de connaissances. Et le texte de l'entité de la base est extrait et ajouté à l'ensemble de données. Dans ce cas, le texte est l'abstract de la page Wikipédia. Maintenant, nous devons générer ou extraire des fonctionnalités à partir du texte du rétroviseur. Nous avons besoin d'une phase de génération de fonctionnalités qui inclut l'analyse de texte. C'est le principal atout de ce papier, et je plongerai plus en détail dans les prochaines diapositives. Après la phase de génération de fonctionnalités, il y a une phase de génération de fonctionnalités, où nous utilisons les fonctionnalités extraites pour générer un petit nombre de nouvelles fonctionnalités. FIST génère des fonctionnalités dans le nombre de classes de l'ensemble de données original. Dans ce cas, l'ensemble de données original a deux classes, donc FIST génère deux nouvelles fonctionnalités. Mais si l'ensemble de données original a cinq classes, FIST génère cinq nouvelles fonctionnalités. Chaque fonctionnalité représente la probabilité pour chaque classe. Pour analyser le texte, nous utilisons l'état de l'art de l'analyse de texte, qui est des modèles de langage basés sur les transformateurs, tels que BERT, GPT, XL, etc. Mais il est peu probable que nous puissions entraîner un modèle de langage à l'aide des ensembles de données d'entrée. Donc, un approche naïve sera une tâche de fine-tuning. Dans la phase de génération de fonctionnalités, nous utilisons le modèle de langue pré-entraîné, nous finitions le modèle de langue sur l'ensemble de données cible. Dans ce cas, pour classifier le texte en classes, abstrait en classes, bas ou haut, nous recevons le résultat du modèle de langue, qui est la probabilité pour chaque classe, et nous l'utilisons comme nouvelles fonctionnalités. Le problème avec cette approche est que l'ensemble de données peut avoir peu de textes distincts. Dans notre expérience, presque la moitié des ensembles de données contiennent moins de 400 échantillons, et le plus petit ensemble de données contient 35 échantillons. Donc, finituner un modèle de langue sur cet ensemble de données sera inefficace. Mais nous pouvons utiliser la connaissance pré-analyisée des ensembles de données. Puisque FIST est appliqué sur plusieurs ensembles de données, nous pouvons utiliser les ensembles de données n-1 pour recueillir des informations sur les ensembles de données n-1 et utiliser cette information lors de l'analyse de l'ensemble de données n. Ce que nous suggérons, c'est d'ajouter une autre phase de fine-tuning, une fine-tuning préliminaire multitâche, où nous finitions le modèle de langue sur les ensembles de données n-1. Et puis, nous exécutons une autre phase de fine-tuning, qui est une tâche de fine-tuning. Lorsque nous finitions le modèle de langue sur l'ensemble de données cible, le multi-tâche à l'état de l'art, appelé MTDNN, maintient un nombre de tâches dans l'ensemble de données d'entraînement. Donc, dans ce cas, il y a quatre tâches dans l'ensemble de données d'entraînement. Et il évalue le chemin de l'avant-dernière. Dans notre scénario, un ensemble de données tabulaires varie en nombre de classes. Donc, il y a de nombreuses tâches. MTDNN maintient un nombre de classes, de heads, de couches de sortie, et il doit initialiser de nouveaux heads pour un ensemble de données avec une nouvelle tâche. Notre approche, appelée fine-tuning par reformulation de la tâche, reformule chaque ensemble de données en un problème de classification de phrase. C'est un problème de deux classes. Donc, nous entraînons le modèle de langue à classer un texte, l'abstract, et la classe en true ou false. Ou, en d'autres termes, nous entraînons le modèle de langue à classer un abstract et une classe en true ou false."}
{"dataset_id": "acl_6060", "sample_id": 417, "src_lang": "en", "tgt_lang": "fr", "output": "Bonjour à tous. Aujourd'hui, je vais présenter notre travail de recherche, l'apprentissage à raisonner, résoudre les problèmes de mathématiques comme une extraction complexe de raisonnement. Je suis Alan de l'AI Lab, et ce est un travail conjoint avec Cheryle de l'Université de Texas à Austin et Wei de l'Université de Stanford. D'abord, j'aimerais parler de notre motivation pour le raisonnement. Donc, ici, nous montrons des exemples où le raisonnement multistap est utile. Donc, cette figure est prise du papier de Pal, où ils font des exemples pour résoudre le problème de mathématiques dans un scénario d'apprentissage en flux. Donc, sur le côté gauche, nous pouvons voir si nous donnons quelques exemples avec des questions et des réponses, nous ne pourrons pas obtenir les bonnes réponses. Mais si nous donnons plus de description de raisonnement, le modèle est capable de prédire la description de raisonnement et de faire une prédiction correcte. Donc, il est bon d'avoir des prédictions interprétables et multistap. Et nous pensons que le problème de mathématiques est une application simple pour évaluer de telles capacités de raisonnement. Donc, dans notre configuration de problème, étant donné les questions, nous devons résoudre ces questions et obtenir les réponses numériques. Donc, dans nos ensembles de données, nous avons également les expressions mathématiques qui mènent à cette réponse particulière. Donc, certaines hypothèses s'appliquent également, comme dans le travail précédent. Nous supposons que la précision des quantités est connue, et nous considérons seulement des opérateurs de base tels que l'addition, la soustraction, la multiplication, la division et l'exponentielle. De plus, les opérateurs complexes peuvent être décomposés en ces opérateurs de base. Donc, le travail précédent en résolution de problèmes de mathématiques peut être classé en modèles séquence à séquence et séquence à arbre. Donc, les modèles traditionnels séquence à séquence convertissent l'expression en une séquence spécifique pour la génération. Et c'est assez facile à implémenter. Et il peut généraliser à de nombreux problèmes complexes. Mais les inconvénients sont que les performances ne sont généralement pas meilleures que les modèles structurels. Et il manque d'interprétabilité pour la prédiction. Mais en fait, cette direction est encore très populaire en raison des modèles de transformateurs. Donc, dans les modèles basés sur les arbres, nous structurons ces expressions en forme d'arbre et suivons une génération d'arbre pré-ordonnée. Donc, ici, nous générons les opérateurs, et nous atteignons les feuilles, qui sont les quantités. Donc, la bonne chose est que nous générons en fait l'expression entière, plutôt que de générer des opérateurs ou des quantités individuelles. Donc, ce qui rend le processus plus précis. Donc, dans notre système de déduction, nous commençons avec un groupe de quantités présentées dans les questions, et aussi, incluant certains constantes comme nos états initiaux. Donc, l'expression est représentée par Eijop, où nous effectuons l'opérateur de QI à QJ. Et cette expression est en fait dirigée. Donc, nous avons aussi une soustraction inverse ici pour représenter l'opération opposée. Donc, dans un système de déduction formel, à un temps t, nous appliquons l'opérateur entre les paires QI et QJ. Et puis nous obtenons cette nouvelle expression. Nous l'ajoutons aux états suivants pour devenir un nouveau quantitatif. Donc, ces diapositives visualisent l'évolution de ces états, où nous ajoutons des expressions aux états actuels. Donc, dans nos implémentations, nous utilisons d'abord un modèle de langage pré-entraîné, qui peut être birds ou roberta. Et puis nous codons une phrase, et puis nous obtenons ces représentations de quantités. Donc, une fois que nous obtenons les représentations de quantités, nous pouvons commencer à faire des inférences. Donc, nous montrons un exemple de Q1 pour obtenir la représentation de Q1 divisé par Q2 et multiplié par Q3. D'abord, nous obtenons la paire de représentations, qui est simplement la concaténation entre Q1 et Q2. Et puis nous appliquons un réseau de feedback, qui est paramétrisé par l'opérateur. Et puis nous obtenons la représentation de l'expression, Q1 divisé par Q2. Mais en pratique, dans la phase d'inférence, nous pourrions être en mesure d'obtenir une expression incorrecte aussi. Donc, ici, tous les expressions possibles sont égales à trois fois le nombre d'opérateurs. Donc, la bonne chose ici est que nous pouvons facilement ajouter des contraintes pour contrôler ce espace de recherche. Donc, dans la deuxième étape, nous faisons la même chose, mais la seule différence est qu'il y a une quantité supplémentaire. Donc, cette quantité vient de l'expression calculée précédemment. Donc, enfin, nous pouvons obtenir cette expression finale, Q3 multiplié par Q4. Et nous pouvons également voir le nombre d'expressions possibles différentes de la précédente. Donc, de cette différence, il est difficile d'appliquer une stratégie de recherche de bande. Donc, le processus d'entraînement est similaire à l'entraînement d'un modèle séquence à séquence, où nous optimisons la perte à chaque étape. Et ici, nous utilisons cette tau pour représenter quand nous terminons ce processus de génération. Et ici, l'espace est différent du modèle séquence à séquence, parce que l'espace est différent à chaque étape, tandis que dans les modèles traditionnels séquence à séquence, c'est le nombre de vocabulaire. Et cela permet également d'imposer certaines contraintes de connaissances précédentes. Donc, nous conduisons des expériences sur les ensembles de données de mathématiques couramment utilisés, MATH, WPS, MATH23K, MATHQA et SWAMP. Et ici, nous montrons brièvement les résultats par rapport aux approches précédentes. Donc, notre meilleur modèle de performance est le Roberta Deductive Reasoner. Et en fait, nous n'utilisons pas de recherche de bande en contraste. Donc, les meilleures approches sont souvent des modèles basés sur les arbres. Donc, notre raison est capable de surpasser de manière significative ces modèles basés sur les arbres. Mais nous pouvons voir que le nombre absolu sur MATHQA ou SWAMP n'est pas vraiment élevé. Donc, nous investiguons davantage les résultats sur SWAMP. Et ce jeu de données est difficile parce que l'auteur essaie de confondre le modèle NLP en ajoutant des informations et des quantités supplémentaires. Donc, dans nos prédictions, nous trouvons certains des valeurs intermédiaires négatives. Donc, dans ces questions, nous demandons combien d'appels a Jake, mais nous avons des informations supplémentaires, comme 17, moins quelques poires, et Steven a 8 poires, ce qui est totalement inintégré. Donc, notre modèle fait des prédictions comme ces, qui est en fait produire des valeurs négatives. Et nous observons ces deux expressions ont en fait des scores similaires. Donc, nous pouvons en fait limiter cet espace de recherche en supprimant ces résultats négatifs, de sorte que nous pouvons obtenir la réponse correcte. Donc, nous trouvons que ces contraintes améliorent considérablement pour certains modèles. Donc, pour les modèles de birds, nous améliorons 7 points. Et ensuite, pour le modèle Roberta, nous améliorons 2 points. Donc, les modèles de langage plus bons ont une meilleure capacité de compréhension du langage. Donc, le nombre ici est plus élevé pour Roberta et plus bas pour birds. Et nous essayons également d'analyser la difficulté derrière tous ces ensembles de données. Donc, nous supposons que le nombre de quantités inutilisées peut être considéré comme une information inintégré. Donc, ici, nous avons le pourcentage de ces échantillons avec des quantités inutilisées. Et le SWAMP a la plus grande proportion. Et ici, nous montrons également la performance globale. Donc, pour ceux des échantillons sans quantités inutilisées, la performance est en fait plus élevée que la performance globale. Mais avec ceux des échantillons avec des quantités inutilisées, c'est en fait beaucoup pire que la performance globale. Donc, pour MAWPS, nous n'avons pas vraiment trop de cas de disette, donc je peux ignorer cette partie. Donc, en fin de compte, nous voulons montrer l'interprétabilité à travers un exemple de question et de prédiction. Donc, notre modèle fait en fait une prédiction incorrecte à la première étape. Donc, nous pouvons corréler cette expression avec la phrase ici. Donc, nous pensons que cette phrase pourrait être trompeuse pour le modèle et conduire à des prédictions incorrectes. Donc, nous essayons de reformuler la phrase pour être quelque chose comme, le nombre d'arbres de paires est 35 de moins que les arbres d'arbres. Donc, nous faisons en sorte que la phrase transmet des significations plus précises, de sorte que le modèle est capable de faire la prédiction correcte. Donc, cette étude montre comment les prédictions interprétables nous aident à comprendre le comportement du modèle. Donc, pour conclure notre travail, d'abord, notre modèle est en fait assez efficace, et nous sommes en mesure de fournir des solutions interprétables. Et nous pouvons facilement incorporer certaines connaissances comme contraintes, ce qui peut aider à améliorer les performances. Et la dernière chose est que le mécanisme ne s'applique pas seulement aux tâches de résolution de problèmes de mathématiques, mais aussi à d'autres tâches impliquant un raisonnement multistap. Mais nous avons aussi certaines limitations. Si nous avons un grand nombre d'opérateurs ou de constantes, la consommation de mémoire pourrait être assez élevée. Et la deuxième chose est que, comme mentionné, la probabilité de distribution est inégale à chaque étape. Donc, il est également difficile d'appliquer une stratégie de recherche de bande. Donc, c'est la fin de la présentation. Et les questions sont les bienvenues. Merci."}
{"dataset_id": "acl_6060", "sample_id": 418, "src_lang": "en", "tgt_lang": "fr", "output": "Bonjour, je m'appelle Antoine et je suis de l'Université de Maastricht. Je vais présenter mon travail conjoint avec Gerry, qui porte sur un nouveau ensemble de données pour la récupération d'articles juridiques. Les questions juridiques sont un élément intégral de la vie de beaucoup de gens, mais la majorité des citoyens n'ont pas de connaissance de leurs droits et des procédures juridiques. En conséquence, de nombreux citoyens vulnérables qui ne peuvent pas se permettre l'assistance d'un avocat sont laissés sans protection ou, pire, exploités. Notre travail vise à combler le fossé entre les gens et la loi en développant un système de récupération efficace pour les articles juridiques. Un tel système pourrait fournir un service juridique gratuit et professionnel pour les humains peu qualifiés. Avant de plonger dans la contribution principale de ce travail, décrivons d'abord le problème de la récupération d'articles juridiques. En fonction d'une simple question sur un sujet juridique, comme : \"Quelles sont les conséquences si je viole la confidentialité professionnelle ?\" Un modèle est requis pour récupérer tous les articles juridiques pertinents d'un large corpus de législation. Cette tâche d'extraction d'informations comporte ses propres défis. D'abord, il s'agit de deux types de langage : le langage naturel commun pour les questions et le langage juridique complexe pour les articles. Cette différence de distribution de langage rend plus difficile pour un système de récupérer des candidats, car il nécessite un système d'interprétation inhérent qui peut traduire une question naturelle en une question juridique qui correspond à la terminologie des articles. De plus, le droit n'est pas une série d'articles indépendants qui peuvent être traités comme une source d'information complète, comme les nouvelles ou les recettes, mais plutôt une collection structurée de dispositions juridiques qui ont un sens complet seulement lorsqu'elles sont considérées dans leur contexte global, c'est-à-dire avec les informations complémentaires de leurs articles voisins, des champs et des sous-catégories auxquels ils appartiennent, et de leur place dans la structure de la loi. Enfin, les articles juridiques sont des paragraphes, qui sont généralement le type de récupération dans la plupart des travaux de récupération. Ici, ils sont de longs documents pouvant atteindre jusqu'à 6 000 mots. Les avancées récentes en NLP ont suscité un grand intérêt pour de nombreuses tâches juridiques, telles que la prédiction de jugements juridiques ou la revue automatique des contrats. Mais la récupération d'articles juridiques a été principalement négligée en raison du manque d'ensembles de données étiquetés de grande taille et de haute qualité. Dans ce travail, nous présentons un nouvel ensemble de données, en français, centré sur les citoyens, pour étudier si un modèle de récupération peut approcher l'efficacité et la fiabilité d'un expert juridique pour la tâche de récupération d'articles juridiques. Notre ensemble de données de récupération d'articles juridiques (PZ) se compose de plus de 1 100 questions posées par des citoyens belges. Ces questions couvrent un large éventail de sujets, de la famille, de l'habitation, de l'argent, au travail et à la sécurité sociale. Chaque question a été étiquetée par des juristes expérimentés avec des références à des articles pertinents de plus de 22 633 articles de codes de loi. Examinons maintenant comment nous avons collecté cet ensemble de données. Tout d'abord, nous avons compilé un corpus de textes juridiques. Nous avons considéré 32 codes juridiques publics et extrait tous leurs articles ainsi que les titres de section correspondants. Ensuite, nous avons rassemblé des questions juridiques avec des références à des articles pertinents. Pour ce faire, nous avons collaboré avec un cabinet d'avocats belge qui reçoit chaque année environ 4 000 e-mails de citoyens belges qui demandent des conseils sur des questions juridiques personnelles. Nous avons eu la chance d'accéder à leurs sites web, où leur équipe d'experts juridiques aborde les questions juridiques les plus courantes en Belgique. Nous avons collecté des milliers de questions annotées avec des catégories, des sous-catégories et des références juridiques pertinentes. Enfin, nous avons passé les références juridiques et filtré les questions dont les références ne sont pas des articles dans l'un des codes de loi que nous avons considérés. Les références restantes ont été associées et converties en identifiants d'articles correspondants de notre corpus. Nous avons finalement terminé avec 1 108 questions, chacune soigneusement étiquetée avec les identifiants des articles correspondants de notre large corpus de 22 633 articles juridiques. De plus, chaque question comprend une catégorie principale et une concaténation de sous-catégories, et chaque article comprend une concaténation de leurs sous-titres dans la structure de la loi. Cette information supplémentaire n'est pas utilisée dans le travail actuel, mais pourrait être d'intérêt pour des recherches futures sur la récupération d'informations juridiques ou la classification juridique. Examinons quelques caractéristiques de nos ensembles de données. Les questions sont entre 5 et 44 mots de long, avec une moyenne de 40 mots. Les articles sont beaucoup plus longs, avec une longueur moyenne de 77 mots, avec 142 d'entre eux dépassant 1 000 mots, le plus long étant de 5 790 mots. En outre, les questions couvrent un large éventail de sujets, avec environ 85 % d'entre elles étant sur la famille, l'habitation, l'argent ou la justice, tandis que les 15 % restantes concernent la sécurité sociale, les étrangers ou le travail. Les articles sont également très divers, car ils proviennent de 32 différents codes belges qui couvrent un large nombre de sujets juridiques. Voici le nombre total d'articles collectés de chaque code. Outre les 22 633 articles, seulement 1 612 sont référencés comme pertinents à au moins une question dans les ensembles de données. Environ 80 % de ces articles cités proviennent du code civil, des codes judiciaires, des codes d'enquête criminelle ou des codes pénaux. Pendant ce temps, 18 des 32 codes ont moins de cinq articles mentionnés comme pertinents à au moins une question. Cela peut être expliqué par le fait que ces codes se concentrent moins sur les individus et leurs préoccupations. En général, le nombre moyen de citations pour ces articles cités est de 2, et moins de 25 % d'entre eux sont cités plus de cinq fois. En utilisant nos ensembles de données, nous avons évalué plusieurs approches de récupération, y compris des architectures lexicales et denses. En fonction d'une question et d'un article, un modèle lexical attribue une note au pair de question-article en calculant la somme sur la question des poids de chaque terme dans cet article. Nous expérimentons avec les fonctions de classement standard Tfidf et bm25. Le principal problème avec ces approches est qu'elles ne peuvent récupérer que des articles contenant des mots clés présents dans la question. Pour surmonter cette limitation, nous expérimentons avec une architecture basée sur le réseau neuronal qui peut capturer la relation sémantique entre les questions et les articles. Nous utilisons un modèle de bioncordeur qui mappe les questions et les articles dans un espace dense, et calcule une note de pair de question-article en fonction de la similarité de leurs embeddings. Ces embeddings résultent généralement d'une opération de pooling sur l'output d'un modèle d'embedding de mots. Tout d'abord, nous étudions l'efficacité des bioncordeurs en configuration de zéro shot, c'est-à-dire que les modèles d'embedding de mots prétrains sont appliqués sans aucune fine-tuning supplémentaire. Nous expérimentons avec un encodeur de texte indépendant du contexte, à savoir word2vec et fasttext, et avec des bioncordeurs basés sur le contexte, à savoir roberta et plus spécifiquement, camembert, qui est un modèle de bioncordeur en français. De plus, nous expérimentons avec deux architectures de bioncordeur basées sur le camembert, qui mappent les questions et les articles ensemble dans un espace dense partagé, et deux architectures de bioncordeur séparées, qui codent les questions et les articles dans des espaces d'embedding séparés. Nous expérimentons avec le pooling moyen, maximum et classé, ainsi que le produit de point et le cosinus pour calculer les similarités. Voici les résultats de notre ligne de base sur les ensembles de test, avec les méthodes lexicales ci-dessus, les bioncordeurs en français évalués en configuration de zéro shot au milieu, et les bioncordeurs finement ajustés en dessous. Globalement, les bioncordeurs finement ajustés surpassent toutes les autres lignes de base, les bioncordeurs deux-tours s'améliorant sur leurs variantes en français. Bien que bm25 sous-performe considérablement les bioncordeurs entraînés, ses performances indiquent qu'il est toujours un point de référence pour la récupération spécifique au domaine. En ce qui concerne l'évaluation de zéro shot des bioncordeurs en français, nous constatons que l'utilisation directe des embeddings d'un modèle de bioncordeur prétraité sans optimisation pour la tâche de récupération d'informations donne des résultats médiocres, ce qui est cohérent avec les résultats précédents. De plus, nous observons que le bioncordeur basé sur word2vec surpasse les bioncordeurs basés sur fasttext et camembert, suggérant que les embeddings de niveau de mot prétraités sont peut-être plus appropriés pour la tâche de récupération d'informations. Bien que ces résultats soient prometteurs, ils suggèrent de nombreuses opportunités d'amélioration par rapport à un expert juridique qui peut finalement récupérer tous les articles pertinents pour n'importe quelle question et ainsi obtenir des scores parfaits. Concluons en discutant de deux limitations de nos ensembles de données. Premièrement, le corpus d'articles est limité aux articles collectés des 32 codes juridiques considérés, qui ne couvrent pas l'ensemble du droit belge, car les articles des décrets, des directives et des ordonnances sont manquants. Pendant la construction de l'ensemble de données, toutes les références à ces articles non collectés sont ignorées, ce qui fait que certaines questions finissent par avoir seulement une fraction de leurs articles initialement pertinents. Cela signifie que la réponse contenue dans les articles restants peut être incomplète, bien qu'elle soit toujours complète. Deuxièmement, nous devons noter que toutes les questions juridiques ne peuvent pas être répondues avec des articles juridiques seuls. Par exemple, la question : \"Peux-je expulser mon locataire s'il fait trop de bruit ?\" ne peut pas avoir une réponse détaillée dans le droit qui quantifie un seuil spécifique de bruit à l'aide de l'expulsion. Au lieu de cela, le droit foncier devrait probablement se baser davantage sur le cas-law et trouver des précédents similaires à leur situation actuelle. Par exemple, le locataire fait deux parties par semaine jusqu'à 2 a.m. En effet, certaines questions sont mieux adaptées que d'autres à la tâche de récupération d'articles juridiques. Le domaine des moins appropriés reste à déterminer. Nous espérons que notre travail suscite l'intérêt pour développer des modèles de récupération d'articles juridiques pratiques et fiables qui peuvent améliorer l'accès à la justice pour tous. Vous pouvez consulter notre papier, ensemble de données et code à l'adresse suivante. Merci."}
{"dataset_id": "acl_6060", "sample_id": 419, "src_lang": "en", "tgt_lang": "fr", "output": "Bonjour. Nous présentons notre travail sur VAlues, un benchmark indépendant de la tâche destiné à tester les modèles visionnels et linguistiques avec des phénomènes linguistiques spécifiques. Pourquoi avons-nous mis en place ce benchmark ? Au cours des dernières années, nous avons observé une explosion de modèles visionnels et linguistiques basés sur les transformateurs pré-entraînés sur de grandes quantités d'images-textes. Chaque un de ces modèles pousse l'état de l'art sur les tâches spécifiques telles que la réponse visuelle, la compréhension visuelle, la récupération d'images, le soutien du langage, le raisonnement visuel, la référence d'entité, etc. Nous avons donc reçu un message : les exactitudes sur ces benchmarks spécifiques augmentent constamment. Mais savons-nous ce que les modèles ont réellement appris ? Qu'est-ce que les visionnels et les linguistiques ont compris lorsqu'ils ont attribué un score élevé à cette image et à cette phrase correspondante, et un score faible à une autre ? Se concentrent-ils sur le bon sujet, ou se concentrent-ils sur les biais, comme le montre le travail précédent ? Pour mieux éclairer cette question, nous proposons une approche plus agnostique et introduisons VAlues, qui teste la sensibilité des modèles visionnels et linguistiques à des phénomènes linguistiques qui affectent à la fois les modalités linguistiques et visuelles. Nous ciblons l'existence, la pluralité, le comptage, les relations spatiales, les actions et la référence d'entité. Mais comment tester si les modèles ont capturé ces phénomènes ? En utilisant le procédé de foiling, une méthode appliquée précédemment aux modèles visionnels et linguistiques uniquement pour les phrases non-verbales par Ravi Shekar et collaborateurs, et sur le comptage par nous dans le travail précédent. Foiling signifie que nous prenons la légende d'une image et produisons un foil en modifiant la légende de telle manière qu'elle ne décrit plus l'image. Et nous faisons ces altérations de phrases en nous concentrant sur six pièces spécifiques, telles que l'existence, la pluralité, le comptage, les relations spatiales, les actions et la référence d'entité, où chaque pièce peut consister en un ou plusieurs instruments. Par exemple, dans le cas des actions, nous avons deux instruments, l'un dans lequel le verbe de l'action est changé avec une action différente, et l'autre dans lequel les actants sont échangés. Le comptage et la référence d'entité ont également plus d'un instrument. Et nous créons ces foils en nous assurant qu'ils ne décrivent plus l'image, qu'ils sont des phrases grammaticales et valides. Ce n'est pas facile de le faire, car un foil peut être statistiquement moins probable que la légende originale. Par exemple, bien qu'il ne soit pas impossible, il est statistiquement moins probable que les plantes coupent un homme, que l'homme coupe les plantes. Les grands modèles visionnels et linguistiques pourraient capter cela. Par conséquent, pour obtenir des valides, nous prenons l'action. Premièrement, nous utilisons des modèles linguistiques forts pour proposer des foils. Deuxièmement, nous utilisons l'inférence naturelle, ou court-short, pour filtrer les foils qui pourraient encore décrire l'image, car lors de la construction des foils, nous devons nous assurer qu'ils ne décrivent plus l'image. Si un modèle d'inférence naturelle prédit le foil pour contredire ou être neutre par rapport à la légende, nous prenons cela comme un indicateur de valides. Si un modèle d'inférence naturelle prédit le foil pour être contredit ou neutre par rapport à la légende, cela ne peut pas être un bon foil, car, par transitivité, cela donnera une description vraie de l'image. Et nous filtrons ces foils. Mais ce processus n'est pas parfait, il est juste un indicateur de valides. Par conséquent, comme troisième mesure pour générer des valides, nous employons des annotateurs humains pour valider les données utilisées dans VAlues. Après le filtrage et l'évaluation humaine, nous avons autant d'instances de test que décrit dans cette table. Notez que VAlues ne fournit pas de données d'entraînement, mais seulement des données de test, car c'est un benchmark de zéro shot. Il est conçu pour tirer parti des capacités des modèles visionnels et linguistiques après pré-entraînement. La fine-tuning n'en permettrait qu'à ces modèles d'exploiter des artefacts ou des biais statistiques dans les données. Et nous savons que ces modèles aiment tricher et prendre des raccourcis. Et comme nous l'avons dit, nous sommes intéressés à évaluer quelles capacités les modèles visionnels et linguistiques ont après pré-entraînement. Nous expérimentons avec cinq modèles visionnels et linguistiques sur VAlues, à savoir CLIP, LXMERT, ViLBERT, ViLBERT 12 in 1 et VisualBert. Deux de nos métriques d'évaluation les plus importantes sont la précision des modèles à classer les paires d'images et de phrases en légendes et foils. Peut-être plus important pour ce vidéo, nous montrerons notre métrique plus permissive, la précision par paire, qui mesure si le score d'alignement d'image et de phrase est supérieur pour la paire d'image et de texte correcte que pour sa paire de légende et de foil. Les résultats avec la précision par paire sont montrés ici, et ils sont cohérents avec les résultats que nous avons obtenus d'autres métriques. Il est à noter que les instruments centrés sur les objets individuels, comme l'existence et les phrases nominales, sont presque résolus par ViLBERT 12 in 1, ce qui souligne que les modèles sont capables d'identifier les objets nommés et leur présence dans les images. Cependant, aucun des autres instruments ne peut être résolu dans nos réglages de foiling adversaires. Nous voyons des instruments de pluralité et de comptage, ce qui montre que les modèles visionnels et linguistiques ont du mal à distinguer les références à un seul objet par rapport à plusieurs objets, ou à les compter dans une image. Les instruments de relation montrent que les modèles visionnels et linguistiques ont du mal à classer correctement une relation spatiale nommée entre les objets dans une image. Ils ont également du mal à distinguer les actions et à identifier les participants, même s'ils sont soutenus par des biais de plausibilité, comme nous voyons dans le jeu des actions. De la pièce de référence, nous découvrons que tracer plusieurs références à la même entité dans une image par des pronoms est également difficile pour les modèles visionnels et linguistiques. En tant que contrôle de la santé, et parce qu'il est un exercice intéressant, nous évaluons également deux modèles textuels, GPT1 et GPT2, pour évaluer si VAlues est résolvable par ces modèles unidimensionnels en calculant la perplexité de la légende correcte et de la légende de foil. Si la perplexité est plus élevée pour la légende de foil, nous prenons cela comme un indicateur que la légende de foil souffre d'un biais de plausibilité ou d'autres biais linguistiques. Et c'est intéressant de voir que dans certains cas, les modèles textuels GPT ont capturé la plausibilité du monde mieux que les modèles visionnels et linguistiques. En résumé, VAlues est un benchmark qui utilise la lentille des constructions linguistiques pour aider la communauté à améliorer les modèles visionnels et linguistiques en testant leurs capacités de fondement visuel. Nos expériences montrent que les modèles visionnels et linguistiques identifient bien les objets nommés et leur présence dans les images, comme le montre la pièce d'existence, mais ont du mal à ancrer leur interdépendance et leurs relations dans les scènes visuelles lorsqu'ils sont forcés de respecter les indicateurs linguistiques. Nous aimerions vraiment encourager la communauté à utiliser VAlues pour mesurer les progrès vers l'ancrage linguistique avec les modèles visionnels et linguistiques. Et VAlues pourrait également être utilisé comme une évaluation indirecte des ensembles de données, car les modèles pourraient être évalués avant et après l'entraînement ou la fine-tuning pour voir si un ensemble de données aide les modèles à améliorer l'un des aspects testés par VAlues. Si vous êtes intéressé, veuillez consulter les données VAlues sur Github, et si vous avez des questions, n'hésitez pas à nous contacter."}
{"dataset_id": "acl_6060", "sample_id": 420, "src_lang": "en", "tgt_lang": "fr", "output": "Bonjour, je m'appelle Kamisaka de l'Université de Tokyo. Je vais présenter un papier intitulé \"RNSUM, un ensemble de données à grande échelle pour la génération automatique de notes de version via la résumé des logs\". Je vais expliquer dans cet ordre. D'abord, je vais introduire la génération automatique de notes de version que nous travaillons dans cette recherche. Une note de version est un document technique qui résume les changements distribués avec chaque version d'un logiciel. L'image montre les notes de version pour la version 2.4 de la bibliothèque bj. Les notes de version jouent un rôle important dans le développement open source, mais elles sont chronophages à préparer manuellement. Par conséquent, il serait très utile d'être en mesure de générer automatiquement des notes de version de haute qualité. Je vais faire référence à deux recherches précédentes sur la génération automatique de notes de version. La première est un système appelé Alena, sorti en 2014. Il prend un approche basée sur les règles, par exemple, en utilisant l'extracteur de changements pour extraire les différences de bibliothèques et documenter les changements entre les versions, et enfin les combiner. La plus notable caractéristique de ce système est l'extracteur d'issues dans la coin en haut à droite, qui doit être lié au système de ticket d'issue, et peut être appliqué qu'à des projets qui utilisent Jira. En d'autres mots, il ne peut pas être utilisé pour de nombreux projets sur Github. La deuxième est Grrriff, récemment annoncé en 2020. Il est disponible sur Internet et peut être installé via pip. Ce système a un modèle de classification de texte simple et génère une des quatre probabilités, telles que les fonctionnalités ou les corrections de bogues pour chaque message de commit. L'image est un usage de exemple qui retourne une note de correction de correctifs. La formation de Grrriff est assez petite, environ 5000, et sera montrée dans les expériences décrites ci-dessous. La performance du modèle de classification de texte n'est pas élevée. Je présente deux recherches liées, mais elles ont des problèmes d'applicabilité limitée et des ressources de données insuffisantes. Notre papier résout ces deux problèmes et génère automatiquement des notes de version de haute qualité. Pour le problème d'applicabilité limitée, nous proposons un moyen de résumé de classe de haute qualité en utilisant uniquement les messages de commit comme entrée. Ce moyen peut être utilisé pour tous les répertoires en anglais. Pour le deuxième problème de ressources de données insuffisantes, nous avons construit un ensemble de données RNSUM composé de 82000 pièces de données en collectant des données de répertoires publics via l'API de Github. Ensuite, je décris notre ensemble de données. Voici un exemple de données, le côté gauche est le message de commit et le côté droit est la note de version. Les notes de version sont étiquetées comme améliorations, corrections de bogues, etc. Nous avons défini quatre étiquettes : fonctionnalités, améliorations, corrections de bogues, suppressions et changements de rupture. Ces étiquettes sont fixées sur la base de recherches précédentes et d'autres facteurs. La note de version sur le bas droit et les données extraites des messages de commit sont montrées sur le bas gauche. À ce moment-là, il est nécessaire de détecter les quatre étiquettes qui ont été définies à l'avance. Mais les étiquettes ne sont pas toujours cohérentes avec chaque répertoire. Par exemple, l' étiquette d'améliorations inclut améliorations, améliorations, optimisations, etc. Nous avons préparé une liste de vocabulaire de notes de version pour chaque variation de notation. Utilisez-la pour détecter la classe de note de version et corrigez le texte de la note de version qui suit comme phrase de note. Ensuite, est un message de commit. Les messages de commit ne sont pas liés à chaque version de release. Comme montré dans l'image ci-dessous, si la version actuelle est 2.5 à 19, nous devons identifier la version précédente 2.5 à 18 et obtenir sa différence. Cela est un peu fastidieux, et ce n'est pas suffisant pour simplement obtenir une liste de versions de release et regarder les versions avant et après. Nous avons créé une règle heuristique pour obtenir les versions précédentes et suivantes. Les méthodes de résumé. À la fin, 7200 répertoires et 82 000 pièces de données ont été collectées. De plus, le nombre moyen de tokens de note de version est de 63, ce qui est assez élevé pour une tâche de résumé. De plus, le nombre de tokens uniques est assez élevé, à 8 830 000. Cela est dû à la grande quantité de noms de classe et de méthodes trouvés dans le répertoire. Ensuite, je décris le modèle proposé. Le modèle de résumé de classe puis abstrait consiste en deux modules neuronaux, un classificateur utilisant ou code bart et un générateur utilisant bart. D'abord, CEAS utilise un classificateur pour classer chaque message de commit en cinq classes de notes de version : fonctionnalités, améliorations, corrections de bogues, suppressions et changements de rupture. Les messages de commit classifiés comme autres sont rejetés. Ensuite, CEAS applique le générateur à chaque document de note de version indépendamment et génère une note de version pour chaque classe. Dans cette tâche, les correspondances directes entre les messages de commit et les notes de version ne sont pas connues. Par conséquent, pour entraîner le classificateur, nous modélisons le modèle de résumé abstrait en utilisant deux méthodes différentes. Le premier modèle, que nous appelons CAS single, consiste en un réseau de séquence à séquence unique et génère un texte de note de version unique en fonction des messages de commit concaténés. Le texte de sortie peut être divisé en segments de classe basés sur des symboles d'endpoint spécifiques. La deuxième méthode, que nous appelons CAS multi, consiste en quatre réseaux de séquence à séquence différents, chacun correspondant à une des classes de notes de version. D'accord, laissez-moi expliquer l'expérimentation. Nous avons comparé cinq méthodes : CEAS, CAS single, CAS multi, clustering et le précédent étude G Riff. En ce qui concerne l'évaluation, dans certains cas, les notes de version sont sorties en plusieurs phrases. Comme il est difficile de compter le nombre de phrases, car elles sont combinées avec des espaces et traitées comme une seule phrase. Le bleu est pénalisé lorsque le système produit une phrase courte. Cela résulte en un score bleu plus bas dans les résultats des expériences décrites ci-dessous. Enfin, nous calculons la spécificité, car rouge et bleu ne peuvent pas être calculés si les notes de version sont vides. Une spécificité plus élevée signifie que le modèle produit correctement un texte vides dans les cas où les notes de version supposent vides. Voici les résultats. Étant donné que le dataset contient adresses e-mail, valeurs de hachage, etc., nous évaluons également le dataset nettoyé, qui exclut ces éléments. CEAS et CAS ont obtenu des scores bleu plus de 10 points que les baselines. En particulier, sur le dataset nettoyé, la différence de score entre le proposé et les baselines a grimpé à plus de 20 points. Ces résultats indiquent que CEAS et CAS sont significativement efficaces. CAS a obtenu un score bleu plus élevé que CAS, suggérant que combiner un classificateur et un générateur est efficace et que l'entraînement du classificateur en utilisant des pseudo-étiquettes à chaque message de commit est possible. Une large couverture de CAS peut être atteinte correctement parce que le classificateur peut sélectionner les messages de commit pertinents pour chaque classe. CAS multi a tendance à être plus élevé que CAS single, suggérant que cela est également efficace. De plus, il est efficace de développer des modèles de résumé abstrait différents pour chaque classe de note de version. Voici une analyse des erreurs. Les méthodes CEAS ont tendance à produire des phrases de note de version plus courtes que les phrases de note de version humaines. Dans la figure à droite, la phrase de note de version humaine a trois ou quatre phrases, tandis que CAS a seulement une. La raison de cette tendance plus petite est que, dans les données d'entraînement, seulement 33 % des phrases sont présentes dans la classe de features et 40 % dans la classe d'améliorations. De plus, les méthodes CEAS ne peuvent pas générer des notes de version de release exactes sans informations supplémentaires. L'exemple ci-dessous montre un message de commit très sale et le texte de correction de bogues complet. Sans référence à la requête de prérequisition ou au problème, le message de commit d'entrée est lié et devrait être combiné en une seule phrase, mais il échoue à le faire."}
